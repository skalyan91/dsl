#TITLE: branch notes regarding lex-numbers-3

* Goals

** within a ~DECIDE~ rule, we want to approximate the affordances of haskell function definitions

*** typed input parameters: ~GIVEN~

a typed input dictionary, similar to Python

 #+begin_src text
    GIVEN p IS A Person
          d IS A Date
   DECIDE p Qualifies
     WHEN p walks
      AND p eats
       OR p drinks
   UNLESS d IS quiet holiday
 #+end_src

*** typed output parameters

keyword ~GIVETH~

a typed output dictionary, similar to Python, same internal syntax as ~GIVEN~

#+begin_src text
       ยง waddington 1
   GIVEN p IS A  Person
         d IS A  Date
  GIVETH a IS AN Action
         s IS A  Title
  DECIDE a IS sing
         s IS Happy Birthday
    WHEN p walks
     AND p eats
      OR p drinks
  UNLESS d IS quiet holiday
#+end_src

Natural language text: 
#+begin_example
For the purposes of this section,
the Action and the Title
are "sing" and "Happy Birthday" respectively
when, given a person and a date,
the person walks and eats or drinks
unless it is a quiet holiday on the given date.
#+end_example

Haskell directly:
#+begin_src haskell
  waddington_1 :: Person -> Date -> Maybe (Action, Title)
  waddington_1 p d
    | not (quietHoliday d) &&
      walks p && (eats p || drinks p) = Just (sing, "Happy Birthday")
    | otherwise = Nothing
#+end_src
 
Haskell in a more interpretive, contemplative manner:
#+begin_src haskell
  type VarName = String
  type VarType = String
  type VarVal  = String
  type RuleName = String
  type SymbolTable = Map.Map VarName (VarType, VarVal)

  sub :: [Varname] -> Reader SymbolTable a
  sub ks = local $ filterWithKey (`elem` ks) rm

  (-:) :: RuleName -> VarName -> Reader SymbolTable Boolean
  (-:) rn vn = let withReader ... (sub [vn] $ evald rn)
               in fromMaybe ("Boolean", False) (out Map.! "RETURN") -- i got your negation as failure right here

  evald :: RuleName -> Reader SymbolTable (Maybe SymbolTable) -- in future update the return value to Maybe [RelationalPredicate]
  evald "waddington 1" =
    | (&&)
      <$> fmap not ("quiet holiday" -: "d")
      <*> ( (&&)
            <$> "walks" -: "p"
            <*> ( (||)
                  <$> "eats" -: "p"
                  <*> "drinks" -: "p" )
          ) = return $ pure (fromList [("a","sing"), ("s","Happy Birthday")])
    | otherwise = return Nothing
#+end_src

*** ~let~ in the body of the function

*** ~where~ at the end of a function

** we want to add better support for local vs global variables

*** in a ruleset, top-level definitions are global

*** within a rule, what do we do about unqualified variables

**** can we uniquely ~with~ them to an in-scope variable?

See Pascal's treatment of ~WITH~, which is different from Python's

https://www.freepascal.org/docs-html/ref/refsu62.html

***** we might need advanced CNL management

to allow trees that look like this

 #+begin_src text
    GIVEN p IS A Person
          d IS A Date
   DECIDE p mustSing
     WHEN p       walks
             AND  eats
              OR  drinks
   UNLESS d IS quiet holiday
 #+end_src


