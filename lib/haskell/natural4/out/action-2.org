* preface
:PROPERTIES:
:VISIBILITY: folded
:END:

natural4> test (suite: natural4-test, args: --match "/parser elements and fragments ... should parse/action-2/")

* Tokens
DO
    ( "win" ( "gloriously" ) )
* main
:PROPERTIES:
:VISIBILITY: children
:END:

** / pDoAction/Do                                                                                                      :1_1:Do:
pDoAction/Do> IN: DO ( "win" ( "gloriously" ) )
pDoAction/Do> MATCH (COK): DO
pDoAction/Do> VALUE: (Do,[])

** \ pDoAction/Do has returned Do                                                                                       :1_2:GoDeeper:
** / pDoAction/pAction                                                                                                  :1_2:GoDeeper:
*** / pAction calling dBoolStructP                                                                                     :1_2:GoDeeper:
**** / dBoolStructP calling exprP                                                                                     :1_2:GoDeeper:
***** / expr pParamText                                                                                              :1_2:GoDeeper:
****** / expression                                                                                                 :1_2:GoDeeper:
******* / labelPrefix                                                                                              :1_2:GoDeeper:
labelPrefix> IN: ( "win" ( "gloriously" ) )
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=1:
labelPrefix> unexpected (
labelPrefix> expecting Other text

******* / term p                                                                                                   :1_2:GoDeeper:
******** / term p/notLabelTerm                                                                                    :1_2:GoDeeper:
********* / term p/2:someIndentation expr p                                                                      :1_2:GoDeeper:
********** / someIndentation                                                                                    :1_2:GoDeeper:
*********** / myindented: consuming GoDeeper                                                                   :1_2:GoDeeper:
myindented: consuming GoDeeper> IN: ( "win" ( "gloriously" ) )
myindented: consuming GoDeeper> MATCH (COK): (
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

*********** \ myindented: consuming GoDeeper has returned GoDeeper                                              :1_2:Other "win":
*********** / manyIndentation/leaf?                                                                             :1_2:Other "win":
************ / expression                                                                                      :1_2:Other "win":
************* / labelPrefix                                                                                   :1_2:Other "win":
labelPrefix> IN: "win" ( "gloriously" ) )
labelPrefix> MATCH (COK): "win"
labelPrefix> VALUE: ("win",[])

************* \ labelPrefix has returned "win"                                                                 :1_3:GoDeeper:
************* / term p                                                                                         :1_3:GoDeeper:
************** / term p/notLabelTerm                                                                          :1_3:GoDeeper:
*************** / term p/2:someIndentation expr p                                                            :1_3:GoDeeper:
**************** / someIndentation                                                                          :1_3:GoDeeper:
***************** / myindented: consuming GoDeeper                                                         :1_3:GoDeeper:
myindented: consuming GoDeeper> IN: ( "gloriously" ) )
myindented: consuming GoDeeper> MATCH (COK): (
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

***************** \ myindented: consuming GoDeeper has returned GoDeeper                                    :1_3:Other "glor:
***************** / manyIndentation/leaf?                                                                   :1_3:Other "glor:
****************** / expression                                                                            :1_3:Other "glor:
******************* / labelPrefix                                                                         :1_3:Other "glor:
labelPrefix> IN: "gloriously" ) )
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=5:
labelPrefix> unexpected )

******************* / term p                                                                              :1_3:Other "glor:
******************** / term p/notLabelTerm                                                               :1_3:Other "glor:
********************* / term p/2:someIndentation expr p                                                 :1_3:Other "glor:
********************** / someIndentation                                                               :1_3:Other "glor:
*********************** / myindented: consuming GoDeeper                                              :1_3:Other "glor:
myindented: consuming GoDeeper> IN: "gloriously" ) )
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=4:
myindented: consuming GoDeeper> unexpected "gloriously"
myindented: consuming GoDeeper> expecting (

someIndentation> IN: "gloriously" ) )
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=4:
someIndentation> unexpected "gloriously"
someIndentation> expecting (

term p/2:someIndentation expr p> IN: "gloriously" ) )
term p/2:someIndentation expr p> MATCH (EERR): <EMPTY>
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=4:
term p/2:someIndentation expr p> unexpected "gloriously"
term p/2:someIndentation expr p> expecting (

********************* / term p/3:plain p                                                                :1_3:Other "glor:
********************** / pParamText                                                                    :1_3:Other "glor:
*********************** / pParamText(flat) first line: pKeyValues                                     :1_3:Other "glor:
************************ / pKeyValuesAka                                                             :1_3:Other "glor:
************************* / slAKA                                                                   :1_3:Other "glor:
************************** / $*|                                                                   :1_3:Other "glor:
*************************** / slAKA base                                                          :1_3:Other "glor:
**************************** / slKeyValues                                                       :1_3:Other "glor:
***************************** / $*|                                                             :1_3:Other "glor:
****************************** / someSL                                                        :1_3:Other "glor:
someSL> IN: "gloriously" ) )
someSL> MATCH (COK): "gloriously"
someSL> VALUE: ((["gloriously"],0),[])

****************************** \ someSL has returned (["gloriously"],0)                       :1_2:UnDeeper:
$*|> IN: "gloriously" ) )
$*|> MATCH (COK): "gloriously"
$*|> VALUE: ((["gloriously"],0),[])

***************************** \ $*| has returned (["gloriously"],0)                            :1_2:UnDeeper:
***************************** / |>>/recurse                                                    :1_2:UnDeeper:
|>>/recurse> IN: ) )
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=5:
|>>/recurse> unexpected )
|>>/recurse> expecting (

***************************** / |>>/base                                                       :1_2:UnDeeper:
****************************** / |?| optional something                                       :1_2:UnDeeper:
******************************* / |>>/recurse                                                :1_2:UnDeeper:
|>>/recurse> IN: ) )
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=5:
|>>/recurse> unexpected )
|>>/recurse> expecting (

******************************* / |>>/base                                                   :1_2:UnDeeper:
******************************** / slTypeSig                                                :1_2:UnDeeper:
********************************* / $>|                                                    :1_2:UnDeeper:
$>|> IN: ) )
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=5:
$>|> unexpected )
$>|> expecting :: or IS

slTypeSig> IN: ) )
slTypeSig> MATCH (EERR): <EMPTY>
slTypeSig> ERROR:
slTypeSig> offset=5:
slTypeSig> unexpected )
slTypeSig> expecting :: or IS

|>>/base> IN: ) )
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=5:
|>>/base> unexpected )
|>>/base> expecting :: or IS

|?| optional something> IN: ) )
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

****************************** \ |?| optional something has returned (Nothing,0)              :1_2:UnDeeper:
****************************** > |>>/base got Nothing                                         :1_2:UnDeeper:
|>>/base> IN: ) )
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

***************************** \ |>>/base has returned (Nothing,0)                              :1_2:UnDeeper:
slKeyValues> IN: "gloriously" ) )
slKeyValues> MATCH (COK): "gloriously"
slKeyValues> VALUE: ((("gloriously" :| [],Nothing),0),[])

**************************** \ slKeyValues has returned (("gloriously" :| [],Nothing),0)        :1_2:UnDeeper:
slAKA base> IN: "gloriously" ) )
slAKA base> MATCH (COK): "gloriously"
slAKA base> VALUE: ((("gloriously" :| [],Nothing),0),[])

*************************** \ slAKA base has returned (("gloriously" :| [],Nothing),0)           :1_2:UnDeeper:
$*|> IN: "gloriously" ) )
$*|> MATCH (COK): "gloriously"
$*|> VALUE: ((("gloriously" :| [],Nothing),0),[])

************************** \ $*| has returned (("gloriously" :| [],Nothing),0)                    :1_2:UnDeeper:
************************** / |>>/recurse                                                          :1_2:UnDeeper:
|>>/recurse> IN: ) )
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=5:
|>>/recurse> unexpected )
|>>/recurse> expecting (

************************** / |>>/base                                                             :1_2:UnDeeper:
*************************** / slAKA optional akapart                                             :1_2:UnDeeper:
**************************** / |?| optional something                                           :1_2:UnDeeper:
***************************** / |>>/recurse                                                    :1_2:UnDeeper:
|>>/recurse> IN: ) )
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=5:
|>>/recurse> unexpected )
|>>/recurse> expecting (

***************************** / |>>/base                                                       :1_2:UnDeeper:
****************************** / PAKA/akapart                                                 :1_2:UnDeeper:
******************************* / $>|                                                        :1_2:UnDeeper:
******************************** / Aka Token                                                :1_2:UnDeeper:
Aka Token> IN: ) )
Aka Token> MATCH (EERR): <EMPTY>
Aka Token> ERROR:
Aka Token> offset=5:
Aka Token> unexpected )
Aka Token> expecting AKA

$>|> IN: ) )
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=5:
$>|> unexpected )
$>|> expecting AKA

PAKA/akapart> IN: ) )
PAKA/akapart> MATCH (EERR): <EMPTY>
PAKA/akapart> ERROR:
PAKA/akapart> offset=5:
PAKA/akapart> unexpected )
PAKA/akapart> expecting AKA

|>>/base> IN: ) )
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=5:
|>>/base> unexpected )
|>>/base> expecting AKA

|?| optional something> IN: ) )
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

**************************** \ |?| optional something has returned (Nothing,0)                  :1_2:UnDeeper:
slAKA optional akapart> IN: ) )
slAKA optional akapart> MATCH (EOK): <EMPTY>
slAKA optional akapart> VALUE: ((Nothing,0),[])

*************************** \ slAKA optional akapart has returned (Nothing,0)                    :1_2:UnDeeper:
*************************** > |>>/base got Nothing                                               :1_2:UnDeeper:
|>>/base> IN: ) )
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************************** \ |>>/base has returned (Nothing,0)                                    :1_2:UnDeeper:
************************** / |>>/recurse                                                          :1_2:UnDeeper:
|>>/recurse> IN: ) )
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=5:
|>>/recurse> unexpected )
|>>/recurse> expecting (

************************** / |>>/base                                                             :1_2:UnDeeper:
*************************** / slAKA optional typically                                           :1_2:UnDeeper:
**************************** / |?| optional something                                           :1_2:UnDeeper:
***************************** / |>>/recurse                                                    :1_2:UnDeeper:
|>>/recurse> IN: ) )
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=5:
|>>/recurse> unexpected )
|>>/recurse> expecting (

***************************** / |>>/base                                                       :1_2:UnDeeper:
****************************** / typically                                                    :1_2:UnDeeper:
******************************* / $>|                                                        :1_2:UnDeeper:
$>|> IN: ) )
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=5:
$>|> unexpected )
$>|> expecting TYPICALLY

typically> IN: ) )
typically> MATCH (EERR): <EMPTY>
typically> ERROR:
typically> offset=5:
typically> unexpected )
typically> expecting TYPICALLY

|>>/base> IN: ) )
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=5:
|>>/base> unexpected )
|>>/base> expecting TYPICALLY

|?| optional something> IN: ) )
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

**************************** \ |?| optional something has returned (Nothing,0)                  :1_2:UnDeeper:
slAKA optional typically> IN: ) )
slAKA optional typically> MATCH (EOK): <EMPTY>
slAKA optional typically> VALUE: ((Nothing,0),[])

*************************** \ slAKA optional typically has returned (Nothing,0)                  :1_2:UnDeeper:
*************************** > |>>/base got Nothing                                               :1_2:UnDeeper:
|>>/base> IN: ) )
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************************** \ |>>/base has returned (Nothing,0)                                    :1_2:UnDeeper:
************************** > slAKA: proceeding after base and entityalias are retrieved ...       :1_2:UnDeeper:
************************** > pAKA: entityalias = Nothing                                          :1_2:UnDeeper:
slAKA> IN: "gloriously" ) )
slAKA> MATCH (COK): "gloriously"
slAKA> VALUE: ((("gloriously" :| [],Nothing),0),[])

************************* \ slAKA has returned (("gloriously" :| [],Nothing),0)                    :1_2:UnDeeper:
************************* / undeepers                                                              :1_2:UnDeeper:
************************** > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers :1_2:UnDeeper:
************************** > sameLine: success!                                                   :1_2:UnDeeper:
undeepers> IN: ) )
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

************************* \ undeepers has returned ()                                              :1_2:UnDeeper:
pKeyValuesAka> IN: "gloriously" ) )
pKeyValuesAka> MATCH (COK): "gloriously"
pKeyValuesAka> VALUE: (("gloriously" :| [],Nothing),[])

************************ \ pKeyValuesAka has returned ("gloriously" :| [],Nothing)                  :1_2:UnDeeper:
pParamText(flat) first line: pKeyValues> IN: "gloriously" ) )
pParamText(flat) first line: pKeyValues> MATCH (COK): "gloriously"
pParamText(flat) first line: pKeyValues> VALUE: (("gloriously" :| [],Nothing),[])

*********************** \ pParamText(flat) first line: pKeyValues has returned ("gloriously" :| [],Nothing) :1_2:UnDeeper:
*********************** / pParamText(flat) subsequent lines: sameMany pKeyValues                     :1_2:UnDeeper:
************************ / manyIndentation/leaf?                                                    :1_2:UnDeeper:
************************* / sameMany                                                               :1_2:UnDeeper:
************************** / pKeyValuesAka                                                        :1_2:UnDeeper:
*************************** / slAKA                                                              :1_2:UnDeeper:
**************************** / $*|                                                              :1_2:UnDeeper:
***************************** / slAKA base                                                     :1_2:UnDeeper:
****************************** / slKeyValues                                                  :1_2:UnDeeper:
******************************* / $*|                                                        :1_2:UnDeeper:
******************************** / someSL                                                   :1_2:UnDeeper:
********************************* / pNumAsText                                             :1_2:UnDeeper:
pNumAsText> IN: ) )
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=5:
pNumAsText> unexpected )
pNumAsText> expecting number

someSL> IN: ) )
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=5:
someSL> unexpected )
someSL> expecting other text or number

$*|> IN: ) )
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=5:
$*|> unexpected )
$*|> expecting other text or number

slKeyValues> IN: ) )
slKeyValues> MATCH (EERR): <EMPTY>
slKeyValues> ERROR:
slKeyValues> offset=5:
slKeyValues> unexpected )
slKeyValues> expecting other text or number

slAKA base> IN: ) )
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=5:
slAKA base> unexpected )
slAKA base> expecting other text or number

$*|> IN: ) )
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=5:
$*|> unexpected )
$*|> expecting other text or number

slAKA> IN: ) )
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=5:
slAKA> unexpected )
slAKA> expecting other text or number

pKeyValuesAka> IN: ) )
pKeyValuesAka> MATCH (EERR): <EMPTY>
pKeyValuesAka> ERROR:
pKeyValuesAka> offset=5:
pKeyValuesAka> unexpected )
pKeyValuesAka> expecting other text or number

sameMany> IN: ) )
sameMany> MATCH (EOK): <EMPTY>
sameMany> VALUE: ([],[])

************************* \ sameMany has returned []                                               :1_2:UnDeeper:
manyIndentation/leaf?> IN: ) )
manyIndentation/leaf?> MATCH (EOK): <EMPTY>
manyIndentation/leaf?> VALUE: ([],[])

************************ \ manyIndentation/leaf? has returned []                                    :1_2:UnDeeper:
pParamText(flat) subsequent lines: sameMany pKeyValues> IN: ) )
pParamText(flat) subsequent lines: sameMany pKeyValues> MATCH (EOK): <EMPTY>
pParamText(flat) subsequent lines: sameMany pKeyValues> VALUE: ([],[])

*********************** \ pParamText(flat) subsequent lines: sameMany pKeyValues has returned []     :1_2:UnDeeper:
pParamText> IN: "gloriously" ) )
pParamText> MATCH (COK): "gloriously"
pParamText> VALUE: (("gloriously" :| [],Nothing) :| [],[])

********************** \ pParamText has returned ("gloriously" :| [],Nothing) :| []                   :1_2:UnDeeper:
term p/3:plain p> IN: "gloriously" ) )
term p/3:plain p> MATCH (COK): "gloriously"
term p/3:plain p> VALUE: (MyLeaf (("gloriously" :| [],Nothing) :| []),[])

********************* \ term p/3:plain p has returned MyLeaf (("gloriously" :| [],Nothing) :| [])      :1_2:UnDeeper:
term p/notLabelTerm> IN: "gloriously" ) )
term p/notLabelTerm> MATCH (COK): "gloriously"
term p/notLabelTerm> VALUE: (MyLeaf (("gloriously" :| [],Nothing) :| []),[])

******************** \ term p/notLabelTerm has returned MyLeaf (("gloriously" :| [],Nothing) :| [])     :1_2:UnDeeper:
term p> IN: "gloriously" ) )
term p> MATCH (COK): "gloriously"
term p> VALUE: (MyLeaf (("gloriously" :| [],Nothing) :| []),[])

******************* \ term p has returned MyLeaf (("gloriously" :| [],Nothing) :| [])                    :1_2:UnDeeper:
******************* / binary(Or)                                                                         :1_2:UnDeeper:
binary(Or)> IN: ) )
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=5:
binary(Or)> unexpected )
binary(Or)> expecting OR

******************* / binary(And)                                                                        :1_2:UnDeeper:
binary(And)> IN: ) )
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=5:
binary(And)> unexpected )
binary(And)> expecting AND

******************* / binary(SetLess)                                                                    :1_2:UnDeeper:
binary(SetLess)> IN: ) )
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=5:
binary(SetLess)> unexpected )
binary(SetLess)> expecting LESS

******************* / binary(SetPlus)                                                                    :1_2:UnDeeper:
binary(SetPlus)> IN: ) )
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=5:
binary(SetPlus)> unexpected )
binary(SetPlus)> expecting PLUS

expression> IN: "gloriously" ) )
expression> MATCH (COK): "gloriously"
expression> VALUE: (MyLeaf (("gloriously" :| [],Nothing) :| []),[])

****************** \ expression has returned MyLeaf (("gloriously" :| [],Nothing) :| [])                  :1_2:UnDeeper:
manyIndentation/leaf?> IN: "gloriously" ) )
manyIndentation/leaf?> MATCH (COK): "gloriously"
manyIndentation/leaf?> VALUE: (MyLeaf (("gloriously" :| [],Nothing) :| []),[])

***************** \ manyIndentation/leaf? has returned MyLeaf (("gloriously" :| [],Nothing) :| [])         :1_2:UnDeeper:
***************** / myindented: consuming UnDeeper                                                         :1_2:UnDeeper:
myindented: consuming UnDeeper> IN: ) )
myindented: consuming UnDeeper> MATCH (COK): )
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

***************** \ myindented: consuming UnDeeper has returned UnDeeper                                     :1_3:UnDeeper:
someIndentation> IN: ( "gloriously" ) )
someIndentation> MATCH (COK): ( "gloriously" )
someIndentation> VALUE: (MyLeaf (("gloriously" :| [],Nothing) :| []),[])

**************** \ someIndentation has returned MyLeaf (("gloriously" :| [],Nothing) :| [])                   :1_3:UnDeeper:
term p/2:someIndentation expr p> IN: ( "gloriously" ) )
term p/2:someIndentation expr p> MATCH (COK): ( "gloriously" )
term p/2:someIndentation expr p> VALUE: (MyLeaf (("gloriously" :| [],Nothing) :| []),[])

*************** \ term p/2:someIndentation expr p has returned MyLeaf (("gloriously" :| [],Nothing) :| [])     :1_3:UnDeeper:
term p/notLabelTerm> IN: ( "gloriously" ) )
term p/notLabelTerm> MATCH (COK): ( "gloriously" )
term p/notLabelTerm> VALUE: (MyLeaf (("gloriously" :| [],Nothing) :| []),[])

************** \ term p/notLabelTerm has returned MyLeaf (("gloriously" :| [],Nothing) :| [])                   :1_3:UnDeeper:
term p> IN: ( "gloriously" ) )
term p> MATCH (COK): ( "gloriously" )
term p> VALUE: (MyLeaf (("gloriously" :| [],Nothing) :| []),[])

************* \ term p has returned MyLeaf (("gloriously" :| [],Nothing) :| [])                                  :1_3:UnDeeper:
************* / binary(Or)                                                                                       :1_3:UnDeeper:
binary(Or)> IN: )
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=6:
binary(Or)> unexpected )
binary(Or)> expecting OR

************* / binary(And)                                                                                      :1_3:UnDeeper:
binary(And)> IN: )
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=6:
binary(And)> unexpected )
binary(And)> expecting AND

************* / binary(SetLess)                                                                                  :1_3:UnDeeper:
binary(SetLess)> IN: )
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=6:
binary(SetLess)> unexpected )
binary(SetLess)> expecting LESS

************* / binary(SetPlus)                                                                                  :1_3:UnDeeper:
binary(SetPlus)> IN: )
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=6:
binary(SetPlus)> unexpected )
binary(SetPlus)> expecting PLUS

expression> IN: "win" ( "gloriously" ) )
expression> MATCH (COK): "win" ( "gloriously" )
expression> VALUE: (MyLabel ["win"] (MyLeaf (("gloriously" :| [],Nothing) :| [])),[])

************ \ expression has returned MyLabel ["win"] (MyLeaf (("gloriously" :| [],Nothing) :| []))              :1_3:UnDeeper:
manyIndentation/leaf?> IN: "win" ( "gloriously" ) )
manyIndentation/leaf?> MATCH (COK): "win" ( "gloriously" )
manyIndentation/leaf?> VALUE: (MyLabel ["win"] (MyLeaf (("gloriously" :| [],Nothing) :| [])),[])

*********** \ manyIndentation/leaf? has returned MyLabel ["win"] (MyLeaf (("gloriously" :| [],Nothing) :| []))     :1_3:UnDeeper:
*********** / myindented: consuming UnDeeper                                                                       :1_3:UnDeeper:
myindented: consuming UnDeeper> IN: )
myindented: consuming UnDeeper> MATCH (COK): )
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

*********** \ myindented: consuming UnDeeper has returned UnDeeper                                          :EOF:
someIndentation> IN: ( "win" ( "gloriously" ) )
someIndentation> MATCH (COK): ( "win" ( "gloriously" ) )
someIndentation> VALUE: (MyLabel ["win"] (MyLeaf (("gloriously" :| [],Nothing) :| [])),[])

********** \ someIndentation has returned MyLabel ["win"] (MyLeaf (("gloriously" :| [],Nothing) :| []))      :EOF:
term p/2:someIndentation expr p> IN: ( "win" ( "gloriously" ) )
term p/2:someIndentation expr p> MATCH (COK): ( "win" ( "gloriously" ) )
term p/2:someIndentation expr p> VALUE: (MyLabel ["win"] (MyLeaf (("gloriously" :| [],Nothing) :| [])),[])

********* \ term p/2:someIndentation expr p has returned MyLabel ["win"] (MyLeaf (("gloriously" :| [],Nothing) :| [])) :EOF:
term p/notLabelTerm> IN: ( "win" ( "gloriously" ) )
term p/notLabelTerm> MATCH (COK): ( "win" ( "gloriously" ) )
term p/notLabelTerm> VALUE: (MyLabel ["win"] (MyLeaf (("gloriously" :| [],Nothing) :| [])),[])

******** \ term p/notLabelTerm has returned MyLabel ["win"] (MyLeaf (("gloriously" :| [],Nothing) :| []))      :EOF:
term p> IN: ( "win" ( "gloriously" ) )
term p> MATCH (COK): ( "win" ( "gloriously" ) )
term p> VALUE: (MyLabel ["win"] (MyLeaf (("gloriously" :| [],Nothing) :| [])),[])

******* \ term p has returned MyLabel ["win"] (MyLeaf (("gloriously" :| [],Nothing) :| []))                     :EOF:
******* / binary(Or)                                                                                            :EOF:
binary(Or)> IN: <EMPTY>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=7:
binary(Or)> unexpected end of input
binary(Or)> expecting OR

******* / binary(And)                                                                                           :EOF:
binary(And)> IN: <EMPTY>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=7:
binary(And)> unexpected end of input
binary(And)> expecting AND

******* / binary(SetLess)                                                                                       :EOF:
binary(SetLess)> IN: <EMPTY>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=7:
binary(SetLess)> unexpected end of input
binary(SetLess)> expecting LESS

******* / binary(SetPlus)                                                                                       :EOF:
binary(SetPlus)> IN: <EMPTY>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=7:
binary(SetPlus)> unexpected end of input
binary(SetPlus)> expecting PLUS

expression> IN: ( "win" ( "gloriously" ) )
expression> MATCH (COK): ( "win" ( "gloriously" ) )
expression> VALUE: (MyLabel ["win"] (MyLeaf (("gloriously" :| [],Nothing) :| [])),[])

****** \ expression has returned MyLabel ["win"] (MyLeaf (("gloriously" :| [],Nothing) :| []))                   :EOF:
expr pParamText> IN: ( "win" ( "gloriously" ) )
expr pParamText> MATCH (COK): ( "win" ( "gloriously" ) )
expr pParamText> VALUE: (MyLeaf (("win" :| [],Nothing) :| [("gloriously" :| [],Nothing)]),[])

***** \ expr pParamText has returned MyLeaf (("win" :| [],Nothing) :| [("gloriously" :| [],Nothing)])             :EOF:
dBoolStructP calling exprP> IN: ( "win" ( "gloriously" ) )
dBoolStructP calling exprP> MATCH (COK): ( "win" ( "gloriously" ) )
dBoolStructP calling exprP> VALUE: (Leaf (("win" :| [],Nothing) :| [("gloriously" :| [],Nothing)]),[])

**** \ dBoolStructP calling exprP has returned Leaf (("win" :| [],Nothing) :| [("gloriously" :| [],Nothing)])      :EOF:
pAction calling dBoolStructP> IN: ( "win" ( "gloriously" ) )
pAction calling dBoolStructP> MATCH (COK): ( "win" ( "gloriously" ) )
pAction calling dBoolStructP> VALUE: (Leaf (("win" :| [],Nothing) :| [("gloriously" :| [],Nothing)]),[])

*** \ pAction calling dBoolStructP has returned Leaf (("win" :| [],Nothing) :| [("gloriously" :| [],Nothing)])      :EOF:
pDoAction/pAction> IN: ( "win" ( "gloriously" ) )
pDoAction/pAction> MATCH (COK): ( "win" ( "gloriously" ) )
pDoAction/pAction> VALUE: (Leaf (("win" :| [],Nothing) :| [("gloriously" :| [],Nothing)]),[])

** \ pDoAction/pAction has returned Leaf (("win" :| [],Nothing) :| [("gloriously" :| [],Nothing)])                   :EOF:

parser elements and fragments ... should parse
  action-2 FAILED [1]

Failures:

  test/Spec.hs:124:3: 
  1) parser elements and fragments ... should parse action-2
       expected: [(Leaf (("win" :| ["gloriously"],Nothing) :| []),[])]
        but got: [(Leaf (("win" :| [],Nothing) :| [("gloriously" :| [],Nothing)]),[])]

  To rerun use: --match "/parser elements and fragments ... should parse/action-2/"

Randomized with seed 291259240

Finished in 0.0053 seconds
1 example, 1 failure

natural4> Test suite natural4-test failed
Test suite failure for package natural4-0.1.0.0
    natural4-test:  exited with: ExitFailure 1
Logs printed to console

