* preface
:PROPERTIES:
:VISIBILITY: folded
:END:

natural4> test (suite: natural4-test, args: --match /PDPA/boolstructp-3/)

* Tokens
[Every,GoDeeper,Other "person",UnDeeper,Who,GoDeeper,GoDeeper,Other "is",GoDeeper,Other "immortal",GoDeeper,Typically,GoDeeper,Other "false",UnDeeper,UnDeeper,UnDeeper,UnDeeper,Or,GoDeeper,Other "has",GoDeeper,Other "health insurance",UnDeeper,UnDeeper,UnDeeper,May,GoDeeper,Other "sharpen knives",UnDeeper]
* main
:PROPERTIES:
:VISIBILITY: children
:END:

** / pRule                                                                                                             :1_1:Every:
*** / pRegRule                                                                                                        :1_1:Every:
**** / pRuleLabel                                                                                                    :1_1:Every:
***** / $>|                                                                                                         :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting RuleMarker 1 "\167"

pRuleLabel> IN: Every GoDeeper Other "person" UnDeeper W <…>
pRuleLabel> MATCH (EERR): <EMPTY>
pRuleLabel> ERROR:
pRuleLabel> offset=0:
pRuleLabel> unexpected Every
pRuleLabel> expecting RuleMarker 1 "\167"

**** / pRegRuleSugary                                                                                                :1_1:Every:
***** / someDeep                                                                                                    :1_1:Every:
****** / someDeep first part calls base directly                                                                   :1_1:Every:
someDeep first part calls base directly> IN: Every GoDeeper Other "person" UnDeeper W <…>
someDeep first part calls base directly> MATCH (EERR): <EMPTY>
someDeep first part calls base directly> ERROR:
someDeep first part calls base directly> offset=0:
someDeep first part calls base directly> unexpected Every
someDeep first part calls base directly> expecting Other text

someDeep> IN: Every GoDeeper Other "person" UnDeeper W <…>
someDeep> MATCH (EERR): <EMPTY>
someDeep> ERROR:
someDeep> offset=0:
someDeep> unexpected Every
someDeep> expecting Other text

pRegRuleSugary> IN: Every GoDeeper Other "person" UnDeeper W <…>
pRegRuleSugary> MATCH (EERR): <EMPTY>
pRegRuleSugary> ERROR:
pRegRuleSugary> offset=0:
pRegRuleSugary> unexpected Every
pRegRuleSugary> expecting Other text

**** / pRegRuleNormal                                                                                                :1_1:Every:
***** / permutationsReg                                                                                             :1_1:Every:
****** / regulative permutation with deontic-temporal                                                              :1_1:Every:
******* / WHERE                                                                                                   :1_1:Every:
WHERE> IN: Every GoDeeper Other "person" UnDeeper W <…>
WHERE> MATCH (EERR): <EMPTY>
WHERE> ERROR:
WHERE> offset=0:
WHERE> unexpected Every
WHERE> expecting Where

******* / preambleParamText:[Having]                                                                              :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting Having

preambleParamText:[Having]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleParamText:[Having]> MATCH (EERR): <EMPTY>
preambleParamText:[Having]> ERROR:
preambleParamText:[Having]> offset=0:
preambleParamText:[Having]> unexpected Every
preambleParamText:[Having]> expecting Having

******* / preambleParamText:[Given]                                                                               :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting Given

preambleParamText:[Given]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=0:
preambleParamText:[Given]> unexpected Every
preambleParamText:[Given]> expecting Given

******* / preambleParamText:[Upon]                                                                                :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting Upon

preambleParamText:[Upon]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=0:
preambleParamText:[Upon]> unexpected Every
preambleParamText:[Upon]> expecting Upon

******* / preambleBoolStructR [Unless]                                                                            :1_1:Every:
preambleBoolStructR [Unless]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleBoolStructR [Unless]> MATCH (EERR): <EMPTY>
preambleBoolStructR [Unless]> ERROR:
preambleBoolStructR [Unless]> offset=0:
preambleBoolStructR [Unless]> unexpected Every
preambleBoolStructR [Unless]> expecting Unless

******* / preambleBoolStructR [When,If]                                                                           :1_1:Every:
preambleBoolStructR [When,If]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleBoolStructR [When,If]> MATCH (EERR): <EMPTY>
preambleBoolStructR [When,If]> ERROR:
preambleBoolStructR [When,If]> offset=0:
preambleBoolStructR [When,If]> unexpected Every
preambleBoolStructR [When,If]> expecting If or When

******* / pDT                                                                                                     :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting May, Must, or Shant

pDT> IN: Every GoDeeper Other "person" UnDeeper W <…>
pDT> MATCH (EERR): <EMPTY>
pDT> ERROR:
pDT> offset=0:
pDT> unexpected Every
pDT> expecting May, Must, or Shant

******* / pActor [Every,Party,TokAll]                                                                             :1_1:Every:
******** / someIndentation                                                                                        :1_2:GoDeeper:
********* / myindented: consuming GoDeeper                                                                       :1_2:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "person" UnDeeper Who GoD <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

********* \ myindented: consuming GoDeeper has returned GoDeeper                                                  :1_2:Other "pers:
********* / manyIndentation/leaf?                                                                                 :1_2:Other "pers:
********** / pMultiTermAka                                                                                       :1_2:Other "pers:
*********** / pAKA                                                                                              :1_2:Other "pers:
************ / slAKA                                                                                           :1_2:Other "pers:
************* / $*|                                                                                           :1_2:Other "pers:
************** / slAKA base                                                                                  :1_2:Other "pers:
*************** / slMultiTerm                                                                               :1_2:Other "pers:
**************** / someSL                                                                                  :1_2:Other "pers:
someSL> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
someSL> MATCH (COK): Other "person"
someSL> VALUE: ((["person"],0),[])

**************** \ someSL has returned (["person"],0)                                                       :2_2:UnDeeper:
slMultiTerm> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
slMultiTerm> MATCH (COK): Other "person"
slMultiTerm> VALUE: ((["person"],0),[])

*************** \ slMultiTerm has returned (["person"],0)                                                    :2_2:UnDeeper:
slAKA base> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
slAKA base> MATCH (COK): Other "person"
slAKA base> VALUE: ((["person"],0),[])

************** \ slAKA base has returned (["person"],0)                                                       :2_2:UnDeeper:
$*|> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
$*|> MATCH (COK): Other "person"
$*|> VALUE: ((["person"],0),[])

************* \ $*| has returned (["person"],0)                                                                :2_2:UnDeeper:
************* / |>>/recurse                                                                                    :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************* / |>>/base                                                                                       :2_2:UnDeeper:
************** / slAKA optional akapart                                                                       :2_2:UnDeeper:
*************** / |?| optional something                                                                     :2_2:UnDeeper:
**************** / |>>/recurse                                                                              :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

**************** / |>>/base                                                                                 :2_2:UnDeeper:
***************** / PAKA/akapart                                                                           :2_2:UnDeeper:
****************** / $>|                                                                                  :2_2:UnDeeper:
******************* / Aka Token                                                                          :2_2:UnDeeper:
Aka Token> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
Aka Token> MATCH (EERR): <EMPTY>
Aka Token> ERROR:
Aka Token> offset=3:
Aka Token> unexpected UnDeeper
Aka Token> expecting Aka

$>|> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=3:
$>|> unexpected UnDeeper
$>|> expecting Aka

PAKA/akapart> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
PAKA/akapart> MATCH (EERR): <EMPTY>
PAKA/akapart> ERROR:
PAKA/akapart> offset=3:
PAKA/akapart> unexpected UnDeeper
PAKA/akapart> expecting Aka

|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=3:
|>>/base> unexpected UnDeeper
|>>/base> expecting Aka

|?| optional something> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

*************** \ |?| optional something has returned (Nothing,0)                                            :2_2:UnDeeper:
slAKA optional akapart> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
slAKA optional akapart> MATCH (EOK): <EMPTY>
slAKA optional akapart> VALUE: ((Nothing,0),[])

************** \ slAKA optional akapart has returned (Nothing,0)                                              :2_2:UnDeeper:
************** > |>>/base got Nothing                                                                         :2_2:UnDeeper:
|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************* \ |>>/base has returned (Nothing,0)                                                              :2_2:UnDeeper:
************* / |>>/recurse                                                                                    :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************* / |>>/base                                                                                       :2_2:UnDeeper:
************** / slAKA optional typically                                                                     :2_2:UnDeeper:
*************** / |?| optional something                                                                     :2_2:UnDeeper:
**************** / |>>/recurse                                                                              :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

**************** / |>>/base                                                                                 :2_2:UnDeeper:
***************** / typically                                                                              :2_2:UnDeeper:
****************** / $>|                                                                                  :2_2:UnDeeper:
$>|> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=3:
$>|> unexpected UnDeeper
$>|> expecting Typically

typically> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
typically> MATCH (EERR): <EMPTY>
typically> ERROR:
typically> offset=3:
typically> unexpected UnDeeper
typically> expecting Typically

|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=3:
|>>/base> unexpected UnDeeper
|>>/base> expecting Typically

|?| optional something> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

*************** \ |?| optional something has returned (Nothing,0)                                            :2_2:UnDeeper:
slAKA optional typically> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
slAKA optional typically> MATCH (EOK): <EMPTY>
slAKA optional typically> VALUE: ((Nothing,0),[])

************** \ slAKA optional typically has returned (Nothing,0)                                            :2_2:UnDeeper:
************** > |>>/base got Nothing                                                                         :2_2:UnDeeper:
|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************* \ |>>/base has returned (Nothing,0)                                                              :2_2:UnDeeper:
************* > slAKA: proceeding after base and entityalias are retrieved ...                                 :2_2:UnDeeper:
************* > pAKA: entityalias = Nothing                                                                    :2_2:UnDeeper:
slAKA> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
slAKA> MATCH (COK): Other "person"
slAKA> VALUE: ((["person"],0),[])

************ \ slAKA has returned (["person"],0)                                                                :2_2:UnDeeper:
************ / undeepers                                                                                        :2_2:UnDeeper:
************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers                         :2_2:UnDeeper:
************* > sameLine: success!                                                                             :2_2:UnDeeper:
undeepers> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

************ \ undeepers has returned ()                                                                        :2_2:UnDeeper:
pAKA> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
pAKA> MATCH (COK): Other "person"
pAKA> VALUE: (["person"],[])

*********** \ pAKA has returned ["person"]                                                                       :2_2:UnDeeper:
pMultiTermAka> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
pMultiTermAka> MATCH (COK): Other "person"
pMultiTermAka> VALUE: (["person"],[])

********** \ pMultiTermAka has returned ["person"]                                                                :2_2:UnDeeper:
manyIndentation/leaf?> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
manyIndentation/leaf?> MATCH (COK): Other "person"
manyIndentation/leaf?> VALUE: (["person"],[])

********* \ manyIndentation/leaf? has returned ["person"]                                                          :2_2:UnDeeper:
********* / myindented: consuming UnDeeper                                                                         :2_2:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

********* \ myindented: consuming UnDeeper has returned UnDeeper                                                :2_1:Who:
someIndentation> IN: GoDeeper Other "person" UnDeeper Who GoD <…>
someIndentation> MATCH (COK): GoDeeper Other "person" UnDeeper
someIndentation> VALUE: (["person"],[])

******** \ someIndentation has returned ["person"]                                                               :2_1:Who:
pActor [Every,Party,TokAll]> IN: Every GoDeeper Other "person" UnDeeper W <…>
pActor [Every,Party,TokAll]> MATCH (COK): Every GoDeeper Other "person" UnDeeper
pActor [Every,Party,TokAll]> VALUE: ((Every,Leaf (("person" :| [],Nothing) :| [])),[])

******* \ pActor [Every,Party,TokAll] has returned (Every,Leaf (("person" :| [],Nothing) :| []))                  :2_1:Who:
******* / manyIndentation/leaf?                                                                                   :2_1:Who:
******** / preambleBoolStructR [Who,Which,Whose]                                                                 :2_1:Who:
********* / pBSR                                                                                                 :2_2:GoDeeper:
********** / ppp inner                                                                                          :2_2:GoDeeper:
*********** / expression                                                                                       :2_2:GoDeeper:
************ / labelPrefix                                                                                    :2_2:GoDeeper:
labelPrefix> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=5:
labelPrefix> unexpected GoDeeper
labelPrefix> expecting Other text

************ / term p                                                                                         :2_2:GoDeeper:
************* / term p/1a:label directly above                                                               :2_2:GoDeeper:
************** / $*|                                                                                        :2_2:GoDeeper:
*************** / someSL                                                                                   :2_2:GoDeeper:
**************** / pNumAsText                                                                             :2_2:GoDeeper:
pNumAsText> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=5:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=5:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=5:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=5:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

************* / term p/b:label to the left of line below, with EOL                                           :2_2:GoDeeper:
************** / someSL                                                                                     :2_2:GoDeeper:
*************** / pNumAsText                                                                               :2_2:GoDeeper:
pNumAsText> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=5:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=5:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=5:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

************* / term p/notLabelTerm                                                                          :2_2:GoDeeper:
************** / term p/2:someIndentation expr p                                                            :2_2:GoDeeper:
*************** / someIndentation                                                                          :2_2:GoDeeper:
**************** / myindented: consuming GoDeeper                                                         :2_2:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

**************** \ myindented: consuming GoDeeper has returned GoDeeper                                     :2_3:GoDeeper:
**************** / manyIndentation/leaf?                                                                    :2_3:GoDeeper:
***************** / expression                                                                             :2_3:GoDeeper:
****************** / labelPrefix                                                                          :2_3:GoDeeper:
labelPrefix> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=6:
labelPrefix> unexpected GoDeeper
labelPrefix> expecting Other text

****************** / term p                                                                               :2_3:GoDeeper:
******************* / term p/1a:label directly above                                                     :2_3:GoDeeper:
******************** / $*|                                                                              :2_3:GoDeeper:
********************* / someSL                                                                         :2_3:GoDeeper:
********************** / pNumAsText                                                                   :2_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=6:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=6:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=6:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=6:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

******************* / term p/b:label to the left of line below, with EOL                                 :2_3:GoDeeper:
******************** / someSL                                                                           :2_3:GoDeeper:
********************* / pNumAsText                                                                     :2_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=6:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=6:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=6:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

******************* / term p/notLabelTerm                                                                :2_3:GoDeeper:
******************** / term p/2:someIndentation expr p                                                  :2_3:GoDeeper:
********************* / someIndentation                                                                :2_3:GoDeeper:
********************** / myindented: consuming GoDeeper                                               :2_3:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

********************** \ myindented: consuming GoDeeper has returned GoDeeper                          :2_3:Other "is":
********************** / manyIndentation/leaf?                                                         :2_3:Other "is":
*********************** / expression                                                                  :2_3:Other "is":
************************ / labelPrefix                                                               :2_3:Other "is":
labelPrefix> IN: Other "is" GoDeeper Other "immortal" GoD <…>
labelPrefix> MATCH (COK): Other "is"
labelPrefix> VALUE: ("is",[])

************************ \ labelPrefix has returned "is"                                              :2_4:GoDeeper:
************************ / term p                                                                     :2_4:GoDeeper:
************************* / term p/1a:label directly above                                           :2_4:GoDeeper:
************************** / $*|                                                                    :2_4:GoDeeper:
*************************** / someSL                                                               :2_4:GoDeeper:
**************************** / pNumAsText                                                         :2_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=8:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=8:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=8:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=8:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

************************* / term p/b:label to the left of line below, with EOL                       :2_4:GoDeeper:
************************** / someSL                                                                 :2_4:GoDeeper:
*************************** / pNumAsText                                                           :2_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=8:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=8:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=8:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

************************* / term p/notLabelTerm                                                      :2_4:GoDeeper:
************************** / term p/2:someIndentation expr p                                        :2_4:GoDeeper:
*************************** / someIndentation                                                      :2_4:GoDeeper:
**************************** / myindented: consuming GoDeeper                                     :2_4:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

**************************** \ myindented: consuming GoDeeper has returned GoDeeper                :2_4:Other "immo:
**************************** / manyIndentation/leaf?                                               :2_4:Other "immo:
***************************** / expression                                                        :2_4:Other "immo:
****************************** / labelPrefix                                                     :2_4:Other "immo:
labelPrefix> IN: Other "immortal" GoDeeper Typically GoDe <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=10:
labelPrefix> unexpected GoDeeper

****************************** / term p                                                          :2_4:Other "immo:
******************************* / term p/1a:label directly above                                :2_4:Other "immo:
******************************** / $*|                                                         :2_4:Other "immo:
********************************* / someSL                                                    :2_4:Other "immo:
********************************** / pNumAsText                                                :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

********************************* \ someSL has returned (["immortal"],0)                       :2_5:GoDeeper:
********************************* / pNumAsText                                                 :2_5:GoDeeper:
pNumAsText> IN: GoDeeper Typically GoDeeper Other "false <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (CERR): Other "immortal"
$*|> ERROR:
$*|> offset=10:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/1a:label directly above> MATCH (CERR): Other "immortal"
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=10:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

******************************* / term p/b:label to the left of line below, with EOL            :2_4:Other "immo:
******************************** / someSL                                                      :2_4:Other "immo:
********************************* / pNumAsText                                                  :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

******************************** \ someSL has returned (["immortal"],0)                         :2_5:GoDeeper:
******************************** / undeepers                                                    :2_5:GoDeeper:
********************************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers :2_5:GoDeeper:
********************************* > sameLine: success!                                         :2_5:GoDeeper:
undeepers> IN: GoDeeper Typically GoDeeper Other "false <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

******************************** \ undeepers has returned ()                                    :2_5:GoDeeper:
******************************** / matching EOL                                                 :2_5:GoDeeper:
matching EOL> IN: GoDeeper Typically GoDeeper Other "false <…>
matching EOL> MATCH (EERR): <EMPTY>
matching EOL> ERROR:
matching EOL> offset=10:
matching EOL> unexpected GoDeeper
matching EOL> expecting EOL

term p/b:label to the left of line below, with EOL> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/b:label to the left of line below, with EOL> MATCH (CERR): Other "immortal"
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=10:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting EOL

******************************* / term p/notLabelTerm                                           :2_4:Other "immo:
******************************** / term p/2:someIndentation expr p                             :2_4:Other "immo:
********************************* / someIndentation                                           :2_4:Other "immo:
********************************** / myindented: consuming GoDeeper                          :2_4:Other "immo:
myindented: consuming GoDeeper> IN: Other "immortal" GoDeeper Typically GoDe <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=9:
myindented: consuming GoDeeper> unexpected Other "immortal"
myindented: consuming GoDeeper> expecting GoDeeper

someIndentation> IN: Other "immortal" GoDeeper Typically GoDe <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=9:
someIndentation> unexpected Other "immortal"
someIndentation> expecting GoDeeper

term p/2:someIndentation expr p> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/2:someIndentation expr p> MATCH (EERR): <EMPTY>
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=9:
term p/2:someIndentation expr p> unexpected Other "immortal"
term p/2:someIndentation expr p> expecting GoDeeper

******************************** / term p/3:plain p                                            :2_4:Other "immo:
********************************* / pRelPred                                                  :2_4:Other "immo:
********************************** / slRelPred                                               :2_4:Other "immo:
*********************************** / nested simpleHorn                                     :2_4:Other "immo:
************************************ > |^|                                                 :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slMultiTerm                                       :2_4:Other "immo:
************************************** / someSL                                          :2_4:Other "immo:
*************************************** / pNumAsText                                      :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

************************************** \ someSL has returned (["immortal"],0)             :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

************************************* \ slMultiTerm has returned (["immortal"],0)          :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************ \ $*| has returned (["immortal"],0)                    :2_5:GoDeeper:
************************************ / |^| deeps                                            :2_5:GoDeeper:
|^| deeps> IN: GoDeeper Typically GoDeeper Other "false <…>
|^| deeps> MATCH (COK): GoDeeper
|^| deeps> VALUE: (([()],1),[])

************************************ \ |^| deeps has returned ([()],1)                       :2_5:Typically:
nested simpleHorn> IN: Other "immortal" GoDeeper Typically GoDe <…>
nested simpleHorn> MATCH (CERR): Other "immortal" GoDeeper
nested simpleHorn> ERROR:
nested simpleHorn> offset=11:
nested simpleHorn> unexpected Typically
nested simpleHorn> expecting GoDeeper or Means

*********************************** / RPConstraint                                          :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slMultiTerm                                       :2_4:Other "immo:
************************************** / someSL                                          :2_4:Other "immo:
*************************************** / pNumAsText                                      :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

************************************** \ someSL has returned (["immortal"],0)             :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

************************************* \ slMultiTerm has returned (["immortal"],0)          :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************ \ $*| has returned (["immortal"],0)                    :2_5:GoDeeper:
************************************ / |>| calling $>>                                      :2_5:GoDeeper:
************************************* / |>>/recurse                                        :2_5:GoDeeper:
************************************** / |>>/recurse                                       :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                          :2_5:Typically:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=11:
|>>/base> unexpected Typically
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>>/recurse> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/recurse> MATCH (CERR): GoDeeper
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

************************************* / |>>/base                                           :2_5:GoDeeper:
|>>/base> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=10:
|>>/base> unexpected GoDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: GoDeeper Typically GoDeeper Other "false <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=11:
|>| calling $>>> unexpected Typically
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPConstraint> IN: Other "immortal" GoDeeper Typically GoDe <…>
RPConstraint> MATCH (CERR): Other "immortal"
RPConstraint> ERROR:
RPConstraint> offset=11:
RPConstraint> unexpected Typically
RPConstraint> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPBoolStructR                                         :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slMultiTerm                                       :2_4:Other "immo:
************************************** / someSL                                          :2_4:Other "immo:
*************************************** / pNumAsText                                      :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

************************************** \ someSL has returned (["immortal"],0)             :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

************************************* \ slMultiTerm has returned (["immortal"],0)          :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************ \ $*| has returned (["immortal"],0)                    :2_5:GoDeeper:
************************************ / |>| calling $>>                                      :2_5:GoDeeper:
************************************* / |>>/recurse                                        :2_5:GoDeeper:
************************************** / |>>/recurse                                       :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                          :2_5:Typically:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=11:
|>>/base> unexpected Typically
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>>/recurse> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/recurse> MATCH (CERR): GoDeeper
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

************************************* / |>>/base                                           :2_5:GoDeeper:
|>>/base> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=10:
|>>/base> unexpected GoDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: GoDeeper Typically GoDeeper Other "false <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=11:
|>| calling $>>> unexpected Typically
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPBoolStructR> IN: Other "immortal" GoDeeper Typically GoDe <…>
RPBoolStructR> MATCH (CERR): Other "immortal"
RPBoolStructR> ERROR:
RPBoolStructR> offset=11:
RPBoolStructR> unexpected Typically
RPBoolStructR> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPMT                                                  :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slAKA                                             :2_4:Other "immo:
************************************** / $*|                                             :2_4:Other "immo:
*************************************** / slAKA base                                    :2_4:Other "immo:
**************************************** / slMultiTerm                                 :2_4:Other "immo:
***************************************** / someSL                                    :2_4:Other "immo:
****************************************** / pNumAsText                                :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

***************************************** \ someSL has returned (["immortal"],0)       :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

**************************************** \ slMultiTerm has returned (["immortal"],0)    :2_5:GoDeeper:
slAKA base> IN: Other "immortal" GoDeeper Typically GoDe <…>
slAKA base> MATCH (COK): Other "immortal"
slAKA base> VALUE: ((["immortal"],0),[])

*************************************** \ slAKA base has returned (["immortal"],0)       :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************** \ $*| has returned (["immortal"],0)                :2_5:GoDeeper:
************************************** / |>>/recurse                                      :2_5:GoDeeper:
*************************************** / |>>/recurse                                     :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

*************************************** / |>>/base                                        :2_5:Typically:
**************************************** / slAKA optional akapart                        :2_5:Typically:
***************************************** / |?| optional something                      :2_5:Typically:
****************************************** / |>>/recurse                               :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

****************************************** / |>>/base                                  :2_5:Typically:
******************************************* / PAKA/akapart                            :2_5:Typically:
******************************************** / $>|                                   :2_5:Typically:
********************************************* / Aka Token                           :2_5:Typically:
Aka Token> IN: Typically GoDeeper Other "false" UnDeepe <…>
Aka Token> MATCH (EERR): <EMPTY>
Aka Token> ERROR:
Aka Token> offset=11:
Aka Token> unexpected Typically
Aka Token> expecting Aka

$>|> IN: Typically GoDeeper Other "false" UnDeepe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=11:
$>|> unexpected Typically
$>|> expecting Aka

PAKA/akapart> IN: Typically GoDeeper Other "false" UnDeepe <…>
PAKA/akapart> MATCH (EERR): <EMPTY>
PAKA/akapart> ERROR:
PAKA/akapart> offset=11:
PAKA/akapart> unexpected Typically
PAKA/akapart> expecting Aka

|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=11:
|>>/base> unexpected Typically
|>>/base> expecting Aka

|?| optional something> IN: Typically GoDeeper Other "false" UnDeepe <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

***************************************** \ |?| optional something has returned (Nothing,0) :2_5:Typically:
slAKA optional akapart> IN: Typically GoDeeper Other "false" UnDeepe <…>
slAKA optional akapart> MATCH (EOK): <EMPTY>
slAKA optional akapart> VALUE: ((Nothing,0),[])

**************************************** \ slAKA optional akapart has returned (Nothing,0) :2_5:Typically:
**************************************** > |>>/base got Nothing                          :2_5:Typically:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

*************************************** \ |>>/base has returned (Nothing,0)               :2_5:Typically:
|>>/recurse> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/recurse> MATCH (COK): GoDeeper
|>>/recurse> VALUE: ((Nothing,1),[])

************************************** \ |>>/recurse has returned (Nothing,1)              :2_5:Typically:
************************************** / |>>/recurse                                       :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                          :2_5:Typically:
*************************************** / slAKA optional typically                        :2_5:Typically:
**************************************** / |?| optional something                        :2_5:Typically:
***************************************** / |>>/recurse                                 :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

***************************************** / |>>/base                                    :2_5:Typically:
****************************************** / typically                                 :2_5:Typically:
******************************************* / $>|                                     :2_5:Typically:
$>|> IN: Typically GoDeeper Other "false" UnDeepe <…>
$>|> MATCH (COK): Typically
$>|> VALUE: (Typically,[])

******************************************* \ $>| has returned Typically               :2_6:GoDeeper:
******************************************* / |>>/recurse                              :2_6:GoDeeper:
******************************************** / |>>/recurse                             :2_6:Other "fals:
|>>/recurse> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=13:
|>>/recurse> unexpected Other "false"
|>>/recurse> expecting GoDeeper

******************************************** / |>>/base                                :2_6:Other "fals:
********************************************* / slMultiTerm                           :2_6:Other "fals:
********************************************** / someSL                              :2_6:Other "fals:
someSL> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
someSL> MATCH (COK): Other "false"
someSL> VALUE: ((["false"],0),[])

********************************************** \ someSL has returned (["false"],0) :3_3:UnDeeper:
slMultiTerm> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
slMultiTerm> MATCH (COK): Other "false"
slMultiTerm> VALUE: ((["false"],0),[])

********************************************* \ slMultiTerm has returned (["false"],0) :3_3:UnDeeper:
********************************************* > |>>/base got ["false"]           :3_3:UnDeeper:
|>>/base> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
|>>/base> MATCH (COK): Other "false"
|>>/base> VALUE: ((["false"],0),[])

******************************************** \ |>>/base has returned (["false"],0) :3_3:UnDeeper:
|>>/recurse> IN: GoDeeper Other "false" UnDeeper UnDeeper <…>
|>>/recurse> MATCH (COK): GoDeeper Other "false"
|>>/recurse> VALUE: ((["false"],1),[])

******************************************* \ |>>/recurse has returned (["false"],1) :3_3:UnDeeper:
typically> IN: Typically GoDeeper Other "false" UnDeepe <…>
typically> MATCH (COK): Typically GoDeeper Other "false"
typically> VALUE: ((["false"],1),[])

****************************************** \ typically has returned (["false"],1)   :3_3:UnDeeper:
****************************************** > |>>/base got ["false"]                 :3_3:UnDeeper:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (COK): Typically GoDeeper Other "false"
|>>/base> VALUE: ((["false"],1),[])

***************************************** \ |>>/base has returned (["false"],1)      :3_3:UnDeeper:
|?| optional something> IN: Typically GoDeeper Other "false" UnDeepe <…>
|?| optional something> MATCH (COK): Typically GoDeeper Other "false"
|?| optional something> VALUE: ((Just ["false"],1),[])

**************************************** \ |?| optional something has returned (Just ["false"],1) :3_3:UnDeeper:
slAKA optional typically> IN: Typically GoDeeper Other "false" UnDeepe <…>
slAKA optional typically> MATCH (COK): Typically GoDeeper Other "false"
slAKA optional typically> VALUE: ((Just ["false"],1),[])

*************************************** \ slAKA optional typically has returned (Just ["false"],1) :3_3:UnDeeper:
*************************************** > |>>/base got Just ["false"]                  :3_3:UnDeeper:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (COK): Typically GoDeeper Other "false"
|>>/base> VALUE: ((Just ["false"],1),[])

************************************** \ |>>/base has returned (Just ["false"],1)       :3_3:UnDeeper:
************************************** > slAKA: proceeding after base and entityalias are retrieved ... :3_3:UnDeeper:
************************************** > pAKA: entityalias = Nothing                    :3_3:UnDeeper:
slAKA> IN: Other "immortal" GoDeeper Typically GoDe <…>
slAKA> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
slAKA> VALUE: ((["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************************* \ slAKA has returned (["immortal"],2)              :3_3:UnDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
$*|> VALUE: ((["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************************ \ $*| has returned (["immortal"],2)                  :3_3:UnDeeper:
RPMT> IN: Other "immortal" GoDeeper Typically GoDe <…>
RPMT> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
RPMT> VALUE: ((RPMT ["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*********************************** \ RPMT has returned (RPMT ["immortal"],2)              :3_3:UnDeeper:
slRelPred> IN: Other "immortal" GoDeeper Typically GoDe <…>
slRelPred> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
slRelPred> VALUE: ((RPMT ["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************************** \ slRelPred has returned (RPMT ["immortal"],2)           :3_3:UnDeeper:
********************************** / undeepers                                              :3_3:UnDeeper:
*********************************** > sameLine/undeepers: reached end of line; now need to clear 2 UnDeepers :3_3:UnDeeper:
*********************************** > sameLine: success!                                       :3_5:UnDeeper:
undeepers> IN: UnDeeper UnDeeper UnDeeper UnDeeper Or G <…>
undeepers> MATCH (COK): UnDeeper UnDeeper
undeepers> VALUE: ((),[])

********************************** \ undeepers has returned ()                                  :3_5:UnDeeper:
pRelPred> IN: Other "immortal" GoDeeper Typically GoDe <…>
pRelPred> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
pRelPred> VALUE: (RPMT ["immortal"],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************************* \ pRelPred has returned RPMT ["immortal"]                      :3_5:UnDeeper:
term p/3:plain p> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/3:plain p> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
term p/3:plain p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************************** \ term p/3:plain p has returned MyLeaf (RPMT ["immortal"])       :3_5:UnDeeper:
term p/notLabelTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/notLabelTerm> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["immortal"])      :3_5:UnDeeper:
term p> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
term p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

****************************** \ term p has returned MyLeaf (RPMT ["immortal"])                     :3_5:UnDeeper:
****************************** / binary(Or)                                                         :3_5:UnDeeper:
binary(Or)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=16:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

****************************** / binary(And)                                                        :3_5:UnDeeper:
binary(And)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=16:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

****************************** / binary(SetLess)                                                    :3_5:UnDeeper:
binary(SetLess)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=16:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

****************************** / binary(SetPlus)                                                    :3_5:UnDeeper:
binary(SetPlus)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=16:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "immortal" GoDeeper Typically GoDe <…>
expression> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
expression> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

***************************** \ expression has returned MyLeaf (RPMT ["immortal"])                   :3_5:UnDeeper:
manyIndentation/leaf?> IN: Other "immortal" GoDeeper Typically GoDe <…>
manyIndentation/leaf?> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
manyIndentation/leaf?> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

**************************** \ manyIndentation/leaf? has returned MyLeaf (RPMT ["immortal"])          :3_5:UnDeeper:
**************************** / myindented: consuming UnDeeper                                         :3_5:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

**************************** \ myindented: consuming UnDeeper has returned UnDeeper                     :3_6:UnDeeper:
someIndentation> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
someIndentation> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
someIndentation> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*************************** \ someIndentation has returned MyLeaf (RPMT ["immortal"])                    :3_6:UnDeeper:
term p/2:someIndentation expr p> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
term p/2:someIndentation expr p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************** \ term p/2:someIndentation expr p has returned MyLeaf (RPMT ["immortal"])      :3_6:UnDeeper:
term p/notLabelTerm> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["immortal"])                    :3_6:UnDeeper:
term p> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
term p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************ \ term p has returned MyLeaf (RPMT ["immortal"])                                   :3_6:UnDeeper:
************************ / binary(Or)                                                                       :3_6:UnDeeper:
binary(Or)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=17:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

************************ / binary(And)                                                                      :3_6:UnDeeper:
binary(And)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=17:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

************************ / binary(SetLess)                                                                  :3_6:UnDeeper:
binary(SetLess)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=17:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

************************ / binary(SetPlus)                                                                  :3_6:UnDeeper:
binary(SetPlus)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=17:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "is" GoDeeper Other "immortal" GoD <…>
expression> MATCH (COK): Other "is" GoDeeper Other "immortal" GoD <…>
expression> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*********************** \ expression has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))                :3_6:UnDeeper:
manyIndentation/leaf?> IN: Other "is" GoDeeper Other "immortal" GoD <…>
manyIndentation/leaf?> MATCH (COK): Other "is" GoDeeper Other "immortal" GoD <…>
manyIndentation/leaf?> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************** \ manyIndentation/leaf? has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))       :3_6:UnDeeper:
********************** / myindented: consuming UnDeeper                                                       :3_6:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

********************** \ myindented: consuming UnDeeper has returned UnDeeper                        :3_2:Or:
someIndentation> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
someIndentation> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
someIndentation> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************* \ someIndentation has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))      :3_2:Or:
term p/2:someIndentation expr p> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
term p/2:someIndentation expr p> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************** \ term p/2:someIndentation expr p has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"])) :3_2:Or:
term p/notLabelTerm> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
term p/notLabelTerm> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************* \ term p/notLabelTerm has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))      :3_2:Or:
term p> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
term p> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

****************** \ term p has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))                     :3_2:Or:
****************** / binary(Or)                                                                          :3_2:Or:
binary(Or)> IN: Or GoDeeper Other "has" GoDeeper Other " <…>
binary(Or)> MATCH (COK): Or
binary(Or)> VALUE: (Or,[])

****************** \ binary(Or) has returned Or                                                           :3_3:GoDeeper:
****************** / term p                                                                               :3_3:GoDeeper:
******************* / term p/1a:label directly above                                                     :3_3:GoDeeper:
******************** / $*|                                                                              :3_3:GoDeeper:
********************* / someSL                                                                         :3_3:GoDeeper:
********************** / pNumAsText                                                                   :3_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=19:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=19:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=19:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=19:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

******************* / term p/b:label to the left of line below, with EOL                                 :3_3:GoDeeper:
******************** / someSL                                                                           :3_3:GoDeeper:
********************* / pNumAsText                                                                     :3_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=19:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=19:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=19:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

******************* / term p/notLabelTerm                                                                :3_3:GoDeeper:
******************** / term p/2:someIndentation expr p                                                  :3_3:GoDeeper:
********************* / someIndentation                                                                :3_3:GoDeeper:
********************** / myindented: consuming GoDeeper                                               :3_3:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

********************** \ myindented: consuming GoDeeper has returned GoDeeper                          :3_3:Other "has":
********************** / manyIndentation/leaf?                                                         :3_3:Other "has":
*********************** / expression                                                                  :3_3:Other "has":
************************ / labelPrefix                                                               :3_3:Other "has":
labelPrefix> IN: Other "has" GoDeeper Other "health insur <…>
labelPrefix> MATCH (COK): Other "has"
labelPrefix> VALUE: ("has",[])

************************ \ labelPrefix has returned "has"                                             :3_4:GoDeeper:
************************ / term p                                                                     :3_4:GoDeeper:
************************* / term p/1a:label directly above                                           :3_4:GoDeeper:
************************** / $*|                                                                    :3_4:GoDeeper:
*************************** / someSL                                                               :3_4:GoDeeper:
**************************** / pNumAsText                                                         :3_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "health insurance" UnDeep <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=21:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "health insurance" UnDeep <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=21:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "health insurance" UnDeep <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=21:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=21:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

************************* / term p/b:label to the left of line below, with EOL                       :3_4:GoDeeper:
************************** / someSL                                                                 :3_4:GoDeeper:
*************************** / pNumAsText                                                           :3_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "health insurance" UnDeep <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=21:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "health insurance" UnDeep <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=21:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=21:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

************************* / term p/notLabelTerm                                                      :3_4:GoDeeper:
************************** / term p/2:someIndentation expr p                                        :3_4:GoDeeper:
*************************** / someIndentation                                                      :3_4:GoDeeper:
**************************** / myindented: consuming GoDeeper                                     :3_4:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "health insurance" UnDeep <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

**************************** \ myindented: consuming GoDeeper has returned GoDeeper                :3_4:Other "heal:
**************************** / manyIndentation/leaf?                                               :3_4:Other "heal:
***************************** / expression                                                        :3_4:Other "heal:
****************************** / labelPrefix                                                     :3_4:Other "heal:
labelPrefix> IN: Other "health insurance" UnDeeper UnDeep <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=23:
labelPrefix> unexpected UnDeeper

****************************** / term p                                                          :3_4:Other "heal:
******************************* / term p/1a:label directly above                                :3_4:Other "heal:
******************************** / $*|                                                         :3_4:Other "heal:
********************************* / someSL                                                    :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

********************************* \ someSL has returned (["health insurance"],0)           :4_2:UnDeeper:
********************************* / pNumAsText                                             :4_2:UnDeeper:
pNumAsText> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=23:
pNumAsText> unexpected UnDeeper
pNumAsText> expecting number

$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (CERR): Other "health insurance"
$*|> ERROR:
$*|> offset=23:
$*|> unexpected UnDeeper
$*|> expecting GoDeeper or other text or number

term p/1a:label directly above> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/1a:label directly above> MATCH (CERR): Other "health insurance"
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=23:
term p/1a:label directly above> unexpected UnDeeper
term p/1a:label directly above> expecting GoDeeper or other text or number

******************************* / term p/b:label to the left of line below, with EOL            :3_4:Other "heal:
******************************** / someSL                                                      :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

******************************** \ someSL has returned (["health insurance"],0)             :4_2:UnDeeper:
******************************** / undeepers                                                :4_2:UnDeeper:
********************************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers :4_2:UnDeeper:
********************************* > sameLine: success!                                     :4_2:UnDeeper:
undeepers> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

******************************** \ undeepers has returned ()                                :4_2:UnDeeper:
******************************** / matching EOL                                             :4_2:UnDeeper:
matching EOL> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
matching EOL> MATCH (EERR): <EMPTY>
matching EOL> ERROR:
matching EOL> offset=23:
matching EOL> unexpected UnDeeper
matching EOL> expecting EOL

term p/b:label to the left of line below, with EOL> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/b:label to the left of line below, with EOL> MATCH (CERR): Other "health insurance"
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=23:
term p/b:label to the left of line below, with EOL> unexpected UnDeeper
term p/b:label to the left of line below, with EOL> expecting EOL or GoDeeper

******************************* / term p/notLabelTerm                                           :3_4:Other "heal:
******************************** / term p/2:someIndentation expr p                             :3_4:Other "heal:
********************************* / someIndentation                                           :3_4:Other "heal:
********************************** / myindented: consuming GoDeeper                          :3_4:Other "heal:
myindented: consuming GoDeeper> IN: Other "health insurance" UnDeeper UnDeep <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=22:
myindented: consuming GoDeeper> unexpected Other "health insurance"
myindented: consuming GoDeeper> expecting GoDeeper

someIndentation> IN: Other "health insurance" UnDeeper UnDeep <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=22:
someIndentation> unexpected Other "health insurance"
someIndentation> expecting GoDeeper

term p/2:someIndentation expr p> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/2:someIndentation expr p> MATCH (EERR): <EMPTY>
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=22:
term p/2:someIndentation expr p> unexpected Other "health insurance"
term p/2:someIndentation expr p> expecting GoDeeper

******************************** / term p/3:plain p                                            :3_4:Other "heal:
********************************* / pRelPred                                                  :3_4:Other "heal:
********************************** / slRelPred                                               :3_4:Other "heal:
*********************************** / nested simpleHorn                                     :3_4:Other "heal:
************************************ > |^|                                                 :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slMultiTerm                                       :3_4:Other "heal:
************************************** / someSL                                          :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

************************************* \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
************************************ / |^| deeps                                        :4_2:UnDeeper:
|^| deeps> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|^| deeps> MATCH (COK): UnDeeper UnDeeper UnDeeper
|^| deeps> VALUE: (([(),(),()],-3),[])

************************************ \ |^| deeps has returned ([(),(),()],-3)        :4_1:May:
nested simpleHorn> IN: Other "health insurance" UnDeeper UnDeep <…>
nested simpleHorn> MATCH (CERR): Other "health insurance" UnDeeper UnDeep <…>
nested simpleHorn> ERROR:
nested simpleHorn> offset=26:
nested simpleHorn> unexpected May
nested simpleHorn> expecting Means or UnDeeper

*********************************** / RPConstraint                                          :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slMultiTerm                                       :3_4:Other "heal:
************************************** / someSL                                          :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

************************************* \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
************************************ / |>| calling $>>                                  :4_2:UnDeeper:
************************************* / |>>/recurse                                    :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************* / |>>/base                                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=23:
|>| calling $>>> unexpected UnDeeper
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPConstraint> IN: Other "health insurance" UnDeeper UnDeep <…>
RPConstraint> MATCH (CERR): Other "health insurance"
RPConstraint> ERROR:
RPConstraint> offset=23:
RPConstraint> unexpected UnDeeper
RPConstraint> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPBoolStructR                                         :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slMultiTerm                                       :3_4:Other "heal:
************************************** / someSL                                          :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

************************************* \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
************************************ / |>| calling $>>                                  :4_2:UnDeeper:
************************************* / |>>/recurse                                    :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************* / |>>/base                                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=23:
|>| calling $>>> unexpected UnDeeper
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPBoolStructR> IN: Other "health insurance" UnDeeper UnDeep <…>
RPBoolStructR> MATCH (CERR): Other "health insurance"
RPBoolStructR> ERROR:
RPBoolStructR> offset=23:
RPBoolStructR> unexpected UnDeeper
RPBoolStructR> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPMT                                                  :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slAKA                                             :3_4:Other "heal:
************************************** / $*|                                             :3_4:Other "heal:
*************************************** / slAKA base                                    :3_4:Other "heal:
**************************************** / slMultiTerm                                 :3_4:Other "heal:
***************************************** / someSL                                    :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

***************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

**************************************** \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
slAKA base> IN: Other "health insurance" UnDeeper UnDeep <…>
slAKA base> MATCH (COK): Other "health insurance"
slAKA base> VALUE: ((["health insurance"],0),[])

*************************************** \ slAKA base has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************** \ $*| has returned (["health insurance"],0)    :4_2:UnDeeper:
************************************** / |>>/recurse                                  :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                     :4_2:UnDeeper:
*************************************** / slAKA optional akapart                     :4_2:UnDeeper:
**************************************** / |?| optional something                   :4_2:UnDeeper:
***************************************** / |>>/recurse                            :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

***************************************** / |>>/base                               :4_2:UnDeeper:
****************************************** / PAKA/akapart                         :4_2:UnDeeper:
******************************************* / $>|                                :4_2:UnDeeper:
******************************************** / Aka Token                        :4_2:UnDeeper:
Aka Token> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
Aka Token> MATCH (EERR): <EMPTY>
Aka Token> ERROR:
Aka Token> offset=23:
Aka Token> unexpected UnDeeper
Aka Token> expecting Aka

$>|> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=23:
$>|> unexpected UnDeeper
$>|> expecting Aka

PAKA/akapart> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
PAKA/akapart> MATCH (EERR): <EMPTY>
PAKA/akapart> ERROR:
PAKA/akapart> offset=23:
PAKA/akapart> unexpected UnDeeper
PAKA/akapart> expecting Aka

|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Aka

|?| optional something> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

**************************************** \ |?| optional something has returned (Nothing,0) :4_2:UnDeeper:
slAKA optional akapart> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
slAKA optional akapart> MATCH (EOK): <EMPTY>
slAKA optional akapart> VALUE: ((Nothing,0),[])

*************************************** \ slAKA optional akapart has returned (Nothing,0) :4_2:UnDeeper:
*************************************** > |>>/base got Nothing                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************************************** \ |>>/base has returned (Nothing,0)            :4_2:UnDeeper:
************************************** / |>>/recurse                                  :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                     :4_2:UnDeeper:
*************************************** / slAKA optional typically                   :4_2:UnDeeper:
**************************************** / |?| optional something                   :4_2:UnDeeper:
***************************************** / |>>/recurse                            :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

***************************************** / |>>/base                               :4_2:UnDeeper:
****************************************** / typically                            :4_2:UnDeeper:
******************************************* / $>|                                :4_2:UnDeeper:
$>|> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=23:
$>|> unexpected UnDeeper
$>|> expecting Typically

typically> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
typically> MATCH (EERR): <EMPTY>
typically> ERROR:
typically> offset=23:
typically> unexpected UnDeeper
typically> expecting Typically

|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Typically

|?| optional something> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

**************************************** \ |?| optional something has returned (Nothing,0) :4_2:UnDeeper:
slAKA optional typically> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
slAKA optional typically> MATCH (EOK): <EMPTY>
slAKA optional typically> VALUE: ((Nothing,0),[])

*************************************** \ slAKA optional typically has returned (Nothing,0) :4_2:UnDeeper:
*************************************** > |>>/base got Nothing                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************************************** \ |>>/base has returned (Nothing,0)            :4_2:UnDeeper:
************************************** > slAKA: proceeding after base and entityalias are retrieved ... :4_2:UnDeeper:
************************************** > pAKA: entityalias = Nothing                  :4_2:UnDeeper:
slAKA> IN: Other "health insurance" UnDeeper UnDeep <…>
slAKA> MATCH (COK): Other "health insurance"
slAKA> VALUE: ((["health insurance"],0),[])

************************************* \ slAKA has returned (["health insurance"],0)    :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
RPMT> IN: Other "health insurance" UnDeeper UnDeep <…>
RPMT> MATCH (COK): Other "health insurance"
RPMT> VALUE: ((RPMT ["health insurance"],0),[])

*********************************** \ RPMT has returned (RPMT ["health insurance"],0)    :4_2:UnDeeper:
slRelPred> IN: Other "health insurance" UnDeeper UnDeep <…>
slRelPred> MATCH (COK): Other "health insurance"
slRelPred> VALUE: ((RPMT ["health insurance"],0),[])

********************************** \ slRelPred has returned (RPMT ["health insurance"],0) :4_2:UnDeeper:
********************************** / undeepers                                            :4_2:UnDeeper:
*********************************** > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers :4_2:UnDeeper:
*********************************** > sameLine: success!                                 :4_2:UnDeeper:
undeepers> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

********************************** \ undeepers has returned ()                            :4_2:UnDeeper:
pRelPred> IN: Other "health insurance" UnDeeper UnDeep <…>
pRelPred> MATCH (COK): Other "health insurance"
pRelPred> VALUE: (RPMT ["health insurance"],[])

********************************* \ pRelPred has returned RPMT ["health insurance"]        :4_2:UnDeeper:
term p/3:plain p> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/3:plain p> MATCH (COK): Other "health insurance"
term p/3:plain p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

******************************** \ term p/3:plain p has returned MyLeaf (RPMT ["health insurance"]) :4_2:UnDeeper:
term p/notLabelTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/notLabelTerm> MATCH (COK): Other "health insurance"
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

******************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["health insurance"]) :4_2:UnDeeper:
term p> IN: Other "health insurance" UnDeeper UnDeep <…>
term p> MATCH (COK): Other "health insurance"
term p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

****************************** \ term p has returned MyLeaf (RPMT ["health insurance"])       :4_2:UnDeeper:
****************************** / binary(Or)                                                   :4_2:UnDeeper:
binary(Or)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=23:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

****************************** / binary(And)                                                  :4_2:UnDeeper:
binary(And)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=23:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

****************************** / binary(SetLess)                                              :4_2:UnDeeper:
binary(SetLess)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=23:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

****************************** / binary(SetPlus)                                              :4_2:UnDeeper:
binary(SetPlus)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=23:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "health insurance" UnDeeper UnDeep <…>
expression> MATCH (COK): Other "health insurance"
expression> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

***************************** \ expression has returned MyLeaf (RPMT ["health insurance"])     :4_2:UnDeeper:
manyIndentation/leaf?> IN: Other "health insurance" UnDeeper UnDeep <…>
manyIndentation/leaf?> MATCH (COK): Other "health insurance"
manyIndentation/leaf?> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

**************************** \ manyIndentation/leaf? has returned MyLeaf (RPMT ["health insurance"]) :4_2:UnDeeper:
**************************** / myindented: consuming UnDeeper                                   :4_2:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

**************************** \ myindented: consuming UnDeeper has returned UnDeeper               :4_3:UnDeeper:
someIndentation> IN: GoDeeper Other "health insurance" UnDeep <…>
someIndentation> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
someIndentation> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

*************************** \ someIndentation has returned MyLeaf (RPMT ["health insurance"])      :4_3:UnDeeper:
term p/2:someIndentation expr p> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
term p/2:someIndentation expr p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

************************** \ term p/2:someIndentation expr p has returned MyLeaf (RPMT ["health insurance"]) :4_3:UnDeeper:
term p/notLabelTerm> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["health insurance"])      :4_3:UnDeeper:
term p> IN: GoDeeper Other "health insurance" UnDeep <…>
term p> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
term p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

************************ \ term p has returned MyLeaf (RPMT ["health insurance"])                     :4_3:UnDeeper:
************************ / binary(Or)                                                                 :4_3:UnDeeper:
binary(Or)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=24:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

************************ / binary(And)                                                                :4_3:UnDeeper:
binary(And)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=24:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

************************ / binary(SetLess)                                                            :4_3:UnDeeper:
binary(SetLess)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=24:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

************************ / binary(SetPlus)                                                            :4_3:UnDeeper:
binary(SetPlus)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=24:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "has" GoDeeper Other "health insur <…>
expression> MATCH (COK): Other "has" GoDeeper Other "health insur <…>
expression> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

*********************** \ expression has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])) :4_3:UnDeeper:
manyIndentation/leaf?> IN: Other "has" GoDeeper Other "health insur <…>
manyIndentation/leaf?> MATCH (COK): Other "has" GoDeeper Other "health insur <…>
manyIndentation/leaf?> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

********************** \ manyIndentation/leaf? has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])) :4_3:UnDeeper:
********************** / myindented: consuming UnDeeper                                                 :4_3:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

********************** \ myindented: consuming UnDeeper has returned UnDeeper                             :4_4:UnDeeper:
someIndentation> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
someIndentation> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
someIndentation> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

********************* \ someIndentation has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))  :4_4:UnDeeper:
term p/2:someIndentation expr p> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
term p/2:someIndentation expr p> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

******************** \ term p/2:someIndentation expr p has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])) :4_4:UnDeeper:
term p/notLabelTerm> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
term p/notLabelTerm> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

******************* \ term p/notLabelTerm has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))  :4_4:UnDeeper:
term p> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
term p> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

****************** \ term p has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))                 :4_4:UnDeeper:
****************** / binary(Or)                                                                               :4_4:UnDeeper:
binary(Or)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=25:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

****************** / binary(And)                                                                              :4_4:UnDeeper:
binary(And)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=25:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

****************** / binary(SetLess)                                                                          :4_4:UnDeeper:
binary(SetLess)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=25:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

****************** / binary(SetPlus)                                                                          :4_4:UnDeeper:
binary(SetPlus)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=25:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
expression> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
expression> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

***************** \ expression has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_4:UnDeeper:
manyIndentation/leaf?> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
manyIndentation/leaf?> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
manyIndentation/leaf?> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

**************** \ manyIndentation/leaf? has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_4:UnDeeper:
**************** / myindented: consuming UnDeeper                                                               :4_4:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

**************** \ myindented: consuming UnDeeper has returned UnDeeper                                  :4_1:May:
someIndentation> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someIndentation> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someIndentation> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*************** \ someIndentation has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
term p/2:someIndentation expr p> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/2:someIndentation expr p> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************** \ term p/2:someIndentation expr p has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
term p/notLabelTerm> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/notLabelTerm> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/notLabelTerm> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************* \ term p/notLabelTerm has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
term p> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************ \ term p has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
************ / binary(Or)                                                                                    :4_1:May:
binary(Or)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=26:
binary(Or)> unexpected May
binary(Or)> expecting Or

************ / binary(And)                                                                                   :4_1:May:
binary(And)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=26:
binary(And)> unexpected May
binary(And)> expecting And

************ / binary(SetLess)                                                                               :4_1:May:
binary(SetLess)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=26:
binary(SetLess)> unexpected May
binary(SetLess)> expecting SetLess

************ / binary(SetPlus)                                                                               :4_1:May:
binary(SetPlus)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=26:
binary(SetPlus)> unexpected May
binary(SetPlus)> expecting SetPlus

expression> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
expression> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
expression> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*********** \ expression has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
ppp inner> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
ppp inner> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
ppp inner> VALUE: (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********** \ ppp inner has returned Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])] :4_1:May:
pBSR> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pBSR> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pBSR> VALUE: (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********* \ pBSR has returned Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])] :4_1:May:
preambleBoolStructR [Who,Which,Whose]> IN: Who GoDeeper GoDeeper Other "is" GoDeepe <…>
preambleBoolStructR [Who,Which,Whose]> MATCH (COK): Who GoDeeper GoDeeper Other "is" GoDeepe <…>
preambleBoolStructR [Who,Which,Whose]> VALUE: ((Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******** \ preambleBoolStructR [Who,Which,Whose] has returned (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]) :4_1:May:
manyIndentation/leaf?> IN: Who GoDeeper GoDeeper Other "is" GoDeepe <…>
manyIndentation/leaf?> MATCH (COK): Who GoDeeper GoDeeper Other "is" GoDeepe <…>
manyIndentation/leaf?> VALUE: ((Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******* \ manyIndentation/leaf? has returned (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]) :4_1:May:
******* / WHERE                                                                                                   :4_1:May:
WHERE> IN: May GoDeeper Other "sharpen knives" UnDe <…>
WHERE> MATCH (EERR): <EMPTY>
WHERE> ERROR:
WHERE> offset=26:
WHERE> unexpected May
WHERE> expecting Where

******* / preambleParamText:[Having]                                                                              :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=26:
$>|> unexpected May
$>|> expecting Having

preambleParamText:[Having]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleParamText:[Having]> MATCH (EERR): <EMPTY>
preambleParamText:[Having]> ERROR:
preambleParamText:[Having]> offset=26:
preambleParamText:[Having]> unexpected May
preambleParamText:[Having]> expecting Having

******* / preambleParamText:[Given]                                                                               :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=26:
$>|> unexpected May
$>|> expecting Given

preambleParamText:[Given]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=26:
preambleParamText:[Given]> unexpected May
preambleParamText:[Given]> expecting Given

******* / preambleParamText:[Upon]                                                                                :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=26:
$>|> unexpected May
$>|> expecting Upon

preambleParamText:[Upon]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=26:
preambleParamText:[Upon]> unexpected May
preambleParamText:[Upon]> expecting Upon

******* / preambleBoolStructR [Unless]                                                                            :4_1:May:
preambleBoolStructR [Unless]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleBoolStructR [Unless]> MATCH (EERR): <EMPTY>
preambleBoolStructR [Unless]> ERROR:
preambleBoolStructR [Unless]> offset=26:
preambleBoolStructR [Unless]> unexpected May
preambleBoolStructR [Unless]> expecting Unless

******* / preambleBoolStructR [When,If]                                                                           :4_1:May:
preambleBoolStructR [When,If]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleBoolStructR [When,If]> MATCH (EERR): <EMPTY>
preambleBoolStructR [When,If]> ERROR:
preambleBoolStructR [When,If]> offset=26:
preambleBoolStructR [When,If]> unexpected May
preambleBoolStructR [When,If]> expecting If or When

******* / pDT                                                                                                     :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (COK): May
$>|> VALUE: (DMay,[])

******** \ $>| has returned DMay                                                                                  :4_2:GoDeeper:
******** / |>| calling $>>                                                                                        :4_2:GoDeeper:
********* / |>>/recurse                                                                                          :4_2:GoDeeper:
********** / |>>/recurse                                                                                         :4_2:Other "shar:
|>>/recurse> IN: Other "sharpen knives" UnDeeper
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=28:
|>>/recurse> unexpected Other "sharpen knives"
|>>/recurse> expecting GoDeeper

********** / |>>/base                                                                                            :4_2:Other "shar:
*********** / pTemporal/eventually                                                                              :4_2:Other "shar:
pTemporal/eventually> IN: Other "sharpen knives" UnDeeper
pTemporal/eventually> MATCH (EERR): <EMPTY>
pTemporal/eventually> ERROR:
pTemporal/eventually> offset=28:
pTemporal/eventually> unexpected Other "sharpen knives"
pTemporal/eventually> expecting Eventually

*********** / pTemporal/specifically                                                                            :4_2:Other "shar:
************ / $>|                                                                                             :4_2:Other "shar:
$>|> IN: Other "sharpen knives" UnDeeper
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=28:
$>|> unexpected Other "sharpen knives"
$>|> expecting After, Before, By, or On

pTemporal/specifically> IN: Other "sharpen knives" UnDeeper
pTemporal/specifically> MATCH (EERR): <EMPTY>
pTemporal/specifically> ERROR:
pTemporal/specifically> offset=28:
pTemporal/specifically> unexpected Other "sharpen knives"
pTemporal/specifically> expecting After, Before, By, or On

*********** / pTemporal/vaguely                                                                                 :4_2:Other "shar:
pTemporal/vaguely> IN: Other "sharpen knives" UnDeeper
pTemporal/vaguely> MATCH (COK): Other "sharpen knives"
pTemporal/vaguely> VALUE: (Just (TemporalConstraint TVague (Just 0) "sharpen knives"),[])

*********** \ pTemporal/vaguely has returned Just (TemporalConstraint TVague (Just 0) "sharpen knives")          :1_2:UnDeeper:
*********** > |>>/base got Just (Just (TemporalConstraint TVague (Just 0) "sharpen knives"))                     :1_2:UnDeeper:
|>>/base> IN: Other "sharpen knives" UnDeeper
|>>/base> MATCH (COK): Other "sharpen knives"
|>>/base> VALUE: ((Just (Just (TemporalConstraint TVague (Just 0) "sharpen knives")),0),[])

********** \ |>>/base has returned (Just (Just (TemporalConstraint TVague (Just 0) "sharpen knives")),0)          :1_2:UnDeeper:
|>>/recurse> IN: GoDeeper Other "sharpen knives" UnDeeper
|>>/recurse> MATCH (COK): GoDeeper Other "sharpen knives"
|>>/recurse> VALUE: ((Just (Just (TemporalConstraint TVague (Just 0) "sharpen knives")),1),[])

********* \ |>>/recurse has returned (Just (Just (TemporalConstraint TVague (Just 0) "sharpen knives")),1)         :1_2:UnDeeper:
|>| calling $>>> IN: GoDeeper Other "sharpen knives" UnDeeper
|>| calling $>>> MATCH (COK): GoDeeper Other "sharpen knives"
|>| calling $>>> VALUE: ((Just (Just (TemporalConstraint TVague (Just 0) "sharpen knives")),1),[])

******** \ |>| calling $>> has returned (Just (Just (TemporalConstraint TVague (Just 0) "sharpen knives")),1)       :1_2:UnDeeper:
******** / undeepers                                                                                                :1_2:UnDeeper:
********* > sameLine/undeepers: reached end of line; now need to clear 1 UnDeepers                                 :1_2:UnDeeper:
********* > sameLine: success!                                                                                :EOF:
undeepers> IN: UnDeeper
undeepers> MATCH (COK): UnDeeper
undeepers> VALUE: ((),[])

******** \ undeepers has returned ()                                                                           :EOF:
pDT> IN: May GoDeeper Other "sharpen knives" UnDe <…>
pDT> MATCH (COK): May GoDeeper Other "sharpen knives" UnDe <…>
pDT> VALUE: ((DMay,Just (TemporalConstraint TVague (Just 0) "sharpen knives")),[])

******* \ pDT has returned (DMay,Just (TemporalConstraint TVague (Just 0) "sharpen knives"))                    :EOF:
******* / WHERE                                                                                                 :EOF:
WHERE> IN: <EMPTY>
WHERE> MATCH (EERR): <EMPTY>
WHERE> ERROR:
WHERE> offset=30:
WHERE> unexpected end of input
WHERE> expecting Where

******* / preambleParamText:[Having]                                                                            :EOF:
******** / $>|                                                                                                 :EOF:
$>|> IN: <EMPTY>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=30:
$>|> unexpected end of input
$>|> expecting Having

preambleParamText:[Having]> IN: <EMPTY>
preambleParamText:[Having]> MATCH (EERR): <EMPTY>
preambleParamText:[Having]> ERROR:
preambleParamText:[Having]> offset=30:
preambleParamText:[Having]> unexpected end of input
preambleParamText:[Having]> expecting Having or any token

******* / preambleParamText:[Given]                                                                             :EOF:
******** / $>|                                                                                                 :EOF:
$>|> IN: <EMPTY>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=30:
$>|> unexpected end of input
$>|> expecting Given

preambleParamText:[Given]> IN: <EMPTY>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=30:
preambleParamText:[Given]> unexpected end of input
preambleParamText:[Given]> expecting Given or any token

******* / preambleParamText:[Upon]                                                                              :EOF:
******** / $>|                                                                                                 :EOF:
$>|> IN: <EMPTY>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=30:
$>|> unexpected end of input
$>|> expecting Upon

preambleParamText:[Upon]> IN: <EMPTY>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=30:
preambleParamText:[Upon]> unexpected end of input
preambleParamText:[Upon]> expecting Upon or any token

******* / preambleBoolStructR [Unless]                                                                          :EOF:
preambleBoolStructR [Unless]> IN: <EMPTY>
preambleBoolStructR [Unless]> MATCH (EERR): <EMPTY>
preambleBoolStructR [Unless]> ERROR:
preambleBoolStructR [Unless]> offset=30:
preambleBoolStructR [Unless]> unexpected end of input
preambleBoolStructR [Unless]> expecting Unless

******* / preambleBoolStructR [When,If]                                                                         :EOF:
preambleBoolStructR [When,If]> IN: <EMPTY>
preambleBoolStructR [When,If]> MATCH (EERR): <EMPTY>
preambleBoolStructR [When,If]> ERROR:
preambleBoolStructR [When,If]> offset=30:
preambleBoolStructR [When,If]> unexpected end of input
preambleBoolStructR [When,If]> expecting If or When

******* / pDoAction/Do                                                                                          :EOF:
pDoAction/Do> IN: <EMPTY>
pDoAction/Do> MATCH (EERR): <EMPTY>
pDoAction/Do> ERROR:
pDoAction/Do> offset=30:
pDoAction/Do> unexpected end of input
pDoAction/Do> expecting Do

regulative permutation with deontic-temporal> IN: Every GoDeeper Other "person" UnDeeper W <…>
regulative permutation with deontic-temporal> MATCH (CERR): Every GoDeeper Other "person" UnDeeper W <…>
regulative permutation with deontic-temporal> ERROR:
regulative permutation with deontic-temporal> offset=30:
regulative permutation with deontic-temporal> unexpected end of input
regulative permutation with deontic-temporal> expecting Do, Given, Having, If, Unless, Upon, When, Where, or any token

****** / regulative permutation with deontic-action                                                                :1_1:Every:
******* / WHERE                                                                                                   :1_1:Every:
WHERE> IN: Every GoDeeper Other "person" UnDeeper W <…>
WHERE> MATCH (EERR): <EMPTY>
WHERE> ERROR:
WHERE> offset=0:
WHERE> unexpected Every
WHERE> expecting Where

******* / preambleParamText:[Having]                                                                              :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting Having

preambleParamText:[Having]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleParamText:[Having]> MATCH (EERR): <EMPTY>
preambleParamText:[Having]> ERROR:
preambleParamText:[Having]> offset=0:
preambleParamText:[Having]> unexpected Every
preambleParamText:[Having]> expecting Having

******* / preambleParamText:[Given]                                                                               :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting Given

preambleParamText:[Given]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=0:
preambleParamText:[Given]> unexpected Every
preambleParamText:[Given]> expecting Given

******* / preambleParamText:[Upon]                                                                                :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting Upon

preambleParamText:[Upon]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=0:
preambleParamText:[Upon]> unexpected Every
preambleParamText:[Upon]> expecting Upon

******* / preambleBoolStructR [Unless]                                                                            :1_1:Every:
preambleBoolStructR [Unless]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleBoolStructR [Unless]> MATCH (EERR): <EMPTY>
preambleBoolStructR [Unless]> ERROR:
preambleBoolStructR [Unless]> offset=0:
preambleBoolStructR [Unless]> unexpected Every
preambleBoolStructR [Unless]> expecting Unless

******* / preambleBoolStructR [When,If]                                                                           :1_1:Every:
preambleBoolStructR [When,If]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleBoolStructR [When,If]> MATCH (EERR): <EMPTY>
preambleBoolStructR [When,If]> ERROR:
preambleBoolStructR [When,If]> offset=0:
preambleBoolStructR [When,If]> unexpected Every
preambleBoolStructR [When,If]> expecting If or When

******* / pTemporal/eventually                                                                                    :1_1:Every:
pTemporal/eventually> IN: Every GoDeeper Other "person" UnDeeper W <…>
pTemporal/eventually> MATCH (EERR): <EMPTY>
pTemporal/eventually> ERROR:
pTemporal/eventually> offset=0:
pTemporal/eventually> unexpected Every
pTemporal/eventually> expecting Eventually

******* / pTemporal/specifically                                                                                  :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting After, Before, By, or On

pTemporal/specifically> IN: Every GoDeeper Other "person" UnDeeper W <…>
pTemporal/specifically> MATCH (EERR): <EMPTY>
pTemporal/specifically> ERROR:
pTemporal/specifically> offset=0:
pTemporal/specifically> unexpected Every
pTemporal/specifically> expecting After, Before, By, or On

******* / pTemporal/vaguely                                                                                       :1_1:Every:
pTemporal/vaguely> IN: Every GoDeeper Other "person" UnDeeper W <…>
pTemporal/vaguely> MATCH (EERR): <EMPTY>
pTemporal/vaguely> ERROR:
pTemporal/vaguely> offset=0:
pTemporal/vaguely> unexpected Every
pTemporal/vaguely> expecting Other text

******* / pActor [Every,Party,TokAll]                                                                             :1_1:Every:
******** / someIndentation                                                                                        :1_2:GoDeeper:
********* / myindented: consuming GoDeeper                                                                       :1_2:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "person" UnDeeper Who GoD <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

********* \ myindented: consuming GoDeeper has returned GoDeeper                                                  :1_2:Other "pers:
********* / manyIndentation/leaf?                                                                                 :1_2:Other "pers:
********** / pMultiTermAka                                                                                       :1_2:Other "pers:
*********** / pAKA                                                                                              :1_2:Other "pers:
************ / slAKA                                                                                           :1_2:Other "pers:
************* / $*|                                                                                           :1_2:Other "pers:
************** / slAKA base                                                                                  :1_2:Other "pers:
*************** / slMultiTerm                                                                               :1_2:Other "pers:
**************** / someSL                                                                                  :1_2:Other "pers:
someSL> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
someSL> MATCH (COK): Other "person"
someSL> VALUE: ((["person"],0),[])

**************** \ someSL has returned (["person"],0)                                                       :2_2:UnDeeper:
slMultiTerm> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
slMultiTerm> MATCH (COK): Other "person"
slMultiTerm> VALUE: ((["person"],0),[])

*************** \ slMultiTerm has returned (["person"],0)                                                    :2_2:UnDeeper:
slAKA base> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
slAKA base> MATCH (COK): Other "person"
slAKA base> VALUE: ((["person"],0),[])

************** \ slAKA base has returned (["person"],0)                                                       :2_2:UnDeeper:
$*|> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
$*|> MATCH (COK): Other "person"
$*|> VALUE: ((["person"],0),[])

************* \ $*| has returned (["person"],0)                                                                :2_2:UnDeeper:
************* / |>>/recurse                                                                                    :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************* / |>>/base                                                                                       :2_2:UnDeeper:
************** / slAKA optional akapart                                                                       :2_2:UnDeeper:
*************** / |?| optional something                                                                     :2_2:UnDeeper:
**************** / |>>/recurse                                                                              :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

**************** / |>>/base                                                                                 :2_2:UnDeeper:
***************** / PAKA/akapart                                                                           :2_2:UnDeeper:
****************** / $>|                                                                                  :2_2:UnDeeper:
******************* / Aka Token                                                                          :2_2:UnDeeper:
Aka Token> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
Aka Token> MATCH (EERR): <EMPTY>
Aka Token> ERROR:
Aka Token> offset=3:
Aka Token> unexpected UnDeeper
Aka Token> expecting Aka

$>|> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=3:
$>|> unexpected UnDeeper
$>|> expecting Aka

PAKA/akapart> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
PAKA/akapart> MATCH (EERR): <EMPTY>
PAKA/akapart> ERROR:
PAKA/akapart> offset=3:
PAKA/akapart> unexpected UnDeeper
PAKA/akapart> expecting Aka

|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=3:
|>>/base> unexpected UnDeeper
|>>/base> expecting Aka

|?| optional something> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

*************** \ |?| optional something has returned (Nothing,0)                                            :2_2:UnDeeper:
slAKA optional akapart> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
slAKA optional akapart> MATCH (EOK): <EMPTY>
slAKA optional akapart> VALUE: ((Nothing,0),[])

************** \ slAKA optional akapart has returned (Nothing,0)                                              :2_2:UnDeeper:
************** > |>>/base got Nothing                                                                         :2_2:UnDeeper:
|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************* \ |>>/base has returned (Nothing,0)                                                              :2_2:UnDeeper:
************* / |>>/recurse                                                                                    :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************* / |>>/base                                                                                       :2_2:UnDeeper:
************** / slAKA optional typically                                                                     :2_2:UnDeeper:
*************** / |?| optional something                                                                     :2_2:UnDeeper:
**************** / |>>/recurse                                                                              :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

**************** / |>>/base                                                                                 :2_2:UnDeeper:
***************** / typically                                                                              :2_2:UnDeeper:
****************** / $>|                                                                                  :2_2:UnDeeper:
$>|> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=3:
$>|> unexpected UnDeeper
$>|> expecting Typically

typically> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
typically> MATCH (EERR): <EMPTY>
typically> ERROR:
typically> offset=3:
typically> unexpected UnDeeper
typically> expecting Typically

|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=3:
|>>/base> unexpected UnDeeper
|>>/base> expecting Typically

|?| optional something> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

*************** \ |?| optional something has returned (Nothing,0)                                            :2_2:UnDeeper:
slAKA optional typically> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
slAKA optional typically> MATCH (EOK): <EMPTY>
slAKA optional typically> VALUE: ((Nothing,0),[])

************** \ slAKA optional typically has returned (Nothing,0)                                            :2_2:UnDeeper:
************** > |>>/base got Nothing                                                                         :2_2:UnDeeper:
|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************* \ |>>/base has returned (Nothing,0)                                                              :2_2:UnDeeper:
************* > slAKA: proceeding after base and entityalias are retrieved ...                                 :2_2:UnDeeper:
************* > pAKA: entityalias = Nothing                                                                    :2_2:UnDeeper:
slAKA> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
slAKA> MATCH (COK): Other "person"
slAKA> VALUE: ((["person"],0),[])

************ \ slAKA has returned (["person"],0)                                                                :2_2:UnDeeper:
************ / undeepers                                                                                        :2_2:UnDeeper:
************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers                         :2_2:UnDeeper:
************* > sameLine: success!                                                                             :2_2:UnDeeper:
undeepers> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

************ \ undeepers has returned ()                                                                        :2_2:UnDeeper:
pAKA> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
pAKA> MATCH (COK): Other "person"
pAKA> VALUE: (["person"],[])

*********** \ pAKA has returned ["person"]                                                                       :2_2:UnDeeper:
pMultiTermAka> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
pMultiTermAka> MATCH (COK): Other "person"
pMultiTermAka> VALUE: (["person"],[])

********** \ pMultiTermAka has returned ["person"]                                                                :2_2:UnDeeper:
manyIndentation/leaf?> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
manyIndentation/leaf?> MATCH (COK): Other "person"
manyIndentation/leaf?> VALUE: (["person"],[])

********* \ manyIndentation/leaf? has returned ["person"]                                                          :2_2:UnDeeper:
********* / myindented: consuming UnDeeper                                                                         :2_2:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

********* \ myindented: consuming UnDeeper has returned UnDeeper                                                :2_1:Who:
someIndentation> IN: GoDeeper Other "person" UnDeeper Who GoD <…>
someIndentation> MATCH (COK): GoDeeper Other "person" UnDeeper
someIndentation> VALUE: (["person"],[])

******** \ someIndentation has returned ["person"]                                                               :2_1:Who:
pActor [Every,Party,TokAll]> IN: Every GoDeeper Other "person" UnDeeper W <…>
pActor [Every,Party,TokAll]> MATCH (COK): Every GoDeeper Other "person" UnDeeper
pActor [Every,Party,TokAll]> VALUE: ((Every,Leaf (("person" :| [],Nothing) :| [])),[])

******* \ pActor [Every,Party,TokAll] has returned (Every,Leaf (("person" :| [],Nothing) :| []))                  :2_1:Who:
******* / manyIndentation/leaf?                                                                                   :2_1:Who:
******** / preambleBoolStructR [Who,Which,Whose]                                                                 :2_1:Who:
********* / pBSR                                                                                                 :2_2:GoDeeper:
********** / ppp inner                                                                                          :2_2:GoDeeper:
*********** / expression                                                                                       :2_2:GoDeeper:
************ / labelPrefix                                                                                    :2_2:GoDeeper:
labelPrefix> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=5:
labelPrefix> unexpected GoDeeper
labelPrefix> expecting Other text

************ / term p                                                                                         :2_2:GoDeeper:
************* / term p/1a:label directly above                                                               :2_2:GoDeeper:
************** / $*|                                                                                        :2_2:GoDeeper:
*************** / someSL                                                                                   :2_2:GoDeeper:
**************** / pNumAsText                                                                             :2_2:GoDeeper:
pNumAsText> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=5:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=5:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=5:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=5:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

************* / term p/b:label to the left of line below, with EOL                                           :2_2:GoDeeper:
************** / someSL                                                                                     :2_2:GoDeeper:
*************** / pNumAsText                                                                               :2_2:GoDeeper:
pNumAsText> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=5:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=5:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=5:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

************* / term p/notLabelTerm                                                                          :2_2:GoDeeper:
************** / term p/2:someIndentation expr p                                                            :2_2:GoDeeper:
*************** / someIndentation                                                                          :2_2:GoDeeper:
**************** / myindented: consuming GoDeeper                                                         :2_2:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

**************** \ myindented: consuming GoDeeper has returned GoDeeper                                     :2_3:GoDeeper:
**************** / manyIndentation/leaf?                                                                    :2_3:GoDeeper:
***************** / expression                                                                             :2_3:GoDeeper:
****************** / labelPrefix                                                                          :2_3:GoDeeper:
labelPrefix> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=6:
labelPrefix> unexpected GoDeeper
labelPrefix> expecting Other text

****************** / term p                                                                               :2_3:GoDeeper:
******************* / term p/1a:label directly above                                                     :2_3:GoDeeper:
******************** / $*|                                                                              :2_3:GoDeeper:
********************* / someSL                                                                         :2_3:GoDeeper:
********************** / pNumAsText                                                                   :2_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=6:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=6:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=6:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=6:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

******************* / term p/b:label to the left of line below, with EOL                                 :2_3:GoDeeper:
******************** / someSL                                                                           :2_3:GoDeeper:
********************* / pNumAsText                                                                     :2_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=6:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=6:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=6:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

******************* / term p/notLabelTerm                                                                :2_3:GoDeeper:
******************** / term p/2:someIndentation expr p                                                  :2_3:GoDeeper:
********************* / someIndentation                                                                :2_3:GoDeeper:
********************** / myindented: consuming GoDeeper                                               :2_3:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

********************** \ myindented: consuming GoDeeper has returned GoDeeper                          :2_3:Other "is":
********************** / manyIndentation/leaf?                                                         :2_3:Other "is":
*********************** / expression                                                                  :2_3:Other "is":
************************ / labelPrefix                                                               :2_3:Other "is":
labelPrefix> IN: Other "is" GoDeeper Other "immortal" GoD <…>
labelPrefix> MATCH (COK): Other "is"
labelPrefix> VALUE: ("is",[])

************************ \ labelPrefix has returned "is"                                              :2_4:GoDeeper:
************************ / term p                                                                     :2_4:GoDeeper:
************************* / term p/1a:label directly above                                           :2_4:GoDeeper:
************************** / $*|                                                                    :2_4:GoDeeper:
*************************** / someSL                                                               :2_4:GoDeeper:
**************************** / pNumAsText                                                         :2_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=8:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=8:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=8:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=8:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

************************* / term p/b:label to the left of line below, with EOL                       :2_4:GoDeeper:
************************** / someSL                                                                 :2_4:GoDeeper:
*************************** / pNumAsText                                                           :2_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=8:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=8:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=8:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

************************* / term p/notLabelTerm                                                      :2_4:GoDeeper:
************************** / term p/2:someIndentation expr p                                        :2_4:GoDeeper:
*************************** / someIndentation                                                      :2_4:GoDeeper:
**************************** / myindented: consuming GoDeeper                                     :2_4:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

**************************** \ myindented: consuming GoDeeper has returned GoDeeper                :2_4:Other "immo:
**************************** / manyIndentation/leaf?                                               :2_4:Other "immo:
***************************** / expression                                                        :2_4:Other "immo:
****************************** / labelPrefix                                                     :2_4:Other "immo:
labelPrefix> IN: Other "immortal" GoDeeper Typically GoDe <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=10:
labelPrefix> unexpected GoDeeper

****************************** / term p                                                          :2_4:Other "immo:
******************************* / term p/1a:label directly above                                :2_4:Other "immo:
******************************** / $*|                                                         :2_4:Other "immo:
********************************* / someSL                                                    :2_4:Other "immo:
********************************** / pNumAsText                                                :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

********************************* \ someSL has returned (["immortal"],0)                       :2_5:GoDeeper:
********************************* / pNumAsText                                                 :2_5:GoDeeper:
pNumAsText> IN: GoDeeper Typically GoDeeper Other "false <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (CERR): Other "immortal"
$*|> ERROR:
$*|> offset=10:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/1a:label directly above> MATCH (CERR): Other "immortal"
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=10:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

******************************* / term p/b:label to the left of line below, with EOL            :2_4:Other "immo:
******************************** / someSL                                                      :2_4:Other "immo:
********************************* / pNumAsText                                                  :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

******************************** \ someSL has returned (["immortal"],0)                         :2_5:GoDeeper:
******************************** / undeepers                                                    :2_5:GoDeeper:
********************************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers :2_5:GoDeeper:
********************************* > sameLine: success!                                         :2_5:GoDeeper:
undeepers> IN: GoDeeper Typically GoDeeper Other "false <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

******************************** \ undeepers has returned ()                                    :2_5:GoDeeper:
******************************** / matching EOL                                                 :2_5:GoDeeper:
matching EOL> IN: GoDeeper Typically GoDeeper Other "false <…>
matching EOL> MATCH (EERR): <EMPTY>
matching EOL> ERROR:
matching EOL> offset=10:
matching EOL> unexpected GoDeeper
matching EOL> expecting EOL

term p/b:label to the left of line below, with EOL> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/b:label to the left of line below, with EOL> MATCH (CERR): Other "immortal"
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=10:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting EOL

******************************* / term p/notLabelTerm                                           :2_4:Other "immo:
******************************** / term p/2:someIndentation expr p                             :2_4:Other "immo:
********************************* / someIndentation                                           :2_4:Other "immo:
********************************** / myindented: consuming GoDeeper                          :2_4:Other "immo:
myindented: consuming GoDeeper> IN: Other "immortal" GoDeeper Typically GoDe <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=9:
myindented: consuming GoDeeper> unexpected Other "immortal"
myindented: consuming GoDeeper> expecting GoDeeper

someIndentation> IN: Other "immortal" GoDeeper Typically GoDe <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=9:
someIndentation> unexpected Other "immortal"
someIndentation> expecting GoDeeper

term p/2:someIndentation expr p> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/2:someIndentation expr p> MATCH (EERR): <EMPTY>
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=9:
term p/2:someIndentation expr p> unexpected Other "immortal"
term p/2:someIndentation expr p> expecting GoDeeper

******************************** / term p/3:plain p                                            :2_4:Other "immo:
********************************* / pRelPred                                                  :2_4:Other "immo:
********************************** / slRelPred                                               :2_4:Other "immo:
*********************************** / nested simpleHorn                                     :2_4:Other "immo:
************************************ > |^|                                                 :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slMultiTerm                                       :2_4:Other "immo:
************************************** / someSL                                          :2_4:Other "immo:
*************************************** / pNumAsText                                      :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

************************************** \ someSL has returned (["immortal"],0)             :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

************************************* \ slMultiTerm has returned (["immortal"],0)          :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************ \ $*| has returned (["immortal"],0)                    :2_5:GoDeeper:
************************************ / |^| deeps                                            :2_5:GoDeeper:
|^| deeps> IN: GoDeeper Typically GoDeeper Other "false <…>
|^| deeps> MATCH (COK): GoDeeper
|^| deeps> VALUE: (([()],1),[])

************************************ \ |^| deeps has returned ([()],1)                       :2_5:Typically:
nested simpleHorn> IN: Other "immortal" GoDeeper Typically GoDe <…>
nested simpleHorn> MATCH (CERR): Other "immortal" GoDeeper
nested simpleHorn> ERROR:
nested simpleHorn> offset=11:
nested simpleHorn> unexpected Typically
nested simpleHorn> expecting GoDeeper or Means

*********************************** / RPConstraint                                          :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slMultiTerm                                       :2_4:Other "immo:
************************************** / someSL                                          :2_4:Other "immo:
*************************************** / pNumAsText                                      :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

************************************** \ someSL has returned (["immortal"],0)             :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

************************************* \ slMultiTerm has returned (["immortal"],0)          :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************ \ $*| has returned (["immortal"],0)                    :2_5:GoDeeper:
************************************ / |>| calling $>>                                      :2_5:GoDeeper:
************************************* / |>>/recurse                                        :2_5:GoDeeper:
************************************** / |>>/recurse                                       :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                          :2_5:Typically:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=11:
|>>/base> unexpected Typically
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>>/recurse> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/recurse> MATCH (CERR): GoDeeper
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

************************************* / |>>/base                                           :2_5:GoDeeper:
|>>/base> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=10:
|>>/base> unexpected GoDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: GoDeeper Typically GoDeeper Other "false <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=11:
|>| calling $>>> unexpected Typically
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPConstraint> IN: Other "immortal" GoDeeper Typically GoDe <…>
RPConstraint> MATCH (CERR): Other "immortal"
RPConstraint> ERROR:
RPConstraint> offset=11:
RPConstraint> unexpected Typically
RPConstraint> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPBoolStructR                                         :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slMultiTerm                                       :2_4:Other "immo:
************************************** / someSL                                          :2_4:Other "immo:
*************************************** / pNumAsText                                      :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

************************************** \ someSL has returned (["immortal"],0)             :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

************************************* \ slMultiTerm has returned (["immortal"],0)          :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************ \ $*| has returned (["immortal"],0)                    :2_5:GoDeeper:
************************************ / |>| calling $>>                                      :2_5:GoDeeper:
************************************* / |>>/recurse                                        :2_5:GoDeeper:
************************************** / |>>/recurse                                       :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                          :2_5:Typically:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=11:
|>>/base> unexpected Typically
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>>/recurse> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/recurse> MATCH (CERR): GoDeeper
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

************************************* / |>>/base                                           :2_5:GoDeeper:
|>>/base> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=10:
|>>/base> unexpected GoDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: GoDeeper Typically GoDeeper Other "false <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=11:
|>| calling $>>> unexpected Typically
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPBoolStructR> IN: Other "immortal" GoDeeper Typically GoDe <…>
RPBoolStructR> MATCH (CERR): Other "immortal"
RPBoolStructR> ERROR:
RPBoolStructR> offset=11:
RPBoolStructR> unexpected Typically
RPBoolStructR> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPMT                                                  :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slAKA                                             :2_4:Other "immo:
************************************** / $*|                                             :2_4:Other "immo:
*************************************** / slAKA base                                    :2_4:Other "immo:
**************************************** / slMultiTerm                                 :2_4:Other "immo:
***************************************** / someSL                                    :2_4:Other "immo:
****************************************** / pNumAsText                                :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

***************************************** \ someSL has returned (["immortal"],0)       :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

**************************************** \ slMultiTerm has returned (["immortal"],0)    :2_5:GoDeeper:
slAKA base> IN: Other "immortal" GoDeeper Typically GoDe <…>
slAKA base> MATCH (COK): Other "immortal"
slAKA base> VALUE: ((["immortal"],0),[])

*************************************** \ slAKA base has returned (["immortal"],0)       :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************** \ $*| has returned (["immortal"],0)                :2_5:GoDeeper:
************************************** / |>>/recurse                                      :2_5:GoDeeper:
*************************************** / |>>/recurse                                     :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

*************************************** / |>>/base                                        :2_5:Typically:
**************************************** / slAKA optional akapart                        :2_5:Typically:
***************************************** / |?| optional something                      :2_5:Typically:
****************************************** / |>>/recurse                               :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

****************************************** / |>>/base                                  :2_5:Typically:
******************************************* / PAKA/akapart                            :2_5:Typically:
******************************************** / $>|                                   :2_5:Typically:
********************************************* / Aka Token                           :2_5:Typically:
Aka Token> IN: Typically GoDeeper Other "false" UnDeepe <…>
Aka Token> MATCH (EERR): <EMPTY>
Aka Token> ERROR:
Aka Token> offset=11:
Aka Token> unexpected Typically
Aka Token> expecting Aka

$>|> IN: Typically GoDeeper Other "false" UnDeepe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=11:
$>|> unexpected Typically
$>|> expecting Aka

PAKA/akapart> IN: Typically GoDeeper Other "false" UnDeepe <…>
PAKA/akapart> MATCH (EERR): <EMPTY>
PAKA/akapart> ERROR:
PAKA/akapart> offset=11:
PAKA/akapart> unexpected Typically
PAKA/akapart> expecting Aka

|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=11:
|>>/base> unexpected Typically
|>>/base> expecting Aka

|?| optional something> IN: Typically GoDeeper Other "false" UnDeepe <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

***************************************** \ |?| optional something has returned (Nothing,0) :2_5:Typically:
slAKA optional akapart> IN: Typically GoDeeper Other "false" UnDeepe <…>
slAKA optional akapart> MATCH (EOK): <EMPTY>
slAKA optional akapart> VALUE: ((Nothing,0),[])

**************************************** \ slAKA optional akapart has returned (Nothing,0) :2_5:Typically:
**************************************** > |>>/base got Nothing                          :2_5:Typically:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

*************************************** \ |>>/base has returned (Nothing,0)               :2_5:Typically:
|>>/recurse> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/recurse> MATCH (COK): GoDeeper
|>>/recurse> VALUE: ((Nothing,1),[])

************************************** \ |>>/recurse has returned (Nothing,1)              :2_5:Typically:
************************************** / |>>/recurse                                       :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                          :2_5:Typically:
*************************************** / slAKA optional typically                        :2_5:Typically:
**************************************** / |?| optional something                        :2_5:Typically:
***************************************** / |>>/recurse                                 :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

***************************************** / |>>/base                                    :2_5:Typically:
****************************************** / typically                                 :2_5:Typically:
******************************************* / $>|                                     :2_5:Typically:
$>|> IN: Typically GoDeeper Other "false" UnDeepe <…>
$>|> MATCH (COK): Typically
$>|> VALUE: (Typically,[])

******************************************* \ $>| has returned Typically               :2_6:GoDeeper:
******************************************* / |>>/recurse                              :2_6:GoDeeper:
******************************************** / |>>/recurse                             :2_6:Other "fals:
|>>/recurse> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=13:
|>>/recurse> unexpected Other "false"
|>>/recurse> expecting GoDeeper

******************************************** / |>>/base                                :2_6:Other "fals:
********************************************* / slMultiTerm                           :2_6:Other "fals:
********************************************** / someSL                              :2_6:Other "fals:
someSL> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
someSL> MATCH (COK): Other "false"
someSL> VALUE: ((["false"],0),[])

********************************************** \ someSL has returned (["false"],0) :3_3:UnDeeper:
slMultiTerm> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
slMultiTerm> MATCH (COK): Other "false"
slMultiTerm> VALUE: ((["false"],0),[])

********************************************* \ slMultiTerm has returned (["false"],0) :3_3:UnDeeper:
********************************************* > |>>/base got ["false"]           :3_3:UnDeeper:
|>>/base> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
|>>/base> MATCH (COK): Other "false"
|>>/base> VALUE: ((["false"],0),[])

******************************************** \ |>>/base has returned (["false"],0) :3_3:UnDeeper:
|>>/recurse> IN: GoDeeper Other "false" UnDeeper UnDeeper <…>
|>>/recurse> MATCH (COK): GoDeeper Other "false"
|>>/recurse> VALUE: ((["false"],1),[])

******************************************* \ |>>/recurse has returned (["false"],1) :3_3:UnDeeper:
typically> IN: Typically GoDeeper Other "false" UnDeepe <…>
typically> MATCH (COK): Typically GoDeeper Other "false"
typically> VALUE: ((["false"],1),[])

****************************************** \ typically has returned (["false"],1)   :3_3:UnDeeper:
****************************************** > |>>/base got ["false"]                 :3_3:UnDeeper:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (COK): Typically GoDeeper Other "false"
|>>/base> VALUE: ((["false"],1),[])

***************************************** \ |>>/base has returned (["false"],1)      :3_3:UnDeeper:
|?| optional something> IN: Typically GoDeeper Other "false" UnDeepe <…>
|?| optional something> MATCH (COK): Typically GoDeeper Other "false"
|?| optional something> VALUE: ((Just ["false"],1),[])

**************************************** \ |?| optional something has returned (Just ["false"],1) :3_3:UnDeeper:
slAKA optional typically> IN: Typically GoDeeper Other "false" UnDeepe <…>
slAKA optional typically> MATCH (COK): Typically GoDeeper Other "false"
slAKA optional typically> VALUE: ((Just ["false"],1),[])

*************************************** \ slAKA optional typically has returned (Just ["false"],1) :3_3:UnDeeper:
*************************************** > |>>/base got Just ["false"]                  :3_3:UnDeeper:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (COK): Typically GoDeeper Other "false"
|>>/base> VALUE: ((Just ["false"],1),[])

************************************** \ |>>/base has returned (Just ["false"],1)       :3_3:UnDeeper:
************************************** > slAKA: proceeding after base and entityalias are retrieved ... :3_3:UnDeeper:
************************************** > pAKA: entityalias = Nothing                    :3_3:UnDeeper:
slAKA> IN: Other "immortal" GoDeeper Typically GoDe <…>
slAKA> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
slAKA> VALUE: ((["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************************* \ slAKA has returned (["immortal"],2)              :3_3:UnDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
$*|> VALUE: ((["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************************ \ $*| has returned (["immortal"],2)                  :3_3:UnDeeper:
RPMT> IN: Other "immortal" GoDeeper Typically GoDe <…>
RPMT> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
RPMT> VALUE: ((RPMT ["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*********************************** \ RPMT has returned (RPMT ["immortal"],2)              :3_3:UnDeeper:
slRelPred> IN: Other "immortal" GoDeeper Typically GoDe <…>
slRelPred> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
slRelPred> VALUE: ((RPMT ["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************************** \ slRelPred has returned (RPMT ["immortal"],2)           :3_3:UnDeeper:
********************************** / undeepers                                              :3_3:UnDeeper:
*********************************** > sameLine/undeepers: reached end of line; now need to clear 2 UnDeepers :3_3:UnDeeper:
*********************************** > sameLine: success!                                       :3_5:UnDeeper:
undeepers> IN: UnDeeper UnDeeper UnDeeper UnDeeper Or G <…>
undeepers> MATCH (COK): UnDeeper UnDeeper
undeepers> VALUE: ((),[])

********************************** \ undeepers has returned ()                                  :3_5:UnDeeper:
pRelPred> IN: Other "immortal" GoDeeper Typically GoDe <…>
pRelPred> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
pRelPred> VALUE: (RPMT ["immortal"],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************************* \ pRelPred has returned RPMT ["immortal"]                      :3_5:UnDeeper:
term p/3:plain p> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/3:plain p> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
term p/3:plain p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************************** \ term p/3:plain p has returned MyLeaf (RPMT ["immortal"])       :3_5:UnDeeper:
term p/notLabelTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/notLabelTerm> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["immortal"])      :3_5:UnDeeper:
term p> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
term p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

****************************** \ term p has returned MyLeaf (RPMT ["immortal"])                     :3_5:UnDeeper:
****************************** / binary(Or)                                                         :3_5:UnDeeper:
binary(Or)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=16:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

****************************** / binary(And)                                                        :3_5:UnDeeper:
binary(And)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=16:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

****************************** / binary(SetLess)                                                    :3_5:UnDeeper:
binary(SetLess)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=16:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

****************************** / binary(SetPlus)                                                    :3_5:UnDeeper:
binary(SetPlus)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=16:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "immortal" GoDeeper Typically GoDe <…>
expression> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
expression> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

***************************** \ expression has returned MyLeaf (RPMT ["immortal"])                   :3_5:UnDeeper:
manyIndentation/leaf?> IN: Other "immortal" GoDeeper Typically GoDe <…>
manyIndentation/leaf?> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
manyIndentation/leaf?> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

**************************** \ manyIndentation/leaf? has returned MyLeaf (RPMT ["immortal"])          :3_5:UnDeeper:
**************************** / myindented: consuming UnDeeper                                         :3_5:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

**************************** \ myindented: consuming UnDeeper has returned UnDeeper                     :3_6:UnDeeper:
someIndentation> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
someIndentation> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
someIndentation> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*************************** \ someIndentation has returned MyLeaf (RPMT ["immortal"])                    :3_6:UnDeeper:
term p/2:someIndentation expr p> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
term p/2:someIndentation expr p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************** \ term p/2:someIndentation expr p has returned MyLeaf (RPMT ["immortal"])      :3_6:UnDeeper:
term p/notLabelTerm> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["immortal"])                    :3_6:UnDeeper:
term p> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
term p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************ \ term p has returned MyLeaf (RPMT ["immortal"])                                   :3_6:UnDeeper:
************************ / binary(Or)                                                                       :3_6:UnDeeper:
binary(Or)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=17:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

************************ / binary(And)                                                                      :3_6:UnDeeper:
binary(And)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=17:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

************************ / binary(SetLess)                                                                  :3_6:UnDeeper:
binary(SetLess)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=17:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

************************ / binary(SetPlus)                                                                  :3_6:UnDeeper:
binary(SetPlus)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=17:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "is" GoDeeper Other "immortal" GoD <…>
expression> MATCH (COK): Other "is" GoDeeper Other "immortal" GoD <…>
expression> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*********************** \ expression has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))                :3_6:UnDeeper:
manyIndentation/leaf?> IN: Other "is" GoDeeper Other "immortal" GoD <…>
manyIndentation/leaf?> MATCH (COK): Other "is" GoDeeper Other "immortal" GoD <…>
manyIndentation/leaf?> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************** \ manyIndentation/leaf? has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))       :3_6:UnDeeper:
********************** / myindented: consuming UnDeeper                                                       :3_6:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

********************** \ myindented: consuming UnDeeper has returned UnDeeper                        :3_2:Or:
someIndentation> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
someIndentation> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
someIndentation> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************* \ someIndentation has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))      :3_2:Or:
term p/2:someIndentation expr p> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
term p/2:someIndentation expr p> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************** \ term p/2:someIndentation expr p has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"])) :3_2:Or:
term p/notLabelTerm> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
term p/notLabelTerm> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************* \ term p/notLabelTerm has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))      :3_2:Or:
term p> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
term p> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

****************** \ term p has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))                     :3_2:Or:
****************** / binary(Or)                                                                          :3_2:Or:
binary(Or)> IN: Or GoDeeper Other "has" GoDeeper Other " <…>
binary(Or)> MATCH (COK): Or
binary(Or)> VALUE: (Or,[])

****************** \ binary(Or) has returned Or                                                           :3_3:GoDeeper:
****************** / term p                                                                               :3_3:GoDeeper:
******************* / term p/1a:label directly above                                                     :3_3:GoDeeper:
******************** / $*|                                                                              :3_3:GoDeeper:
********************* / someSL                                                                         :3_3:GoDeeper:
********************** / pNumAsText                                                                   :3_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=19:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=19:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=19:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=19:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

******************* / term p/b:label to the left of line below, with EOL                                 :3_3:GoDeeper:
******************** / someSL                                                                           :3_3:GoDeeper:
********************* / pNumAsText                                                                     :3_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=19:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=19:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=19:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

******************* / term p/notLabelTerm                                                                :3_3:GoDeeper:
******************** / term p/2:someIndentation expr p                                                  :3_3:GoDeeper:
********************* / someIndentation                                                                :3_3:GoDeeper:
********************** / myindented: consuming GoDeeper                                               :3_3:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

********************** \ myindented: consuming GoDeeper has returned GoDeeper                          :3_3:Other "has":
********************** / manyIndentation/leaf?                                                         :3_3:Other "has":
*********************** / expression                                                                  :3_3:Other "has":
************************ / labelPrefix                                                               :3_3:Other "has":
labelPrefix> IN: Other "has" GoDeeper Other "health insur <…>
labelPrefix> MATCH (COK): Other "has"
labelPrefix> VALUE: ("has",[])

************************ \ labelPrefix has returned "has"                                             :3_4:GoDeeper:
************************ / term p                                                                     :3_4:GoDeeper:
************************* / term p/1a:label directly above                                           :3_4:GoDeeper:
************************** / $*|                                                                    :3_4:GoDeeper:
*************************** / someSL                                                               :3_4:GoDeeper:
**************************** / pNumAsText                                                         :3_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "health insurance" UnDeep <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=21:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "health insurance" UnDeep <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=21:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "health insurance" UnDeep <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=21:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=21:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

************************* / term p/b:label to the left of line below, with EOL                       :3_4:GoDeeper:
************************** / someSL                                                                 :3_4:GoDeeper:
*************************** / pNumAsText                                                           :3_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "health insurance" UnDeep <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=21:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "health insurance" UnDeep <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=21:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=21:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

************************* / term p/notLabelTerm                                                      :3_4:GoDeeper:
************************** / term p/2:someIndentation expr p                                        :3_4:GoDeeper:
*************************** / someIndentation                                                      :3_4:GoDeeper:
**************************** / myindented: consuming GoDeeper                                     :3_4:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "health insurance" UnDeep <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

**************************** \ myindented: consuming GoDeeper has returned GoDeeper                :3_4:Other "heal:
**************************** / manyIndentation/leaf?                                               :3_4:Other "heal:
***************************** / expression                                                        :3_4:Other "heal:
****************************** / labelPrefix                                                     :3_4:Other "heal:
labelPrefix> IN: Other "health insurance" UnDeeper UnDeep <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=23:
labelPrefix> unexpected UnDeeper

****************************** / term p                                                          :3_4:Other "heal:
******************************* / term p/1a:label directly above                                :3_4:Other "heal:
******************************** / $*|                                                         :3_4:Other "heal:
********************************* / someSL                                                    :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

********************************* \ someSL has returned (["health insurance"],0)           :4_2:UnDeeper:
********************************* / pNumAsText                                             :4_2:UnDeeper:
pNumAsText> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=23:
pNumAsText> unexpected UnDeeper
pNumAsText> expecting number

$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (CERR): Other "health insurance"
$*|> ERROR:
$*|> offset=23:
$*|> unexpected UnDeeper
$*|> expecting GoDeeper or other text or number

term p/1a:label directly above> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/1a:label directly above> MATCH (CERR): Other "health insurance"
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=23:
term p/1a:label directly above> unexpected UnDeeper
term p/1a:label directly above> expecting GoDeeper or other text or number

******************************* / term p/b:label to the left of line below, with EOL            :3_4:Other "heal:
******************************** / someSL                                                      :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

******************************** \ someSL has returned (["health insurance"],0)             :4_2:UnDeeper:
******************************** / undeepers                                                :4_2:UnDeeper:
********************************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers :4_2:UnDeeper:
********************************* > sameLine: success!                                     :4_2:UnDeeper:
undeepers> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

******************************** \ undeepers has returned ()                                :4_2:UnDeeper:
******************************** / matching EOL                                             :4_2:UnDeeper:
matching EOL> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
matching EOL> MATCH (EERR): <EMPTY>
matching EOL> ERROR:
matching EOL> offset=23:
matching EOL> unexpected UnDeeper
matching EOL> expecting EOL

term p/b:label to the left of line below, with EOL> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/b:label to the left of line below, with EOL> MATCH (CERR): Other "health insurance"
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=23:
term p/b:label to the left of line below, with EOL> unexpected UnDeeper
term p/b:label to the left of line below, with EOL> expecting EOL or GoDeeper

******************************* / term p/notLabelTerm                                           :3_4:Other "heal:
******************************** / term p/2:someIndentation expr p                             :3_4:Other "heal:
********************************* / someIndentation                                           :3_4:Other "heal:
********************************** / myindented: consuming GoDeeper                          :3_4:Other "heal:
myindented: consuming GoDeeper> IN: Other "health insurance" UnDeeper UnDeep <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=22:
myindented: consuming GoDeeper> unexpected Other "health insurance"
myindented: consuming GoDeeper> expecting GoDeeper

someIndentation> IN: Other "health insurance" UnDeeper UnDeep <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=22:
someIndentation> unexpected Other "health insurance"
someIndentation> expecting GoDeeper

term p/2:someIndentation expr p> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/2:someIndentation expr p> MATCH (EERR): <EMPTY>
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=22:
term p/2:someIndentation expr p> unexpected Other "health insurance"
term p/2:someIndentation expr p> expecting GoDeeper

******************************** / term p/3:plain p                                            :3_4:Other "heal:
********************************* / pRelPred                                                  :3_4:Other "heal:
********************************** / slRelPred                                               :3_4:Other "heal:
*********************************** / nested simpleHorn                                     :3_4:Other "heal:
************************************ > |^|                                                 :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slMultiTerm                                       :3_4:Other "heal:
************************************** / someSL                                          :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

************************************* \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
************************************ / |^| deeps                                        :4_2:UnDeeper:
|^| deeps> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|^| deeps> MATCH (COK): UnDeeper UnDeeper UnDeeper
|^| deeps> VALUE: (([(),(),()],-3),[])

************************************ \ |^| deeps has returned ([(),(),()],-3)        :4_1:May:
nested simpleHorn> IN: Other "health insurance" UnDeeper UnDeep <…>
nested simpleHorn> MATCH (CERR): Other "health insurance" UnDeeper UnDeep <…>
nested simpleHorn> ERROR:
nested simpleHorn> offset=26:
nested simpleHorn> unexpected May
nested simpleHorn> expecting Means or UnDeeper

*********************************** / RPConstraint                                          :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slMultiTerm                                       :3_4:Other "heal:
************************************** / someSL                                          :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

************************************* \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
************************************ / |>| calling $>>                                  :4_2:UnDeeper:
************************************* / |>>/recurse                                    :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************* / |>>/base                                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=23:
|>| calling $>>> unexpected UnDeeper
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPConstraint> IN: Other "health insurance" UnDeeper UnDeep <…>
RPConstraint> MATCH (CERR): Other "health insurance"
RPConstraint> ERROR:
RPConstraint> offset=23:
RPConstraint> unexpected UnDeeper
RPConstraint> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPBoolStructR                                         :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slMultiTerm                                       :3_4:Other "heal:
************************************** / someSL                                          :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

************************************* \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
************************************ / |>| calling $>>                                  :4_2:UnDeeper:
************************************* / |>>/recurse                                    :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************* / |>>/base                                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=23:
|>| calling $>>> unexpected UnDeeper
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPBoolStructR> IN: Other "health insurance" UnDeeper UnDeep <…>
RPBoolStructR> MATCH (CERR): Other "health insurance"
RPBoolStructR> ERROR:
RPBoolStructR> offset=23:
RPBoolStructR> unexpected UnDeeper
RPBoolStructR> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPMT                                                  :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slAKA                                             :3_4:Other "heal:
************************************** / $*|                                             :3_4:Other "heal:
*************************************** / slAKA base                                    :3_4:Other "heal:
**************************************** / slMultiTerm                                 :3_4:Other "heal:
***************************************** / someSL                                    :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

***************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

**************************************** \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
slAKA base> IN: Other "health insurance" UnDeeper UnDeep <…>
slAKA base> MATCH (COK): Other "health insurance"
slAKA base> VALUE: ((["health insurance"],0),[])

*************************************** \ slAKA base has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************** \ $*| has returned (["health insurance"],0)    :4_2:UnDeeper:
************************************** / |>>/recurse                                  :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                     :4_2:UnDeeper:
*************************************** / slAKA optional akapart                     :4_2:UnDeeper:
**************************************** / |?| optional something                   :4_2:UnDeeper:
***************************************** / |>>/recurse                            :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

***************************************** / |>>/base                               :4_2:UnDeeper:
****************************************** / PAKA/akapart                         :4_2:UnDeeper:
******************************************* / $>|                                :4_2:UnDeeper:
******************************************** / Aka Token                        :4_2:UnDeeper:
Aka Token> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
Aka Token> MATCH (EERR): <EMPTY>
Aka Token> ERROR:
Aka Token> offset=23:
Aka Token> unexpected UnDeeper
Aka Token> expecting Aka

$>|> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=23:
$>|> unexpected UnDeeper
$>|> expecting Aka

PAKA/akapart> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
PAKA/akapart> MATCH (EERR): <EMPTY>
PAKA/akapart> ERROR:
PAKA/akapart> offset=23:
PAKA/akapart> unexpected UnDeeper
PAKA/akapart> expecting Aka

|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Aka

|?| optional something> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

**************************************** \ |?| optional something has returned (Nothing,0) :4_2:UnDeeper:
slAKA optional akapart> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
slAKA optional akapart> MATCH (EOK): <EMPTY>
slAKA optional akapart> VALUE: ((Nothing,0),[])

*************************************** \ slAKA optional akapart has returned (Nothing,0) :4_2:UnDeeper:
*************************************** > |>>/base got Nothing                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************************************** \ |>>/base has returned (Nothing,0)            :4_2:UnDeeper:
************************************** / |>>/recurse                                  :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                     :4_2:UnDeeper:
*************************************** / slAKA optional typically                   :4_2:UnDeeper:
**************************************** / |?| optional something                   :4_2:UnDeeper:
***************************************** / |>>/recurse                            :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

***************************************** / |>>/base                               :4_2:UnDeeper:
****************************************** / typically                            :4_2:UnDeeper:
******************************************* / $>|                                :4_2:UnDeeper:
$>|> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=23:
$>|> unexpected UnDeeper
$>|> expecting Typically

typically> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
typically> MATCH (EERR): <EMPTY>
typically> ERROR:
typically> offset=23:
typically> unexpected UnDeeper
typically> expecting Typically

|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Typically

|?| optional something> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

**************************************** \ |?| optional something has returned (Nothing,0) :4_2:UnDeeper:
slAKA optional typically> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
slAKA optional typically> MATCH (EOK): <EMPTY>
slAKA optional typically> VALUE: ((Nothing,0),[])

*************************************** \ slAKA optional typically has returned (Nothing,0) :4_2:UnDeeper:
*************************************** > |>>/base got Nothing                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************************************** \ |>>/base has returned (Nothing,0)            :4_2:UnDeeper:
************************************** > slAKA: proceeding after base and entityalias are retrieved ... :4_2:UnDeeper:
************************************** > pAKA: entityalias = Nothing                  :4_2:UnDeeper:
slAKA> IN: Other "health insurance" UnDeeper UnDeep <…>
slAKA> MATCH (COK): Other "health insurance"
slAKA> VALUE: ((["health insurance"],0),[])

************************************* \ slAKA has returned (["health insurance"],0)    :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
RPMT> IN: Other "health insurance" UnDeeper UnDeep <…>
RPMT> MATCH (COK): Other "health insurance"
RPMT> VALUE: ((RPMT ["health insurance"],0),[])

*********************************** \ RPMT has returned (RPMT ["health insurance"],0)    :4_2:UnDeeper:
slRelPred> IN: Other "health insurance" UnDeeper UnDeep <…>
slRelPred> MATCH (COK): Other "health insurance"
slRelPred> VALUE: ((RPMT ["health insurance"],0),[])

********************************** \ slRelPred has returned (RPMT ["health insurance"],0) :4_2:UnDeeper:
********************************** / undeepers                                            :4_2:UnDeeper:
*********************************** > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers :4_2:UnDeeper:
*********************************** > sameLine: success!                                 :4_2:UnDeeper:
undeepers> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

********************************** \ undeepers has returned ()                            :4_2:UnDeeper:
pRelPred> IN: Other "health insurance" UnDeeper UnDeep <…>
pRelPred> MATCH (COK): Other "health insurance"
pRelPred> VALUE: (RPMT ["health insurance"],[])

********************************* \ pRelPred has returned RPMT ["health insurance"]        :4_2:UnDeeper:
term p/3:plain p> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/3:plain p> MATCH (COK): Other "health insurance"
term p/3:plain p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

******************************** \ term p/3:plain p has returned MyLeaf (RPMT ["health insurance"]) :4_2:UnDeeper:
term p/notLabelTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/notLabelTerm> MATCH (COK): Other "health insurance"
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

******************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["health insurance"]) :4_2:UnDeeper:
term p> IN: Other "health insurance" UnDeeper UnDeep <…>
term p> MATCH (COK): Other "health insurance"
term p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

****************************** \ term p has returned MyLeaf (RPMT ["health insurance"])       :4_2:UnDeeper:
****************************** / binary(Or)                                                   :4_2:UnDeeper:
binary(Or)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=23:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

****************************** / binary(And)                                                  :4_2:UnDeeper:
binary(And)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=23:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

****************************** / binary(SetLess)                                              :4_2:UnDeeper:
binary(SetLess)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=23:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

****************************** / binary(SetPlus)                                              :4_2:UnDeeper:
binary(SetPlus)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=23:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "health insurance" UnDeeper UnDeep <…>
expression> MATCH (COK): Other "health insurance"
expression> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

***************************** \ expression has returned MyLeaf (RPMT ["health insurance"])     :4_2:UnDeeper:
manyIndentation/leaf?> IN: Other "health insurance" UnDeeper UnDeep <…>
manyIndentation/leaf?> MATCH (COK): Other "health insurance"
manyIndentation/leaf?> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

**************************** \ manyIndentation/leaf? has returned MyLeaf (RPMT ["health insurance"]) :4_2:UnDeeper:
**************************** / myindented: consuming UnDeeper                                   :4_2:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

**************************** \ myindented: consuming UnDeeper has returned UnDeeper               :4_3:UnDeeper:
someIndentation> IN: GoDeeper Other "health insurance" UnDeep <…>
someIndentation> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
someIndentation> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

*************************** \ someIndentation has returned MyLeaf (RPMT ["health insurance"])      :4_3:UnDeeper:
term p/2:someIndentation expr p> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
term p/2:someIndentation expr p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

************************** \ term p/2:someIndentation expr p has returned MyLeaf (RPMT ["health insurance"]) :4_3:UnDeeper:
term p/notLabelTerm> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["health insurance"])      :4_3:UnDeeper:
term p> IN: GoDeeper Other "health insurance" UnDeep <…>
term p> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
term p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

************************ \ term p has returned MyLeaf (RPMT ["health insurance"])                     :4_3:UnDeeper:
************************ / binary(Or)                                                                 :4_3:UnDeeper:
binary(Or)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=24:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

************************ / binary(And)                                                                :4_3:UnDeeper:
binary(And)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=24:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

************************ / binary(SetLess)                                                            :4_3:UnDeeper:
binary(SetLess)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=24:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

************************ / binary(SetPlus)                                                            :4_3:UnDeeper:
binary(SetPlus)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=24:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "has" GoDeeper Other "health insur <…>
expression> MATCH (COK): Other "has" GoDeeper Other "health insur <…>
expression> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

*********************** \ expression has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])) :4_3:UnDeeper:
manyIndentation/leaf?> IN: Other "has" GoDeeper Other "health insur <…>
manyIndentation/leaf?> MATCH (COK): Other "has" GoDeeper Other "health insur <…>
manyIndentation/leaf?> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

********************** \ manyIndentation/leaf? has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])) :4_3:UnDeeper:
********************** / myindented: consuming UnDeeper                                                 :4_3:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

********************** \ myindented: consuming UnDeeper has returned UnDeeper                             :4_4:UnDeeper:
someIndentation> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
someIndentation> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
someIndentation> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

********************* \ someIndentation has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))  :4_4:UnDeeper:
term p/2:someIndentation expr p> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
term p/2:someIndentation expr p> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

******************** \ term p/2:someIndentation expr p has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])) :4_4:UnDeeper:
term p/notLabelTerm> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
term p/notLabelTerm> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

******************* \ term p/notLabelTerm has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))  :4_4:UnDeeper:
term p> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
term p> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

****************** \ term p has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))                 :4_4:UnDeeper:
****************** / binary(Or)                                                                               :4_4:UnDeeper:
binary(Or)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=25:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

****************** / binary(And)                                                                              :4_4:UnDeeper:
binary(And)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=25:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

****************** / binary(SetLess)                                                                          :4_4:UnDeeper:
binary(SetLess)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=25:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

****************** / binary(SetPlus)                                                                          :4_4:UnDeeper:
binary(SetPlus)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=25:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
expression> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
expression> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

***************** \ expression has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_4:UnDeeper:
manyIndentation/leaf?> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
manyIndentation/leaf?> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
manyIndentation/leaf?> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

**************** \ manyIndentation/leaf? has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_4:UnDeeper:
**************** / myindented: consuming UnDeeper                                                               :4_4:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

**************** \ myindented: consuming UnDeeper has returned UnDeeper                                  :4_1:May:
someIndentation> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someIndentation> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someIndentation> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*************** \ someIndentation has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
term p/2:someIndentation expr p> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/2:someIndentation expr p> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************** \ term p/2:someIndentation expr p has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
term p/notLabelTerm> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/notLabelTerm> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/notLabelTerm> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************* \ term p/notLabelTerm has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
term p> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************ \ term p has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
************ / binary(Or)                                                                                    :4_1:May:
binary(Or)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=26:
binary(Or)> unexpected May
binary(Or)> expecting Or

************ / binary(And)                                                                                   :4_1:May:
binary(And)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=26:
binary(And)> unexpected May
binary(And)> expecting And

************ / binary(SetLess)                                                                               :4_1:May:
binary(SetLess)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=26:
binary(SetLess)> unexpected May
binary(SetLess)> expecting SetLess

************ / binary(SetPlus)                                                                               :4_1:May:
binary(SetPlus)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=26:
binary(SetPlus)> unexpected May
binary(SetPlus)> expecting SetPlus

expression> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
expression> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
expression> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*********** \ expression has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
ppp inner> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
ppp inner> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
ppp inner> VALUE: (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********** \ ppp inner has returned Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])] :4_1:May:
pBSR> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pBSR> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pBSR> VALUE: (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********* \ pBSR has returned Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])] :4_1:May:
preambleBoolStructR [Who,Which,Whose]> IN: Who GoDeeper GoDeeper Other "is" GoDeepe <…>
preambleBoolStructR [Who,Which,Whose]> MATCH (COK): Who GoDeeper GoDeeper Other "is" GoDeepe <…>
preambleBoolStructR [Who,Which,Whose]> VALUE: ((Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******** \ preambleBoolStructR [Who,Which,Whose] has returned (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]) :4_1:May:
manyIndentation/leaf?> IN: Who GoDeeper GoDeeper Other "is" GoDeepe <…>
manyIndentation/leaf?> MATCH (COK): Who GoDeeper GoDeeper Other "is" GoDeepe <…>
manyIndentation/leaf?> VALUE: ((Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******* \ manyIndentation/leaf? has returned (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]) :4_1:May:
******* / WHERE                                                                                                   :4_1:May:
WHERE> IN: May GoDeeper Other "sharpen knives" UnDe <…>
WHERE> MATCH (EERR): <EMPTY>
WHERE> ERROR:
WHERE> offset=26:
WHERE> unexpected May
WHERE> expecting Where

******* / preambleParamText:[Having]                                                                              :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=26:
$>|> unexpected May
$>|> expecting Having

preambleParamText:[Having]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleParamText:[Having]> MATCH (EERR): <EMPTY>
preambleParamText:[Having]> ERROR:
preambleParamText:[Having]> offset=26:
preambleParamText:[Having]> unexpected May
preambleParamText:[Having]> expecting Having

******* / preambleParamText:[Given]                                                                               :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=26:
$>|> unexpected May
$>|> expecting Given

preambleParamText:[Given]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=26:
preambleParamText:[Given]> unexpected May
preambleParamText:[Given]> expecting Given

******* / preambleParamText:[Upon]                                                                                :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=26:
$>|> unexpected May
$>|> expecting Upon

preambleParamText:[Upon]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=26:
preambleParamText:[Upon]> unexpected May
preambleParamText:[Upon]> expecting Upon

******* / preambleBoolStructR [Unless]                                                                            :4_1:May:
preambleBoolStructR [Unless]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleBoolStructR [Unless]> MATCH (EERR): <EMPTY>
preambleBoolStructR [Unless]> ERROR:
preambleBoolStructR [Unless]> offset=26:
preambleBoolStructR [Unless]> unexpected May
preambleBoolStructR [Unless]> expecting Unless

******* / preambleBoolStructR [When,If]                                                                           :4_1:May:
preambleBoolStructR [When,If]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleBoolStructR [When,If]> MATCH (EERR): <EMPTY>
preambleBoolStructR [When,If]> ERROR:
preambleBoolStructR [When,If]> offset=26:
preambleBoolStructR [When,If]> unexpected May
preambleBoolStructR [When,If]> expecting If or When

******* / pTemporal/eventually                                                                                    :4_1:May:
pTemporal/eventually> IN: May GoDeeper Other "sharpen knives" UnDe <…>
pTemporal/eventually> MATCH (EERR): <EMPTY>
pTemporal/eventually> ERROR:
pTemporal/eventually> offset=26:
pTemporal/eventually> unexpected May
pTemporal/eventually> expecting Eventually

******* / pTemporal/specifically                                                                                  :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=26:
$>|> unexpected May
$>|> expecting After, Before, By, or On

pTemporal/specifically> IN: May GoDeeper Other "sharpen knives" UnDe <…>
pTemporal/specifically> MATCH (EERR): <EMPTY>
pTemporal/specifically> ERROR:
pTemporal/specifically> offset=26:
pTemporal/specifically> unexpected May
pTemporal/specifically> expecting After, Before, By, or On

******* / pTemporal/vaguely                                                                                       :4_1:May:
pTemporal/vaguely> IN: May GoDeeper Other "sharpen knives" UnDe <…>
pTemporal/vaguely> MATCH (EERR): <EMPTY>
pTemporal/vaguely> ERROR:
pTemporal/vaguely> offset=26:
pTemporal/vaguely> unexpected May
pTemporal/vaguely> expecting Other text

******* / pDA                                                                                                     :4_1:May:
******** / pAction calling dBoolStructP                                                                           :4_2:GoDeeper:
********* / dBoolStructP calling exprP                                                                           :4_2:GoDeeper:
********** / expr pParamText                                                                                    :4_2:GoDeeper:
*********** / expression                                                                                       :4_2:GoDeeper:
************ / labelPrefix                                                                                    :4_2:GoDeeper:
labelPrefix> IN: GoDeeper Other "sharpen knives" UnDeeper
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=27:
labelPrefix> unexpected GoDeeper
labelPrefix> expecting Other text

************ / term p                                                                                         :4_2:GoDeeper:
************* / term p/1a:label directly above                                                               :4_2:GoDeeper:
************** / $*|                                                                                        :4_2:GoDeeper:
*************** / someSL                                                                                   :4_2:GoDeeper:
**************** / pNumAsText                                                                             :4_2:GoDeeper:
pNumAsText> IN: GoDeeper Other "sharpen knives" UnDeeper
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=27:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "sharpen knives" UnDeeper
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=27:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "sharpen knives" UnDeeper
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=27:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "sharpen knives" UnDeeper
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=27:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

************* / term p/b:label to the left of line below, with EOL                                           :4_2:GoDeeper:
************** / someSL                                                                                     :4_2:GoDeeper:
*************** / pNumAsText                                                                               :4_2:GoDeeper:
pNumAsText> IN: GoDeeper Other "sharpen knives" UnDeeper
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=27:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "sharpen knives" UnDeeper
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=27:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "sharpen knives" UnDeeper
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=27:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

************* / term p/notLabelTerm                                                                          :4_2:GoDeeper:
************** / term p/2:someIndentation expr p                                                            :4_2:GoDeeper:
*************** / someIndentation                                                                          :4_2:GoDeeper:
**************** / myindented: consuming GoDeeper                                                         :4_2:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "sharpen knives" UnDeeper
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

**************** \ myindented: consuming GoDeeper has returned GoDeeper                                    :4_2:Other "shar:
**************** / manyIndentation/leaf?                                                                   :4_2:Other "shar:
***************** / expression                                                                            :4_2:Other "shar:
****************** / labelPrefix                                                                         :4_2:Other "shar:
labelPrefix> IN: Other "sharpen knives" UnDeeper
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=29:
labelPrefix> unexpected UnDeeper

****************** / term p                                                                              :4_2:Other "shar:
******************* / term p/1a:label directly above                                                    :4_2:Other "shar:
******************** / $*|                                                                             :4_2:Other "shar:
********************* / someSL                                                                        :4_2:Other "shar:
someSL> IN: Other "sharpen knives" UnDeeper
someSL> MATCH (COK): Other "sharpen knives"
someSL> VALUE: ((["sharpen knives"],0),[])

********************* \ someSL has returned (["sharpen knives"],0)                                     :1_2:UnDeeper:
********************* / pNumAsText                                                                     :1_2:UnDeeper:
pNumAsText> IN: UnDeeper
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=29:
pNumAsText> unexpected UnDeeper
pNumAsText> expecting number

$*|> IN: Other "sharpen knives" UnDeeper
$*|> MATCH (CERR): Other "sharpen knives"
$*|> ERROR:
$*|> offset=29:
$*|> unexpected UnDeeper
$*|> expecting GoDeeper or other text or number

term p/1a:label directly above> IN: Other "sharpen knives" UnDeeper
term p/1a:label directly above> MATCH (CERR): Other "sharpen knives"
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=29:
term p/1a:label directly above> unexpected UnDeeper
term p/1a:label directly above> expecting GoDeeper or other text or number

******************* / term p/b:label to the left of line below, with EOL                                :4_2:Other "shar:
******************** / someSL                                                                          :4_2:Other "shar:
someSL> IN: Other "sharpen knives" UnDeeper
someSL> MATCH (COK): Other "sharpen knives"
someSL> VALUE: ((["sharpen knives"],0),[])

******************** \ someSL has returned (["sharpen knives"],0)                                       :1_2:UnDeeper:
******************** / undeepers                                                                        :1_2:UnDeeper:
********************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers         :1_2:UnDeeper:
********************* > sameLine: success!                                                             :1_2:UnDeeper:
undeepers> IN: UnDeeper
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

******************** \ undeepers has returned ()                                                        :1_2:UnDeeper:
******************** / matching EOL                                                                     :1_2:UnDeeper:
matching EOL> IN: UnDeeper
matching EOL> MATCH (EERR): <EMPTY>
matching EOL> ERROR:
matching EOL> offset=29:
matching EOL> unexpected UnDeeper
matching EOL> expecting EOL

term p/b:label to the left of line below, with EOL> IN: Other "sharpen knives" UnDeeper
term p/b:label to the left of line below, with EOL> MATCH (CERR): Other "sharpen knives"
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=29:
term p/b:label to the left of line below, with EOL> unexpected UnDeeper
term p/b:label to the left of line below, with EOL> expecting EOL or GoDeeper

******************* / term p/notLabelTerm                                                               :4_2:Other "shar:
******************** / term p/2:someIndentation expr p                                                 :4_2:Other "shar:
********************* / someIndentation                                                               :4_2:Other "shar:
********************** / myindented: consuming GoDeeper                                              :4_2:Other "shar:
myindented: consuming GoDeeper> IN: Other "sharpen knives" UnDeeper
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=28:
myindented: consuming GoDeeper> unexpected Other "sharpen knives"
myindented: consuming GoDeeper> expecting GoDeeper

someIndentation> IN: Other "sharpen knives" UnDeeper
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=28:
someIndentation> unexpected Other "sharpen knives"
someIndentation> expecting GoDeeper

term p/2:someIndentation expr p> IN: Other "sharpen knives" UnDeeper
term p/2:someIndentation expr p> MATCH (EERR): <EMPTY>
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=28:
term p/2:someIndentation expr p> unexpected Other "sharpen knives"
term p/2:someIndentation expr p> expecting GoDeeper

******************** / term p/3:plain p                                                                :4_2:Other "shar:
********************* / pParamText                                                                    :4_2:Other "shar:
********************** / pParamText(flat) first line: pKeyValues                                     :4_2:Other "shar:
*********************** / pKeyValuesAka                                                             :4_2:Other "shar:
************************ / slAKA                                                                   :4_2:Other "shar:
************************* / $*|                                                                   :4_2:Other "shar:
************************** / slAKA base                                                          :4_2:Other "shar:
*************************** / slKeyValues                                                       :4_2:Other "shar:
**************************** / $*|                                                             :4_2:Other "shar:
***************************** / someSL                                                        :4_2:Other "shar:
someSL> IN: Other "sharpen knives" UnDeeper
someSL> MATCH (COK): Other "sharpen knives"
someSL> VALUE: ((["sharpen knives"],0),[])

***************************** \ someSL has returned (["sharpen knives"],0)                     :1_2:UnDeeper:
$*|> IN: Other "sharpen knives" UnDeeper
$*|> MATCH (COK): Other "sharpen knives"
$*|> VALUE: ((["sharpen knives"],0),[])

**************************** \ $*| has returned (["sharpen knives"],0)                          :1_2:UnDeeper:
**************************** / |>>/recurse                                                      :1_2:UnDeeper:
|>>/recurse> IN: UnDeeper
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=29:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

**************************** / |>>/base                                                         :1_2:UnDeeper:
***************************** / |?| optional something                                         :1_2:UnDeeper:
****************************** / |>>/recurse                                                  :1_2:UnDeeper:
|>>/recurse> IN: UnDeeper
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=29:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

****************************** / |>>/base                                                     :1_2:UnDeeper:
******************************* / slTypeSig                                                  :1_2:UnDeeper:
******************************** / $>|                                                      :1_2:UnDeeper:
$>|> IN: UnDeeper
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=29:
$>|> unexpected UnDeeper
$>|> expecting Is or TypeSeparator

slTypeSig> IN: UnDeeper
slTypeSig> MATCH (EERR): <EMPTY>
slTypeSig> ERROR:
slTypeSig> offset=29:
slTypeSig> unexpected UnDeeper
slTypeSig> expecting Is or TypeSeparator

|>>/base> IN: UnDeeper
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=29:
|>>/base> unexpected UnDeeper
|>>/base> expecting Is or TypeSeparator

|?| optional something> IN: UnDeeper
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

***************************** \ |?| optional something has returned (Nothing,0)                :1_2:UnDeeper:
***************************** > |>>/base got Nothing                                           :1_2:UnDeeper:
|>>/base> IN: UnDeeper
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

**************************** \ |>>/base has returned (Nothing,0)                                :1_2:UnDeeper:
slKeyValues> IN: Other "sharpen knives" UnDeeper
slKeyValues> MATCH (COK): Other "sharpen knives"
slKeyValues> VALUE: ((("sharpen knives" :| [],Nothing),0),[])

*************************** \ slKeyValues has returned (("sharpen knives" :| [],Nothing),0)      :1_2:UnDeeper:
slAKA base> IN: Other "sharpen knives" UnDeeper
slAKA base> MATCH (COK): Other "sharpen knives"
slAKA base> VALUE: ((("sharpen knives" :| [],Nothing),0),[])

************************** \ slAKA base has returned (("sharpen knives" :| [],Nothing),0)         :1_2:UnDeeper:
$*|> IN: Other "sharpen knives" UnDeeper
$*|> MATCH (COK): Other "sharpen knives"
$*|> VALUE: ((("sharpen knives" :| [],Nothing),0),[])

************************* \ $*| has returned (("sharpen knives" :| [],Nothing),0)                  :1_2:UnDeeper:
************************* / |>>/recurse                                                            :1_2:UnDeeper:
|>>/recurse> IN: UnDeeper
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=29:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************* / |>>/base                                                               :1_2:UnDeeper:
************************** / slAKA optional akapart                                               :1_2:UnDeeper:
*************************** / |?| optional something                                             :1_2:UnDeeper:
**************************** / |>>/recurse                                                      :1_2:UnDeeper:
|>>/recurse> IN: UnDeeper
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=29:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

**************************** / |>>/base                                                         :1_2:UnDeeper:
***************************** / PAKA/akapart                                                   :1_2:UnDeeper:
****************************** / $>|                                                          :1_2:UnDeeper:
******************************* / Aka Token                                                  :1_2:UnDeeper:
Aka Token> IN: UnDeeper
Aka Token> MATCH (EERR): <EMPTY>
Aka Token> ERROR:
Aka Token> offset=29:
Aka Token> unexpected UnDeeper
Aka Token> expecting Aka

$>|> IN: UnDeeper
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=29:
$>|> unexpected UnDeeper
$>|> expecting Aka

PAKA/akapart> IN: UnDeeper
PAKA/akapart> MATCH (EERR): <EMPTY>
PAKA/akapart> ERROR:
PAKA/akapart> offset=29:
PAKA/akapart> unexpected UnDeeper
PAKA/akapart> expecting Aka

|>>/base> IN: UnDeeper
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=29:
|>>/base> unexpected UnDeeper
|>>/base> expecting Aka

|?| optional something> IN: UnDeeper
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

*************************** \ |?| optional something has returned (Nothing,0)                    :1_2:UnDeeper:
slAKA optional akapart> IN: UnDeeper
slAKA optional akapart> MATCH (EOK): <EMPTY>
slAKA optional akapart> VALUE: ((Nothing,0),[])

************************** \ slAKA optional akapart has returned (Nothing,0)                      :1_2:UnDeeper:
************************** > |>>/base got Nothing                                                 :1_2:UnDeeper:
|>>/base> IN: UnDeeper
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************************* \ |>>/base has returned (Nothing,0)                                      :1_2:UnDeeper:
************************* / |>>/recurse                                                            :1_2:UnDeeper:
|>>/recurse> IN: UnDeeper
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=29:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************* / |>>/base                                                               :1_2:UnDeeper:
************************** / slAKA optional typically                                             :1_2:UnDeeper:
*************************** / |?| optional something                                             :1_2:UnDeeper:
**************************** / |>>/recurse                                                      :1_2:UnDeeper:
|>>/recurse> IN: UnDeeper
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=29:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

**************************** / |>>/base                                                         :1_2:UnDeeper:
***************************** / typically                                                      :1_2:UnDeeper:
****************************** / $>|                                                          :1_2:UnDeeper:
$>|> IN: UnDeeper
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=29:
$>|> unexpected UnDeeper
$>|> expecting Typically

typically> IN: UnDeeper
typically> MATCH (EERR): <EMPTY>
typically> ERROR:
typically> offset=29:
typically> unexpected UnDeeper
typically> expecting Typically

|>>/base> IN: UnDeeper
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=29:
|>>/base> unexpected UnDeeper
|>>/base> expecting Typically

|?| optional something> IN: UnDeeper
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

*************************** \ |?| optional something has returned (Nothing,0)                    :1_2:UnDeeper:
slAKA optional typically> IN: UnDeeper
slAKA optional typically> MATCH (EOK): <EMPTY>
slAKA optional typically> VALUE: ((Nothing,0),[])

************************** \ slAKA optional typically has returned (Nothing,0)                    :1_2:UnDeeper:
************************** > |>>/base got Nothing                                                 :1_2:UnDeeper:
|>>/base> IN: UnDeeper
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************************* \ |>>/base has returned (Nothing,0)                                      :1_2:UnDeeper:
************************* > slAKA: proceeding after base and entityalias are retrieved ...         :1_2:UnDeeper:
************************* > pAKA: entityalias = Nothing                                            :1_2:UnDeeper:
slAKA> IN: Other "sharpen knives" UnDeeper
slAKA> MATCH (COK): Other "sharpen knives"
slAKA> VALUE: ((("sharpen knives" :| [],Nothing),0),[])

************************ \ slAKA has returned (("sharpen knives" :| [],Nothing),0)                  :1_2:UnDeeper:
************************ / undeepers                                                                :1_2:UnDeeper:
************************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers :1_2:UnDeeper:
************************* > sameLine: success!                                                     :1_2:UnDeeper:
undeepers> IN: UnDeeper
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

************************ \ undeepers has returned ()                                                :1_2:UnDeeper:
pKeyValuesAka> IN: Other "sharpen knives" UnDeeper
pKeyValuesAka> MATCH (COK): Other "sharpen knives"
pKeyValuesAka> VALUE: (("sharpen knives" :| [],Nothing),[])

*********************** \ pKeyValuesAka has returned ("sharpen knives" :| [],Nothing)                :1_2:UnDeeper:
pParamText(flat) first line: pKeyValues> IN: Other "sharpen knives" UnDeeper
pParamText(flat) first line: pKeyValues> MATCH (COK): Other "sharpen knives"
pParamText(flat) first line: pKeyValues> VALUE: (("sharpen knives" :| [],Nothing),[])

********************** \ pParamText(flat) first line: pKeyValues has returned ("sharpen knives" :| [],Nothing) :1_2:UnDeeper:
********************** / pParamText(flat) subsequent lines: sameMany pKeyValues                       :1_2:UnDeeper:
*********************** / manyIndentation/leaf?                                                      :1_2:UnDeeper:
************************ / sameMany                                                                 :1_2:UnDeeper:
************************* / pKeyValuesAka                                                          :1_2:UnDeeper:
************************** / slAKA                                                                :1_2:UnDeeper:
*************************** / $*|                                                                :1_2:UnDeeper:
**************************** / slAKA base                                                       :1_2:UnDeeper:
***************************** / slKeyValues                                                    :1_2:UnDeeper:
****************************** / $*|                                                          :1_2:UnDeeper:
******************************* / someSL                                                     :1_2:UnDeeper:
******************************** / pNumAsText                                               :1_2:UnDeeper:
pNumAsText> IN: UnDeeper
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=29:
pNumAsText> unexpected UnDeeper
pNumAsText> expecting number

someSL> IN: UnDeeper
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=29:
someSL> unexpected UnDeeper
someSL> expecting other text or number

$*|> IN: UnDeeper
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=29:
$*|> unexpected UnDeeper
$*|> expecting other text or number

slKeyValues> IN: UnDeeper
slKeyValues> MATCH (EERR): <EMPTY>
slKeyValues> ERROR:
slKeyValues> offset=29:
slKeyValues> unexpected UnDeeper
slKeyValues> expecting other text or number

slAKA base> IN: UnDeeper
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=29:
slAKA base> unexpected UnDeeper
slAKA base> expecting other text or number

$*|> IN: UnDeeper
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=29:
$*|> unexpected UnDeeper
$*|> expecting other text or number

slAKA> IN: UnDeeper
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=29:
slAKA> unexpected UnDeeper
slAKA> expecting other text or number

pKeyValuesAka> IN: UnDeeper
pKeyValuesAka> MATCH (EERR): <EMPTY>
pKeyValuesAka> ERROR:
pKeyValuesAka> offset=29:
pKeyValuesAka> unexpected UnDeeper
pKeyValuesAka> expecting other text or number

sameMany> IN: UnDeeper
sameMany> MATCH (EOK): <EMPTY>
sameMany> VALUE: ([],[])

************************ \ sameMany has returned []                                                 :1_2:UnDeeper:
manyIndentation/leaf?> IN: UnDeeper
manyIndentation/leaf?> MATCH (EOK): <EMPTY>
manyIndentation/leaf?> VALUE: ([],[])

*********************** \ manyIndentation/leaf? has returned []                                      :1_2:UnDeeper:
pParamText(flat) subsequent lines: sameMany pKeyValues> IN: UnDeeper
pParamText(flat) subsequent lines: sameMany pKeyValues> MATCH (EOK): <EMPTY>
pParamText(flat) subsequent lines: sameMany pKeyValues> VALUE: ([],[])

********************** \ pParamText(flat) subsequent lines: sameMany pKeyValues has returned []       :1_2:UnDeeper:
pParamText> IN: Other "sharpen knives" UnDeeper
pParamText> MATCH (COK): Other "sharpen knives"
pParamText> VALUE: (("sharpen knives" :| [],Nothing) :| [],[])

********************* \ pParamText has returned ("sharpen knives" :| [],Nothing) :| []                 :1_2:UnDeeper:
term p/3:plain p> IN: Other "sharpen knives" UnDeeper
term p/3:plain p> MATCH (COK): Other "sharpen knives"
term p/3:plain p> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

******************** \ term p/3:plain p has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])    :1_2:UnDeeper:
term p/notLabelTerm> IN: Other "sharpen knives" UnDeeper
term p/notLabelTerm> MATCH (COK): Other "sharpen knives"
term p/notLabelTerm> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

******************* \ term p/notLabelTerm has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])   :1_2:UnDeeper:
term p> IN: Other "sharpen knives" UnDeeper
term p> MATCH (COK): Other "sharpen knives"
term p> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

****************** \ term p has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])                  :1_2:UnDeeper:
****************** / binary(Or)                                                                           :1_2:UnDeeper:
binary(Or)> IN: UnDeeper
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=29:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

****************** / binary(And)                                                                          :1_2:UnDeeper:
binary(And)> IN: UnDeeper
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=29:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

****************** / binary(SetLess)                                                                      :1_2:UnDeeper:
binary(SetLess)> IN: UnDeeper
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=29:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

****************** / binary(SetPlus)                                                                      :1_2:UnDeeper:
binary(SetPlus)> IN: UnDeeper
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=29:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "sharpen knives" UnDeeper
expression> MATCH (COK): Other "sharpen knives"
expression> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

***************** \ expression has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])                :1_2:UnDeeper:
manyIndentation/leaf?> IN: Other "sharpen knives" UnDeeper
manyIndentation/leaf?> MATCH (COK): Other "sharpen knives"
manyIndentation/leaf?> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

**************** \ manyIndentation/leaf? has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])       :1_2:UnDeeper:
**************** / myindented: consuming UnDeeper                                                           :1_2:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

**************** \ myindented: consuming UnDeeper has returned UnDeeper                                :EOF:
someIndentation> IN: GoDeeper Other "sharpen knives" UnDeeper
someIndentation> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
someIndentation> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

*************** \ someIndentation has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])          :EOF:
term p/2:someIndentation expr p> IN: GoDeeper Other "sharpen knives" UnDeeper
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
term p/2:someIndentation expr p> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

************** \ term p/2:someIndentation expr p has returned MyLeaf (("sharpen knives" :| [],Nothing) :| []) :EOF:
term p/notLabelTerm> IN: GoDeeper Other "sharpen knives" UnDeeper
term p/notLabelTerm> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
term p/notLabelTerm> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

************* \ term p/notLabelTerm has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])          :EOF:
term p> IN: GoDeeper Other "sharpen knives" UnDeeper
term p> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
term p> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

************ \ term p has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])                         :EOF:
************ / binary(Or)                                                                                  :EOF:
binary(Or)> IN: <EMPTY>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=30:
binary(Or)> unexpected end of input
binary(Or)> expecting Or

************ / binary(And)                                                                                 :EOF:
binary(And)> IN: <EMPTY>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=30:
binary(And)> unexpected end of input
binary(And)> expecting And

************ / binary(SetLess)                                                                             :EOF:
binary(SetLess)> IN: <EMPTY>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=30:
binary(SetLess)> unexpected end of input
binary(SetLess)> expecting SetLess

************ / binary(SetPlus)                                                                             :EOF:
binary(SetPlus)> IN: <EMPTY>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=30:
binary(SetPlus)> unexpected end of input
binary(SetPlus)> expecting SetPlus

expression> IN: GoDeeper Other "sharpen knives" UnDeeper
expression> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
expression> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

*********** \ expression has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])                       :EOF:
expr pParamText> IN: GoDeeper Other "sharpen knives" UnDeeper
expr pParamText> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
expr pParamText> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

********** \ expr pParamText has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])                    :EOF:
dBoolStructP calling exprP> IN: GoDeeper Other "sharpen knives" UnDeeper
dBoolStructP calling exprP> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
dBoolStructP calling exprP> VALUE: (Leaf (("sharpen knives" :| [],Nothing) :| []),[])

********* \ dBoolStructP calling exprP has returned Leaf (("sharpen knives" :| [],Nothing) :| [])             :EOF:
pAction calling dBoolStructP> IN: GoDeeper Other "sharpen knives" UnDeeper
pAction calling dBoolStructP> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
pAction calling dBoolStructP> VALUE: (Leaf (("sharpen knives" :| [],Nothing) :| []),[])

******** \ pAction calling dBoolStructP has returned Leaf (("sharpen knives" :| [],Nothing) :| [])             :EOF:
pDA> IN: May GoDeeper Other "sharpen knives" UnDe <…>
pDA> MATCH (COK): May GoDeeper Other "sharpen knives" UnDe <…>
pDA> VALUE: ((DMay,Leaf (("sharpen knives" :| [],Nothing) :| [])),[])

******* \ pDA has returned (DMay,Leaf (("sharpen knives" :| [],Nothing) :| []))                                 :EOF:
******* / WHERE                                                                                                 :EOF:
WHERE> IN: <EMPTY>
WHERE> MATCH (EERR): <EMPTY>
WHERE> ERROR:
WHERE> offset=30:
WHERE> unexpected end of input
WHERE> expecting Where

******* / preambleParamText:[Having]                                                                            :EOF:
******** / $>|                                                                                                 :EOF:
$>|> IN: <EMPTY>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=30:
$>|> unexpected end of input
$>|> expecting Having

preambleParamText:[Having]> IN: <EMPTY>
preambleParamText:[Having]> MATCH (EERR): <EMPTY>
preambleParamText:[Having]> ERROR:
preambleParamText:[Having]> offset=30:
preambleParamText:[Having]> unexpected end of input
preambleParamText:[Having]> expecting Having or any token

******* / preambleParamText:[Given]                                                                             :EOF:
******** / $>|                                                                                                 :EOF:
$>|> IN: <EMPTY>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=30:
$>|> unexpected end of input
$>|> expecting Given

preambleParamText:[Given]> IN: <EMPTY>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=30:
preambleParamText:[Given]> unexpected end of input
preambleParamText:[Given]> expecting Given or any token

******* / preambleParamText:[Upon]                                                                              :EOF:
******** / $>|                                                                                                 :EOF:
$>|> IN: <EMPTY>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=30:
$>|> unexpected end of input
$>|> expecting Upon

preambleParamText:[Upon]> IN: <EMPTY>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=30:
preambleParamText:[Upon]> unexpected end of input
preambleParamText:[Upon]> expecting Upon or any token

******* / preambleBoolStructR [Unless]                                                                          :EOF:
preambleBoolStructR [Unless]> IN: <EMPTY>
preambleBoolStructR [Unless]> MATCH (EERR): <EMPTY>
preambleBoolStructR [Unless]> ERROR:
preambleBoolStructR [Unless]> offset=30:
preambleBoolStructR [Unless]> unexpected end of input
preambleBoolStructR [Unless]> expecting Unless

******* / preambleBoolStructR [When,If]                                                                         :EOF:
preambleBoolStructR [When,If]> IN: <EMPTY>
preambleBoolStructR [When,If]> MATCH (EERR): <EMPTY>
preambleBoolStructR [When,If]> ERROR:
preambleBoolStructR [When,If]> offset=30:
preambleBoolStructR [When,If]> unexpected end of input
preambleBoolStructR [When,If]> expecting If or When

******* / pTemporal/eventually                                                                                  :EOF:
pTemporal/eventually> IN: <EMPTY>
pTemporal/eventually> MATCH (EERR): <EMPTY>
pTemporal/eventually> ERROR:
pTemporal/eventually> offset=30:
pTemporal/eventually> unexpected end of input
pTemporal/eventually> expecting Eventually

******* / pTemporal/specifically                                                                                :EOF:
******** / $>|                                                                                                 :EOF:
$>|> IN: <EMPTY>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=30:
$>|> unexpected end of input
$>|> expecting After, Before, By, or On

pTemporal/specifically> IN: <EMPTY>
pTemporal/specifically> MATCH (EERR): <EMPTY>
pTemporal/specifically> ERROR:
pTemporal/specifically> offset=30:
pTemporal/specifically> unexpected end of input
pTemporal/specifically> expecting After, Before, By, On, or any token

******* / pTemporal/vaguely                                                                                     :EOF:
pTemporal/vaguely> IN: <EMPTY>
pTemporal/vaguely> MATCH (EERR): <EMPTY>
pTemporal/vaguely> ERROR:
pTemporal/vaguely> offset=30:
pTemporal/vaguely> unexpected end of input
pTemporal/vaguely> expecting Other text

regulative permutation with deontic-action> IN: Every GoDeeper Other "person" UnDeeper W <…>
regulative permutation with deontic-action> MATCH (COK): Every GoDeeper Other "person" UnDeeper W <…>
regulative permutation with deontic-action> VALUE: (RuleBody {rbaction = Leaf (("sharpen knives" :| [],Nothing) :| []), rbpbrs = [], rbpbrneg = [], rbdeon = DMay, rbtemporal = Nothing, rbupon = [], rbgiven = [], rbhaving = Nothing, rbkeyname = (Every,Leaf (("person" :| [],Nothing) :| [])), rbwho = Just (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), rbwhere = []},[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

****** \ regulative permutation with deontic-action has returned RuleBody {rbaction = Leaf (("sharpen knives" :| [],Nothing) :| []), rbpbrs = [], rbpbrneg = [], rbdeon = DMay, rbtemporal = Nothing, rbupon = [], rbgiven = [], rbhaving = Nothing, rbkeyname = (Every,Leaf (("person" :| [],Nothing) :| [])), rbwho = Just (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), rbwhere = []} :EOF:
permutationsReg> IN: Every GoDeeper Other "person" UnDeeper W <…>
permutationsReg> MATCH (COK): Every GoDeeper Other "person" UnDeeper W <…>
permutationsReg> VALUE: (RuleBody {rbaction = Leaf (("sharpen knives" :| [],Nothing) :| []), rbpbrs = [], rbpbrneg = [], rbdeon = DMay, rbtemporal = Nothing, rbupon = [], rbgiven = [], rbhaving = Nothing, rbkeyname = (Every,Leaf (("person" :| [],Nothing) :| [])), rbwho = Just (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), rbwhere = []},[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

***** \ permutationsReg has returned RuleBody {rbaction = Leaf (("sharpen knives" :| [],Nothing) :| []), rbpbrs = [], rbpbrneg = [], rbdeon = DMay, rbtemporal = Nothing, rbupon = [], rbgiven = [], rbhaving = Nothing, rbkeyname = (Every,Leaf (("person" :| [],Nothing) :| [])), rbwho = Just (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), rbwhere = []} :EOF:
***** / pHenceLest-Hence                                                                                          :EOF:
pHenceLest-Hence> IN: <EMPTY>
pHenceLest-Hence> MATCH (EERR): <EMPTY>
pHenceLest-Hence> ERROR:
pHenceLest-Hence> offset=30:
pHenceLest-Hence> unexpected end of input
pHenceLest-Hence> expecting Hence

***** / pHenceLest-Lest                                                                                           :EOF:
pHenceLest-Lest> IN: <EMPTY>
pHenceLest-Lest> MATCH (EERR): <EMPTY>
pHenceLest-Lest> ERROR:
pHenceLest-Lest> offset=30:
pHenceLest-Lest> unexpected end of input
pHenceLest-Lest> expecting Lest

****   pRegRuleNormal: permutations returned rulebody RuleBody {rbaction = Leaf (("sharpen knives" :| [],Nothing) :| []), rbpbrs = [], rbpbrneg = [], rbdeon = DMay, rbtemporal = Nothing, rbupon = [], rbgiven = [], rbhaving = Nothing, rbkeyname = (Every,Leaf (("person" :| [],Nothing) :| [])), rbwho = Just (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), rbwhere = []} :EOF:
****   pRegRuleNormal: the positive preamble is Nothing                                                           :EOF:
****   pRegRuleNormal: the negative preamble is Nothing                                                           :EOF:
****   pRegRuleNormal: returning Regulative {subj = Leaf (("person" :| [],Nothing) :| []), keyword = Every, who = Just (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), cond = Nothing, deontic = DMay, action = Leaf (("sharpen knives" :| [],Nothing) :| []), temporal = Nothing, hence = Nothing, lest = Nothing, rlabel = Nothing, lsource = Nothing, srcref = Nothing, upon = Nothing, given = Nothing, having = Nothing, wwhere = [], defaults = [], symtab = []} :EOF:
pRegRuleNormal> IN: Every GoDeeper Other "person" UnDeeper W <…>
pRegRuleNormal> MATCH (COK): Every GoDeeper Other "person" UnDeeper W <…>
pRegRuleNormal> VALUE: (Regulative {subj = Leaf (("person" :| [],Nothing) :| []), keyword = Every, who = Just (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), cond = Nothing, deontic = DMay, action = Leaf (("sharpen knives" :| [],Nothing) :| []), temporal = Nothing, hence = Nothing, lest = Nothing, rlabel = Nothing, lsource = Nothing, srcref = Nothing, upon = Nothing, given = Nothing, having = Nothing, wwhere = [], defaults = [], symtab = []},[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

**** \ pRegRuleNormal has returned Regulative {subj = Leaf (("person" :| [],Nothing) :| []), keyword = Every, who = Just (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), cond = Nothing, deontic = DMay, action = Leaf (("sharpen knives" :| [],Nothing) :| []), temporal = Nothing, hence = Nothing, lest = Nothing, rlabel = Nothing, lsource = Nothing, srcref = Nothing, upon = Nothing, given = Nothing, having = Nothing, wwhere = [], defaults = [], symtab = []} :EOF:
pRegRule> IN: Every GoDeeper Other "person" UnDeeper W <…>
pRegRule> MATCH (COK): Every GoDeeper Other "person" UnDeeper W <…>
pRegRule> VALUE: (Regulative {subj = Leaf (("person" :| [],Nothing) :| []), keyword = Every, who = Just (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), cond = Nothing, deontic = DMay, action = Leaf (("sharpen knives" :| [],Nothing) :| []), temporal = Nothing, hence = Nothing, lest = Nothing, rlabel = Nothing, lsource = Nothing, srcref = Nothing, upon = Nothing, given = Nothing, having = Nothing, wwhere = [], defaults = [], symtab = []},[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*** \ pRegRule has returned Regulative {subj = Leaf (("person" :| [],Nothing) :| []), keyword = Every, who = Just (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), cond = Nothing, deontic = DMay, action = Leaf (("sharpen knives" :| [],Nothing) :| []), temporal = Nothing, hence = Nothing, lest = Nothing, rlabel = Nothing, lsource = Nothing, srcref = Nothing, upon = Nothing, given = Nothing, having = Nothing, wwhere = [], defaults = [], symtab = []} :EOF:
pRule> IN: Every GoDeeper Other "person" UnDeeper W <…>
pRule> MATCH (COK): Every GoDeeper Other "person" UnDeeper W <…>
pRule> VALUE: (Regulative {subj = Leaf (("person" :| [],Nothing) :| []), keyword = Every, who = Just (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), cond = Nothing, deontic = DMay, action = Leaf (("sharpen knives" :| [],Nothing) :| []), temporal = Nothing, hence = Nothing, lest = Nothing, rlabel = Nothing, lsource = Nothing, srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 1, srccol = 1, version = Nothing}), upon = Nothing, given = Nothing, having = Nothing, wwhere = [], defaults = [], symtab = []},[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

** \ pRule has returned Regulative {subj = Leaf (("person" :| [],Nothing) :| []), keyword = Every, who = Just (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), cond = Nothing, deontic = DMay, action = Leaf (("sharpen knives" :| [],Nothing) :| []), temporal = Nothing, hence = Nothing, lest = Nothing, rlabel = Nothing, lsource = Nothing, srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 1, srccol = 1, version = Nothing}), upon = Nothing, given = Nothing, having = Nothing, wwhere = [], defaults = [], symtab = []} :EOF:
** / pRule                                                                                                           :EOF:
pRule> IN: <EMPTY>
pRule> MATCH (EERR): <EMPTY>
pRule> ERROR:
pRule> offset=30:
pRule> unexpected end of input
pRule> expecting EOL

[Every,GoDeeper,Other "person",UnDeeper,Who,GoDeeper,GoDeeper,Other "is",GoDeeper,Other "immortal",GoDeeper,Typically,GoDeeper,Other "false",UnDeeper,UnDeeper,UnDeeper,UnDeeper,Or,GoDeeper,Other "has",GoDeeper,Other "health insurance",UnDeeper,UnDeeper,UnDeeper,May,GoDeeper,Other "sharpen knives",UnDeeper]
** / pRule                                                                                                             :1_1:Every:
*** / pRegRule                                                                                                        :1_1:Every:
**** / pRuleLabel                                                                                                    :1_1:Every:
***** / $>|                                                                                                         :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting RuleMarker 1 "\167"

pRuleLabel> IN: Every GoDeeper Other "person" UnDeeper W <…>
pRuleLabel> MATCH (EERR): <EMPTY>
pRuleLabel> ERROR:
pRuleLabel> offset=0:
pRuleLabel> unexpected Every
pRuleLabel> expecting RuleMarker 1 "\167"

**** / pRegRuleSugary                                                                                                :1_1:Every:
***** / someDeep                                                                                                    :1_1:Every:
****** / someDeep first part calls base directly                                                                   :1_1:Every:
someDeep first part calls base directly> IN: Every GoDeeper Other "person" UnDeeper W <…>
someDeep first part calls base directly> MATCH (EERR): <EMPTY>
someDeep first part calls base directly> ERROR:
someDeep first part calls base directly> offset=0:
someDeep first part calls base directly> unexpected Every
someDeep first part calls base directly> expecting Other text

someDeep> IN: Every GoDeeper Other "person" UnDeeper W <…>
someDeep> MATCH (EERR): <EMPTY>
someDeep> ERROR:
someDeep> offset=0:
someDeep> unexpected Every
someDeep> expecting Other text

pRegRuleSugary> IN: Every GoDeeper Other "person" UnDeeper W <…>
pRegRuleSugary> MATCH (EERR): <EMPTY>
pRegRuleSugary> ERROR:
pRegRuleSugary> offset=0:
pRegRuleSugary> unexpected Every
pRegRuleSugary> expecting Other text

**** / pRegRuleNormal                                                                                                :1_1:Every:
***** / permutationsReg                                                                                             :1_1:Every:
****** / regulative permutation with deontic-temporal                                                              :1_1:Every:
******* / WHERE                                                                                                   :1_1:Every:
WHERE> IN: Every GoDeeper Other "person" UnDeeper W <…>
WHERE> MATCH (EERR): <EMPTY>
WHERE> ERROR:
WHERE> offset=0:
WHERE> unexpected Every
WHERE> expecting Where

******* / preambleParamText:[Having]                                                                              :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting Having

preambleParamText:[Having]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleParamText:[Having]> MATCH (EERR): <EMPTY>
preambleParamText:[Having]> ERROR:
preambleParamText:[Having]> offset=0:
preambleParamText:[Having]> unexpected Every
preambleParamText:[Having]> expecting Having

******* / preambleParamText:[Given]                                                                               :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting Given

preambleParamText:[Given]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=0:
preambleParamText:[Given]> unexpected Every
preambleParamText:[Given]> expecting Given

******* / preambleParamText:[Upon]                                                                                :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting Upon

preambleParamText:[Upon]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=0:
preambleParamText:[Upon]> unexpected Every
preambleParamText:[Upon]> expecting Upon

******* / preambleBoolStructR [Unless]                                                                            :1_1:Every:
preambleBoolStructR [Unless]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleBoolStructR [Unless]> MATCH (EERR): <EMPTY>
preambleBoolStructR [Unless]> ERROR:
preambleBoolStructR [Unless]> offset=0:
preambleBoolStructR [Unless]> unexpected Every
preambleBoolStructR [Unless]> expecting Unless

******* / preambleBoolStructR [When,If]                                                                           :1_1:Every:
preambleBoolStructR [When,If]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleBoolStructR [When,If]> MATCH (EERR): <EMPTY>
preambleBoolStructR [When,If]> ERROR:
preambleBoolStructR [When,If]> offset=0:
preambleBoolStructR [When,If]> unexpected Every
preambleBoolStructR [When,If]> expecting If or When

******* / pDT                                                                                                     :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting May, Must, or Shant

pDT> IN: Every GoDeeper Other "person" UnDeeper W <…>
pDT> MATCH (EERR): <EMPTY>
pDT> ERROR:
pDT> offset=0:
pDT> unexpected Every
pDT> expecting May, Must, or Shant

******* / pActor [Every,Party,TokAll]                                                                             :1_1:Every:
******** / someIndentation                                                                                        :1_2:GoDeeper:
********* / myindented: consuming GoDeeper                                                                       :1_2:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "person" UnDeeper Who GoD <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

********* \ myindented: consuming GoDeeper has returned GoDeeper                                                  :1_2:Other "pers:
********* / manyIndentation/leaf?                                                                                 :1_2:Other "pers:
********** / pMultiTermAka                                                                                       :1_2:Other "pers:
*********** / pAKA                                                                                              :1_2:Other "pers:
************ / slAKA                                                                                           :1_2:Other "pers:
************* / $*|                                                                                           :1_2:Other "pers:
************** / slAKA base                                                                                  :1_2:Other "pers:
*************** / slMultiTerm                                                                               :1_2:Other "pers:
**************** / someSL                                                                                  :1_2:Other "pers:
someSL> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
someSL> MATCH (COK): Other "person"
someSL> VALUE: ((["person"],0),[])

**************** \ someSL has returned (["person"],0)                                                       :2_2:UnDeeper:
slMultiTerm> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
slMultiTerm> MATCH (COK): Other "person"
slMultiTerm> VALUE: ((["person"],0),[])

*************** \ slMultiTerm has returned (["person"],0)                                                    :2_2:UnDeeper:
slAKA base> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
slAKA base> MATCH (COK): Other "person"
slAKA base> VALUE: ((["person"],0),[])

************** \ slAKA base has returned (["person"],0)                                                       :2_2:UnDeeper:
$*|> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
$*|> MATCH (COK): Other "person"
$*|> VALUE: ((["person"],0),[])

************* \ $*| has returned (["person"],0)                                                                :2_2:UnDeeper:
************* / |>>/recurse                                                                                    :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************* / |>>/base                                                                                       :2_2:UnDeeper:
************** / slAKA optional akapart                                                                       :2_2:UnDeeper:
*************** / |?| optional something                                                                     :2_2:UnDeeper:
**************** / |>>/recurse                                                                              :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

**************** / |>>/base                                                                                 :2_2:UnDeeper:
***************** / PAKA/akapart                                                                           :2_2:UnDeeper:
****************** / $>|                                                                                  :2_2:UnDeeper:
******************* / Aka Token                                                                          :2_2:UnDeeper:
Aka Token> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
Aka Token> MATCH (EERR): <EMPTY>
Aka Token> ERROR:
Aka Token> offset=3:
Aka Token> unexpected UnDeeper
Aka Token> expecting Aka

$>|> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=3:
$>|> unexpected UnDeeper
$>|> expecting Aka

PAKA/akapart> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
PAKA/akapart> MATCH (EERR): <EMPTY>
PAKA/akapart> ERROR:
PAKA/akapart> offset=3:
PAKA/akapart> unexpected UnDeeper
PAKA/akapart> expecting Aka

|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=3:
|>>/base> unexpected UnDeeper
|>>/base> expecting Aka

|?| optional something> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

*************** \ |?| optional something has returned (Nothing,0)                                            :2_2:UnDeeper:
slAKA optional akapart> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
slAKA optional akapart> MATCH (EOK): <EMPTY>
slAKA optional akapart> VALUE: ((Nothing,0),[])

************** \ slAKA optional akapart has returned (Nothing,0)                                              :2_2:UnDeeper:
************** > |>>/base got Nothing                                                                         :2_2:UnDeeper:
|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************* \ |>>/base has returned (Nothing,0)                                                              :2_2:UnDeeper:
************* / |>>/recurse                                                                                    :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************* / |>>/base                                                                                       :2_2:UnDeeper:
************** / slAKA optional typically                                                                     :2_2:UnDeeper:
*************** / |?| optional something                                                                     :2_2:UnDeeper:
**************** / |>>/recurse                                                                              :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

**************** / |>>/base                                                                                 :2_2:UnDeeper:
***************** / typically                                                                              :2_2:UnDeeper:
****************** / $>|                                                                                  :2_2:UnDeeper:
$>|> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=3:
$>|> unexpected UnDeeper
$>|> expecting Typically

typically> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
typically> MATCH (EERR): <EMPTY>
typically> ERROR:
typically> offset=3:
typically> unexpected UnDeeper
typically> expecting Typically

|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=3:
|>>/base> unexpected UnDeeper
|>>/base> expecting Typically

|?| optional something> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

*************** \ |?| optional something has returned (Nothing,0)                                            :2_2:UnDeeper:
slAKA optional typically> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
slAKA optional typically> MATCH (EOK): <EMPTY>
slAKA optional typically> VALUE: ((Nothing,0),[])

************** \ slAKA optional typically has returned (Nothing,0)                                            :2_2:UnDeeper:
************** > |>>/base got Nothing                                                                         :2_2:UnDeeper:
|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************* \ |>>/base has returned (Nothing,0)                                                              :2_2:UnDeeper:
************* > slAKA: proceeding after base and entityalias are retrieved ...                                 :2_2:UnDeeper:
************* > pAKA: entityalias = Nothing                                                                    :2_2:UnDeeper:
slAKA> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
slAKA> MATCH (COK): Other "person"
slAKA> VALUE: ((["person"],0),[])

************ \ slAKA has returned (["person"],0)                                                                :2_2:UnDeeper:
************ / undeepers                                                                                        :2_2:UnDeeper:
************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers                         :2_2:UnDeeper:
************* > sameLine: success!                                                                             :2_2:UnDeeper:
undeepers> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

************ \ undeepers has returned ()                                                                        :2_2:UnDeeper:
pAKA> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
pAKA> MATCH (COK): Other "person"
pAKA> VALUE: (["person"],[])

*********** \ pAKA has returned ["person"]                                                                       :2_2:UnDeeper:
pMultiTermAka> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
pMultiTermAka> MATCH (COK): Other "person"
pMultiTermAka> VALUE: (["person"],[])

********** \ pMultiTermAka has returned ["person"]                                                                :2_2:UnDeeper:
manyIndentation/leaf?> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
manyIndentation/leaf?> MATCH (COK): Other "person"
manyIndentation/leaf?> VALUE: (["person"],[])

********* \ manyIndentation/leaf? has returned ["person"]                                                          :2_2:UnDeeper:
********* / myindented: consuming UnDeeper                                                                         :2_2:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

********* \ myindented: consuming UnDeeper has returned UnDeeper                                                :2_1:Who:
someIndentation> IN: GoDeeper Other "person" UnDeeper Who GoD <…>
someIndentation> MATCH (COK): GoDeeper Other "person" UnDeeper
someIndentation> VALUE: (["person"],[])

******** \ someIndentation has returned ["person"]                                                               :2_1:Who:
pActor [Every,Party,TokAll]> IN: Every GoDeeper Other "person" UnDeeper W <…>
pActor [Every,Party,TokAll]> MATCH (COK): Every GoDeeper Other "person" UnDeeper
pActor [Every,Party,TokAll]> VALUE: ((Every,Leaf (("person" :| [],Nothing) :| [])),[])

******* \ pActor [Every,Party,TokAll] has returned (Every,Leaf (("person" :| [],Nothing) :| []))                  :2_1:Who:
******* / manyIndentation/leaf?                                                                                   :2_1:Who:
******** / preambleBoolStructR [Who,Which,Whose]                                                                 :2_1:Who:
********* / pBSR                                                                                                 :2_2:GoDeeper:
********** / ppp inner                                                                                          :2_2:GoDeeper:
*********** / expression                                                                                       :2_2:GoDeeper:
************ / labelPrefix                                                                                    :2_2:GoDeeper:
labelPrefix> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=5:
labelPrefix> unexpected GoDeeper
labelPrefix> expecting Other text

************ / term p                                                                                         :2_2:GoDeeper:
************* / term p/1a:label directly above                                                               :2_2:GoDeeper:
************** / $*|                                                                                        :2_2:GoDeeper:
*************** / someSL                                                                                   :2_2:GoDeeper:
**************** / pNumAsText                                                                             :2_2:GoDeeper:
pNumAsText> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=5:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=5:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=5:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=5:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

************* / term p/b:label to the left of line below, with EOL                                           :2_2:GoDeeper:
************** / someSL                                                                                     :2_2:GoDeeper:
*************** / pNumAsText                                                                               :2_2:GoDeeper:
pNumAsText> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=5:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=5:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=5:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

************* / term p/notLabelTerm                                                                          :2_2:GoDeeper:
************** / term p/2:someIndentation expr p                                                            :2_2:GoDeeper:
*************** / someIndentation                                                                          :2_2:GoDeeper:
**************** / myindented: consuming GoDeeper                                                         :2_2:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

**************** \ myindented: consuming GoDeeper has returned GoDeeper                                     :2_3:GoDeeper:
**************** / manyIndentation/leaf?                                                                    :2_3:GoDeeper:
***************** / expression                                                                             :2_3:GoDeeper:
****************** / labelPrefix                                                                          :2_3:GoDeeper:
labelPrefix> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=6:
labelPrefix> unexpected GoDeeper
labelPrefix> expecting Other text

****************** / term p                                                                               :2_3:GoDeeper:
******************* / term p/1a:label directly above                                                     :2_3:GoDeeper:
******************** / $*|                                                                              :2_3:GoDeeper:
********************* / someSL                                                                         :2_3:GoDeeper:
********************** / pNumAsText                                                                   :2_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=6:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=6:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=6:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=6:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

******************* / term p/b:label to the left of line below, with EOL                                 :2_3:GoDeeper:
******************** / someSL                                                                           :2_3:GoDeeper:
********************* / pNumAsText                                                                     :2_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=6:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=6:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=6:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

******************* / term p/notLabelTerm                                                                :2_3:GoDeeper:
******************** / term p/2:someIndentation expr p                                                  :2_3:GoDeeper:
********************* / someIndentation                                                                :2_3:GoDeeper:
********************** / myindented: consuming GoDeeper                                               :2_3:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

********************** \ myindented: consuming GoDeeper has returned GoDeeper                          :2_3:Other "is":
********************** / manyIndentation/leaf?                                                         :2_3:Other "is":
*********************** / expression                                                                  :2_3:Other "is":
************************ / labelPrefix                                                               :2_3:Other "is":
labelPrefix> IN: Other "is" GoDeeper Other "immortal" GoD <…>
labelPrefix> MATCH (COK): Other "is"
labelPrefix> VALUE: ("is",[])

************************ \ labelPrefix has returned "is"                                              :2_4:GoDeeper:
************************ / term p                                                                     :2_4:GoDeeper:
************************* / term p/1a:label directly above                                           :2_4:GoDeeper:
************************** / $*|                                                                    :2_4:GoDeeper:
*************************** / someSL                                                               :2_4:GoDeeper:
**************************** / pNumAsText                                                         :2_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=8:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=8:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=8:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=8:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

************************* / term p/b:label to the left of line below, with EOL                       :2_4:GoDeeper:
************************** / someSL                                                                 :2_4:GoDeeper:
*************************** / pNumAsText                                                           :2_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=8:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=8:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=8:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

************************* / term p/notLabelTerm                                                      :2_4:GoDeeper:
************************** / term p/2:someIndentation expr p                                        :2_4:GoDeeper:
*************************** / someIndentation                                                      :2_4:GoDeeper:
**************************** / myindented: consuming GoDeeper                                     :2_4:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

**************************** \ myindented: consuming GoDeeper has returned GoDeeper                :2_4:Other "immo:
**************************** / manyIndentation/leaf?                                               :2_4:Other "immo:
***************************** / expression                                                        :2_4:Other "immo:
****************************** / labelPrefix                                                     :2_4:Other "immo:
labelPrefix> IN: Other "immortal" GoDeeper Typically GoDe <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=10:
labelPrefix> unexpected GoDeeper

****************************** / term p                                                          :2_4:Other "immo:
******************************* / term p/1a:label directly above                                :2_4:Other "immo:
******************************** / $*|                                                         :2_4:Other "immo:
********************************* / someSL                                                    :2_4:Other "immo:
********************************** / pNumAsText                                                :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

********************************* \ someSL has returned (["immortal"],0)                       :2_5:GoDeeper:
********************************* / pNumAsText                                                 :2_5:GoDeeper:
pNumAsText> IN: GoDeeper Typically GoDeeper Other "false <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (CERR): Other "immortal"
$*|> ERROR:
$*|> offset=10:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/1a:label directly above> MATCH (CERR): Other "immortal"
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=10:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

******************************* / term p/b:label to the left of line below, with EOL            :2_4:Other "immo:
******************************** / someSL                                                      :2_4:Other "immo:
********************************* / pNumAsText                                                  :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

******************************** \ someSL has returned (["immortal"],0)                         :2_5:GoDeeper:
******************************** / undeepers                                                    :2_5:GoDeeper:
********************************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers :2_5:GoDeeper:
********************************* > sameLine: success!                                         :2_5:GoDeeper:
undeepers> IN: GoDeeper Typically GoDeeper Other "false <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

******************************** \ undeepers has returned ()                                    :2_5:GoDeeper:
******************************** / matching EOL                                                 :2_5:GoDeeper:
matching EOL> IN: GoDeeper Typically GoDeeper Other "false <…>
matching EOL> MATCH (EERR): <EMPTY>
matching EOL> ERROR:
matching EOL> offset=10:
matching EOL> unexpected GoDeeper
matching EOL> expecting EOL

term p/b:label to the left of line below, with EOL> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/b:label to the left of line below, with EOL> MATCH (CERR): Other "immortal"
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=10:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting EOL

******************************* / term p/notLabelTerm                                           :2_4:Other "immo:
******************************** / term p/2:someIndentation expr p                             :2_4:Other "immo:
********************************* / someIndentation                                           :2_4:Other "immo:
********************************** / myindented: consuming GoDeeper                          :2_4:Other "immo:
myindented: consuming GoDeeper> IN: Other "immortal" GoDeeper Typically GoDe <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=9:
myindented: consuming GoDeeper> unexpected Other "immortal"
myindented: consuming GoDeeper> expecting GoDeeper

someIndentation> IN: Other "immortal" GoDeeper Typically GoDe <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=9:
someIndentation> unexpected Other "immortal"
someIndentation> expecting GoDeeper

term p/2:someIndentation expr p> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/2:someIndentation expr p> MATCH (EERR): <EMPTY>
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=9:
term p/2:someIndentation expr p> unexpected Other "immortal"
term p/2:someIndentation expr p> expecting GoDeeper

******************************** / term p/3:plain p                                            :2_4:Other "immo:
********************************* / pRelPred                                                  :2_4:Other "immo:
********************************** / slRelPred                                               :2_4:Other "immo:
*********************************** / nested simpleHorn                                     :2_4:Other "immo:
************************************ > |^|                                                 :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slMultiTerm                                       :2_4:Other "immo:
************************************** / someSL                                          :2_4:Other "immo:
*************************************** / pNumAsText                                      :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

************************************** \ someSL has returned (["immortal"],0)             :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

************************************* \ slMultiTerm has returned (["immortal"],0)          :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************ \ $*| has returned (["immortal"],0)                    :2_5:GoDeeper:
************************************ / |^| deeps                                            :2_5:GoDeeper:
|^| deeps> IN: GoDeeper Typically GoDeeper Other "false <…>
|^| deeps> MATCH (COK): GoDeeper
|^| deeps> VALUE: (([()],1),[])

************************************ \ |^| deeps has returned ([()],1)                       :2_5:Typically:
nested simpleHorn> IN: Other "immortal" GoDeeper Typically GoDe <…>
nested simpleHorn> MATCH (CERR): Other "immortal" GoDeeper
nested simpleHorn> ERROR:
nested simpleHorn> offset=11:
nested simpleHorn> unexpected Typically
nested simpleHorn> expecting GoDeeper or Means

*********************************** / RPConstraint                                          :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slMultiTerm                                       :2_4:Other "immo:
************************************** / someSL                                          :2_4:Other "immo:
*************************************** / pNumAsText                                      :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

************************************** \ someSL has returned (["immortal"],0)             :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

************************************* \ slMultiTerm has returned (["immortal"],0)          :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************ \ $*| has returned (["immortal"],0)                    :2_5:GoDeeper:
************************************ / |>| calling $>>                                      :2_5:GoDeeper:
************************************* / |>>/recurse                                        :2_5:GoDeeper:
************************************** / |>>/recurse                                       :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                          :2_5:Typically:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=11:
|>>/base> unexpected Typically
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>>/recurse> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/recurse> MATCH (CERR): GoDeeper
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

************************************* / |>>/base                                           :2_5:GoDeeper:
|>>/base> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=10:
|>>/base> unexpected GoDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: GoDeeper Typically GoDeeper Other "false <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=11:
|>| calling $>>> unexpected Typically
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPConstraint> IN: Other "immortal" GoDeeper Typically GoDe <…>
RPConstraint> MATCH (CERR): Other "immortal"
RPConstraint> ERROR:
RPConstraint> offset=11:
RPConstraint> unexpected Typically
RPConstraint> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPBoolStructR                                         :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slMultiTerm                                       :2_4:Other "immo:
************************************** / someSL                                          :2_4:Other "immo:
*************************************** / pNumAsText                                      :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

************************************** \ someSL has returned (["immortal"],0)             :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

************************************* \ slMultiTerm has returned (["immortal"],0)          :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************ \ $*| has returned (["immortal"],0)                    :2_5:GoDeeper:
************************************ / |>| calling $>>                                      :2_5:GoDeeper:
************************************* / |>>/recurse                                        :2_5:GoDeeper:
************************************** / |>>/recurse                                       :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                          :2_5:Typically:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=11:
|>>/base> unexpected Typically
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>>/recurse> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/recurse> MATCH (CERR): GoDeeper
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

************************************* / |>>/base                                           :2_5:GoDeeper:
|>>/base> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=10:
|>>/base> unexpected GoDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: GoDeeper Typically GoDeeper Other "false <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=11:
|>| calling $>>> unexpected Typically
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPBoolStructR> IN: Other "immortal" GoDeeper Typically GoDe <…>
RPBoolStructR> MATCH (CERR): Other "immortal"
RPBoolStructR> ERROR:
RPBoolStructR> offset=11:
RPBoolStructR> unexpected Typically
RPBoolStructR> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPMT                                                  :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slAKA                                             :2_4:Other "immo:
************************************** / $*|                                             :2_4:Other "immo:
*************************************** / slAKA base                                    :2_4:Other "immo:
**************************************** / slMultiTerm                                 :2_4:Other "immo:
***************************************** / someSL                                    :2_4:Other "immo:
****************************************** / pNumAsText                                :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

***************************************** \ someSL has returned (["immortal"],0)       :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

**************************************** \ slMultiTerm has returned (["immortal"],0)    :2_5:GoDeeper:
slAKA base> IN: Other "immortal" GoDeeper Typically GoDe <…>
slAKA base> MATCH (COK): Other "immortal"
slAKA base> VALUE: ((["immortal"],0),[])

*************************************** \ slAKA base has returned (["immortal"],0)       :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************** \ $*| has returned (["immortal"],0)                :2_5:GoDeeper:
************************************** / |>>/recurse                                      :2_5:GoDeeper:
*************************************** / |>>/recurse                                     :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

*************************************** / |>>/base                                        :2_5:Typically:
**************************************** / slAKA optional akapart                        :2_5:Typically:
***************************************** / |?| optional something                      :2_5:Typically:
****************************************** / |>>/recurse                               :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

****************************************** / |>>/base                                  :2_5:Typically:
******************************************* / PAKA/akapart                            :2_5:Typically:
******************************************** / $>|                                   :2_5:Typically:
********************************************* / Aka Token                           :2_5:Typically:
Aka Token> IN: Typically GoDeeper Other "false" UnDeepe <…>
Aka Token> MATCH (EERR): <EMPTY>
Aka Token> ERROR:
Aka Token> offset=11:
Aka Token> unexpected Typically
Aka Token> expecting Aka

$>|> IN: Typically GoDeeper Other "false" UnDeepe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=11:
$>|> unexpected Typically
$>|> expecting Aka

PAKA/akapart> IN: Typically GoDeeper Other "false" UnDeepe <…>
PAKA/akapart> MATCH (EERR): <EMPTY>
PAKA/akapart> ERROR:
PAKA/akapart> offset=11:
PAKA/akapart> unexpected Typically
PAKA/akapart> expecting Aka

|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=11:
|>>/base> unexpected Typically
|>>/base> expecting Aka

|?| optional something> IN: Typically GoDeeper Other "false" UnDeepe <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

***************************************** \ |?| optional something has returned (Nothing,0) :2_5:Typically:
slAKA optional akapart> IN: Typically GoDeeper Other "false" UnDeepe <…>
slAKA optional akapart> MATCH (EOK): <EMPTY>
slAKA optional akapart> VALUE: ((Nothing,0),[])

**************************************** \ slAKA optional akapart has returned (Nothing,0) :2_5:Typically:
**************************************** > |>>/base got Nothing                          :2_5:Typically:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

*************************************** \ |>>/base has returned (Nothing,0)               :2_5:Typically:
|>>/recurse> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/recurse> MATCH (COK): GoDeeper
|>>/recurse> VALUE: ((Nothing,1),[])

************************************** \ |>>/recurse has returned (Nothing,1)              :2_5:Typically:
************************************** / |>>/recurse                                       :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                          :2_5:Typically:
*************************************** / slAKA optional typically                        :2_5:Typically:
**************************************** / |?| optional something                        :2_5:Typically:
***************************************** / |>>/recurse                                 :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

***************************************** / |>>/base                                    :2_5:Typically:
****************************************** / typically                                 :2_5:Typically:
******************************************* / $>|                                     :2_5:Typically:
$>|> IN: Typically GoDeeper Other "false" UnDeepe <…>
$>|> MATCH (COK): Typically
$>|> VALUE: (Typically,[])

******************************************* \ $>| has returned Typically               :2_6:GoDeeper:
******************************************* / |>>/recurse                              :2_6:GoDeeper:
******************************************** / |>>/recurse                             :2_6:Other "fals:
|>>/recurse> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=13:
|>>/recurse> unexpected Other "false"
|>>/recurse> expecting GoDeeper

******************************************** / |>>/base                                :2_6:Other "fals:
********************************************* / slMultiTerm                           :2_6:Other "fals:
********************************************** / someSL                              :2_6:Other "fals:
someSL> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
someSL> MATCH (COK): Other "false"
someSL> VALUE: ((["false"],0),[])

********************************************** \ someSL has returned (["false"],0) :3_3:UnDeeper:
slMultiTerm> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
slMultiTerm> MATCH (COK): Other "false"
slMultiTerm> VALUE: ((["false"],0),[])

********************************************* \ slMultiTerm has returned (["false"],0) :3_3:UnDeeper:
********************************************* > |>>/base got ["false"]           :3_3:UnDeeper:
|>>/base> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
|>>/base> MATCH (COK): Other "false"
|>>/base> VALUE: ((["false"],0),[])

******************************************** \ |>>/base has returned (["false"],0) :3_3:UnDeeper:
|>>/recurse> IN: GoDeeper Other "false" UnDeeper UnDeeper <…>
|>>/recurse> MATCH (COK): GoDeeper Other "false"
|>>/recurse> VALUE: ((["false"],1),[])

******************************************* \ |>>/recurse has returned (["false"],1) :3_3:UnDeeper:
typically> IN: Typically GoDeeper Other "false" UnDeepe <…>
typically> MATCH (COK): Typically GoDeeper Other "false"
typically> VALUE: ((["false"],1),[])

****************************************** \ typically has returned (["false"],1)   :3_3:UnDeeper:
****************************************** > |>>/base got ["false"]                 :3_3:UnDeeper:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (COK): Typically GoDeeper Other "false"
|>>/base> VALUE: ((["false"],1),[])

***************************************** \ |>>/base has returned (["false"],1)      :3_3:UnDeeper:
|?| optional something> IN: Typically GoDeeper Other "false" UnDeepe <…>
|?| optional something> MATCH (COK): Typically GoDeeper Other "false"
|?| optional something> VALUE: ((Just ["false"],1),[])

**************************************** \ |?| optional something has returned (Just ["false"],1) :3_3:UnDeeper:
slAKA optional typically> IN: Typically GoDeeper Other "false" UnDeepe <…>
slAKA optional typically> MATCH (COK): Typically GoDeeper Other "false"
slAKA optional typically> VALUE: ((Just ["false"],1),[])

*************************************** \ slAKA optional typically has returned (Just ["false"],1) :3_3:UnDeeper:
*************************************** > |>>/base got Just ["false"]                  :3_3:UnDeeper:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (COK): Typically GoDeeper Other "false"
|>>/base> VALUE: ((Just ["false"],1),[])

************************************** \ |>>/base has returned (Just ["false"],1)       :3_3:UnDeeper:
************************************** > slAKA: proceeding after base and entityalias are retrieved ... :3_3:UnDeeper:
************************************** > pAKA: entityalias = Nothing                    :3_3:UnDeeper:
slAKA> IN: Other "immortal" GoDeeper Typically GoDe <…>
slAKA> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
slAKA> VALUE: ((["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************************* \ slAKA has returned (["immortal"],2)              :3_3:UnDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
$*|> VALUE: ((["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************************ \ $*| has returned (["immortal"],2)                  :3_3:UnDeeper:
RPMT> IN: Other "immortal" GoDeeper Typically GoDe <…>
RPMT> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
RPMT> VALUE: ((RPMT ["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*********************************** \ RPMT has returned (RPMT ["immortal"],2)              :3_3:UnDeeper:
slRelPred> IN: Other "immortal" GoDeeper Typically GoDe <…>
slRelPred> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
slRelPred> VALUE: ((RPMT ["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************************** \ slRelPred has returned (RPMT ["immortal"],2)           :3_3:UnDeeper:
********************************** / undeepers                                              :3_3:UnDeeper:
*********************************** > sameLine/undeepers: reached end of line; now need to clear 2 UnDeepers :3_3:UnDeeper:
*********************************** > sameLine: success!                                       :3_5:UnDeeper:
undeepers> IN: UnDeeper UnDeeper UnDeeper UnDeeper Or G <…>
undeepers> MATCH (COK): UnDeeper UnDeeper
undeepers> VALUE: ((),[])

********************************** \ undeepers has returned ()                                  :3_5:UnDeeper:
pRelPred> IN: Other "immortal" GoDeeper Typically GoDe <…>
pRelPred> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
pRelPred> VALUE: (RPMT ["immortal"],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************************* \ pRelPred has returned RPMT ["immortal"]                      :3_5:UnDeeper:
term p/3:plain p> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/3:plain p> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
term p/3:plain p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************************** \ term p/3:plain p has returned MyLeaf (RPMT ["immortal"])       :3_5:UnDeeper:
term p/notLabelTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/notLabelTerm> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["immortal"])      :3_5:UnDeeper:
term p> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
term p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

****************************** \ term p has returned MyLeaf (RPMT ["immortal"])                     :3_5:UnDeeper:
****************************** / binary(Or)                                                         :3_5:UnDeeper:
binary(Or)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=16:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

****************************** / binary(And)                                                        :3_5:UnDeeper:
binary(And)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=16:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

****************************** / binary(SetLess)                                                    :3_5:UnDeeper:
binary(SetLess)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=16:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

****************************** / binary(SetPlus)                                                    :3_5:UnDeeper:
binary(SetPlus)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=16:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "immortal" GoDeeper Typically GoDe <…>
expression> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
expression> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

***************************** \ expression has returned MyLeaf (RPMT ["immortal"])                   :3_5:UnDeeper:
manyIndentation/leaf?> IN: Other "immortal" GoDeeper Typically GoDe <…>
manyIndentation/leaf?> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
manyIndentation/leaf?> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

**************************** \ manyIndentation/leaf? has returned MyLeaf (RPMT ["immortal"])          :3_5:UnDeeper:
**************************** / myindented: consuming UnDeeper                                         :3_5:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

**************************** \ myindented: consuming UnDeeper has returned UnDeeper                     :3_6:UnDeeper:
someIndentation> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
someIndentation> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
someIndentation> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*************************** \ someIndentation has returned MyLeaf (RPMT ["immortal"])                    :3_6:UnDeeper:
term p/2:someIndentation expr p> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
term p/2:someIndentation expr p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************** \ term p/2:someIndentation expr p has returned MyLeaf (RPMT ["immortal"])      :3_6:UnDeeper:
term p/notLabelTerm> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["immortal"])                    :3_6:UnDeeper:
term p> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
term p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************ \ term p has returned MyLeaf (RPMT ["immortal"])                                   :3_6:UnDeeper:
************************ / binary(Or)                                                                       :3_6:UnDeeper:
binary(Or)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=17:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

************************ / binary(And)                                                                      :3_6:UnDeeper:
binary(And)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=17:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

************************ / binary(SetLess)                                                                  :3_6:UnDeeper:
binary(SetLess)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=17:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

************************ / binary(SetPlus)                                                                  :3_6:UnDeeper:
binary(SetPlus)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=17:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "is" GoDeeper Other "immortal" GoD <…>
expression> MATCH (COK): Other "is" GoDeeper Other "immortal" GoD <…>
expression> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*********************** \ expression has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))                :3_6:UnDeeper:
manyIndentation/leaf?> IN: Other "is" GoDeeper Other "immortal" GoD <…>
manyIndentation/leaf?> MATCH (COK): Other "is" GoDeeper Other "immortal" GoD <…>
manyIndentation/leaf?> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************** \ manyIndentation/leaf? has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))       :3_6:UnDeeper:
********************** / myindented: consuming UnDeeper                                                       :3_6:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

********************** \ myindented: consuming UnDeeper has returned UnDeeper                        :3_2:Or:
someIndentation> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
someIndentation> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
someIndentation> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************* \ someIndentation has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))      :3_2:Or:
term p/2:someIndentation expr p> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
term p/2:someIndentation expr p> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************** \ term p/2:someIndentation expr p has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"])) :3_2:Or:
term p/notLabelTerm> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
term p/notLabelTerm> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************* \ term p/notLabelTerm has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))      :3_2:Or:
term p> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
term p> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

****************** \ term p has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))                     :3_2:Or:
****************** / binary(Or)                                                                          :3_2:Or:
binary(Or)> IN: Or GoDeeper Other "has" GoDeeper Other " <…>
binary(Or)> MATCH (COK): Or
binary(Or)> VALUE: (Or,[])

****************** \ binary(Or) has returned Or                                                           :3_3:GoDeeper:
****************** / term p                                                                               :3_3:GoDeeper:
******************* / term p/1a:label directly above                                                     :3_3:GoDeeper:
******************** / $*|                                                                              :3_3:GoDeeper:
********************* / someSL                                                                         :3_3:GoDeeper:
********************** / pNumAsText                                                                   :3_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=19:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=19:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=19:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=19:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

******************* / term p/b:label to the left of line below, with EOL                                 :3_3:GoDeeper:
******************** / someSL                                                                           :3_3:GoDeeper:
********************* / pNumAsText                                                                     :3_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=19:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=19:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=19:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

******************* / term p/notLabelTerm                                                                :3_3:GoDeeper:
******************** / term p/2:someIndentation expr p                                                  :3_3:GoDeeper:
********************* / someIndentation                                                                :3_3:GoDeeper:
********************** / myindented: consuming GoDeeper                                               :3_3:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

********************** \ myindented: consuming GoDeeper has returned GoDeeper                          :3_3:Other "has":
********************** / manyIndentation/leaf?                                                         :3_3:Other "has":
*********************** / expression                                                                  :3_3:Other "has":
************************ / labelPrefix                                                               :3_3:Other "has":
labelPrefix> IN: Other "has" GoDeeper Other "health insur <…>
labelPrefix> MATCH (COK): Other "has"
labelPrefix> VALUE: ("has",[])

************************ \ labelPrefix has returned "has"                                             :3_4:GoDeeper:
************************ / term p                                                                     :3_4:GoDeeper:
************************* / term p/1a:label directly above                                           :3_4:GoDeeper:
************************** / $*|                                                                    :3_4:GoDeeper:
*************************** / someSL                                                               :3_4:GoDeeper:
**************************** / pNumAsText                                                         :3_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "health insurance" UnDeep <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=21:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "health insurance" UnDeep <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=21:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "health insurance" UnDeep <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=21:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=21:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

************************* / term p/b:label to the left of line below, with EOL                       :3_4:GoDeeper:
************************** / someSL                                                                 :3_4:GoDeeper:
*************************** / pNumAsText                                                           :3_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "health insurance" UnDeep <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=21:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "health insurance" UnDeep <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=21:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=21:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

************************* / term p/notLabelTerm                                                      :3_4:GoDeeper:
************************** / term p/2:someIndentation expr p                                        :3_4:GoDeeper:
*************************** / someIndentation                                                      :3_4:GoDeeper:
**************************** / myindented: consuming GoDeeper                                     :3_4:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "health insurance" UnDeep <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

**************************** \ myindented: consuming GoDeeper has returned GoDeeper                :3_4:Other "heal:
**************************** / manyIndentation/leaf?                                               :3_4:Other "heal:
***************************** / expression                                                        :3_4:Other "heal:
****************************** / labelPrefix                                                     :3_4:Other "heal:
labelPrefix> IN: Other "health insurance" UnDeeper UnDeep <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=23:
labelPrefix> unexpected UnDeeper

****************************** / term p                                                          :3_4:Other "heal:
******************************* / term p/1a:label directly above                                :3_4:Other "heal:
******************************** / $*|                                                         :3_4:Other "heal:
********************************* / someSL                                                    :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

********************************* \ someSL has returned (["health insurance"],0)           :4_2:UnDeeper:
********************************* / pNumAsText                                             :4_2:UnDeeper:
pNumAsText> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=23:
pNumAsText> unexpected UnDeeper
pNumAsText> expecting number

$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (CERR): Other "health insurance"
$*|> ERROR:
$*|> offset=23:
$*|> unexpected UnDeeper
$*|> expecting GoDeeper or other text or number

term p/1a:label directly above> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/1a:label directly above> MATCH (CERR): Other "health insurance"
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=23:
term p/1a:label directly above> unexpected UnDeeper
term p/1a:label directly above> expecting GoDeeper or other text or number

******************************* / term p/b:label to the left of line below, with EOL            :3_4:Other "heal:
******************************** / someSL                                                      :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

******************************** \ someSL has returned (["health insurance"],0)             :4_2:UnDeeper:
******************************** / undeepers                                                :4_2:UnDeeper:
********************************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers :4_2:UnDeeper:
********************************* > sameLine: success!                                     :4_2:UnDeeper:
undeepers> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

******************************** \ undeepers has returned ()                                :4_2:UnDeeper:
******************************** / matching EOL                                             :4_2:UnDeeper:
matching EOL> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
matching EOL> MATCH (EERR): <EMPTY>
matching EOL> ERROR:
matching EOL> offset=23:
matching EOL> unexpected UnDeeper
matching EOL> expecting EOL

term p/b:label to the left of line below, with EOL> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/b:label to the left of line below, with EOL> MATCH (CERR): Other "health insurance"
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=23:
term p/b:label to the left of line below, with EOL> unexpected UnDeeper
term p/b:label to the left of line below, with EOL> expecting EOL or GoDeeper

******************************* / term p/notLabelTerm                                           :3_4:Other "heal:
******************************** / term p/2:someIndentation expr p                             :3_4:Other "heal:
********************************* / someIndentation                                           :3_4:Other "heal:
********************************** / myindented: consuming GoDeeper                          :3_4:Other "heal:
myindented: consuming GoDeeper> IN: Other "health insurance" UnDeeper UnDeep <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=22:
myindented: consuming GoDeeper> unexpected Other "health insurance"
myindented: consuming GoDeeper> expecting GoDeeper

someIndentation> IN: Other "health insurance" UnDeeper UnDeep <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=22:
someIndentation> unexpected Other "health insurance"
someIndentation> expecting GoDeeper

term p/2:someIndentation expr p> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/2:someIndentation expr p> MATCH (EERR): <EMPTY>
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=22:
term p/2:someIndentation expr p> unexpected Other "health insurance"
term p/2:someIndentation expr p> expecting GoDeeper

******************************** / term p/3:plain p                                            :3_4:Other "heal:
********************************* / pRelPred                                                  :3_4:Other "heal:
********************************** / slRelPred                                               :3_4:Other "heal:
*********************************** / nested simpleHorn                                     :3_4:Other "heal:
************************************ > |^|                                                 :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slMultiTerm                                       :3_4:Other "heal:
************************************** / someSL                                          :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

************************************* \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
************************************ / |^| deeps                                        :4_2:UnDeeper:
|^| deeps> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|^| deeps> MATCH (COK): UnDeeper UnDeeper UnDeeper
|^| deeps> VALUE: (([(),(),()],-3),[])

************************************ \ |^| deeps has returned ([(),(),()],-3)        :4_1:May:
nested simpleHorn> IN: Other "health insurance" UnDeeper UnDeep <…>
nested simpleHorn> MATCH (CERR): Other "health insurance" UnDeeper UnDeep <…>
nested simpleHorn> ERROR:
nested simpleHorn> offset=26:
nested simpleHorn> unexpected May
nested simpleHorn> expecting Means or UnDeeper

*********************************** / RPConstraint                                          :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slMultiTerm                                       :3_4:Other "heal:
************************************** / someSL                                          :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

************************************* \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
************************************ / |>| calling $>>                                  :4_2:UnDeeper:
************************************* / |>>/recurse                                    :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************* / |>>/base                                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=23:
|>| calling $>>> unexpected UnDeeper
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPConstraint> IN: Other "health insurance" UnDeeper UnDeep <…>
RPConstraint> MATCH (CERR): Other "health insurance"
RPConstraint> ERROR:
RPConstraint> offset=23:
RPConstraint> unexpected UnDeeper
RPConstraint> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPBoolStructR                                         :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slMultiTerm                                       :3_4:Other "heal:
************************************** / someSL                                          :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

************************************* \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
************************************ / |>| calling $>>                                  :4_2:UnDeeper:
************************************* / |>>/recurse                                    :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************* / |>>/base                                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=23:
|>| calling $>>> unexpected UnDeeper
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPBoolStructR> IN: Other "health insurance" UnDeeper UnDeep <…>
RPBoolStructR> MATCH (CERR): Other "health insurance"
RPBoolStructR> ERROR:
RPBoolStructR> offset=23:
RPBoolStructR> unexpected UnDeeper
RPBoolStructR> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPMT                                                  :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slAKA                                             :3_4:Other "heal:
************************************** / $*|                                             :3_4:Other "heal:
*************************************** / slAKA base                                    :3_4:Other "heal:
**************************************** / slMultiTerm                                 :3_4:Other "heal:
***************************************** / someSL                                    :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

***************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

**************************************** \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
slAKA base> IN: Other "health insurance" UnDeeper UnDeep <…>
slAKA base> MATCH (COK): Other "health insurance"
slAKA base> VALUE: ((["health insurance"],0),[])

*************************************** \ slAKA base has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************** \ $*| has returned (["health insurance"],0)    :4_2:UnDeeper:
************************************** / |>>/recurse                                  :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                     :4_2:UnDeeper:
*************************************** / slAKA optional akapart                     :4_2:UnDeeper:
**************************************** / |?| optional something                   :4_2:UnDeeper:
***************************************** / |>>/recurse                            :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

***************************************** / |>>/base                               :4_2:UnDeeper:
****************************************** / PAKA/akapart                         :4_2:UnDeeper:
******************************************* / $>|                                :4_2:UnDeeper:
******************************************** / Aka Token                        :4_2:UnDeeper:
Aka Token> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
Aka Token> MATCH (EERR): <EMPTY>
Aka Token> ERROR:
Aka Token> offset=23:
Aka Token> unexpected UnDeeper
Aka Token> expecting Aka

$>|> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=23:
$>|> unexpected UnDeeper
$>|> expecting Aka

PAKA/akapart> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
PAKA/akapart> MATCH (EERR): <EMPTY>
PAKA/akapart> ERROR:
PAKA/akapart> offset=23:
PAKA/akapart> unexpected UnDeeper
PAKA/akapart> expecting Aka

|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Aka

|?| optional something> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

**************************************** \ |?| optional something has returned (Nothing,0) :4_2:UnDeeper:
slAKA optional akapart> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
slAKA optional akapart> MATCH (EOK): <EMPTY>
slAKA optional akapart> VALUE: ((Nothing,0),[])

*************************************** \ slAKA optional akapart has returned (Nothing,0) :4_2:UnDeeper:
*************************************** > |>>/base got Nothing                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************************************** \ |>>/base has returned (Nothing,0)            :4_2:UnDeeper:
************************************** / |>>/recurse                                  :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                     :4_2:UnDeeper:
*************************************** / slAKA optional typically                   :4_2:UnDeeper:
**************************************** / |?| optional something                   :4_2:UnDeeper:
***************************************** / |>>/recurse                            :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

***************************************** / |>>/base                               :4_2:UnDeeper:
****************************************** / typically                            :4_2:UnDeeper:
******************************************* / $>|                                :4_2:UnDeeper:
$>|> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=23:
$>|> unexpected UnDeeper
$>|> expecting Typically

typically> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
typically> MATCH (EERR): <EMPTY>
typically> ERROR:
typically> offset=23:
typically> unexpected UnDeeper
typically> expecting Typically

|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Typically

|?| optional something> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

**************************************** \ |?| optional something has returned (Nothing,0) :4_2:UnDeeper:
slAKA optional typically> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
slAKA optional typically> MATCH (EOK): <EMPTY>
slAKA optional typically> VALUE: ((Nothing,0),[])

*************************************** \ slAKA optional typically has returned (Nothing,0) :4_2:UnDeeper:
*************************************** > |>>/base got Nothing                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************************************** \ |>>/base has returned (Nothing,0)            :4_2:UnDeeper:
************************************** > slAKA: proceeding after base and entityalias are retrieved ... :4_2:UnDeeper:
************************************** > pAKA: entityalias = Nothing                  :4_2:UnDeeper:
slAKA> IN: Other "health insurance" UnDeeper UnDeep <…>
slAKA> MATCH (COK): Other "health insurance"
slAKA> VALUE: ((["health insurance"],0),[])

************************************* \ slAKA has returned (["health insurance"],0)    :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
RPMT> IN: Other "health insurance" UnDeeper UnDeep <…>
RPMT> MATCH (COK): Other "health insurance"
RPMT> VALUE: ((RPMT ["health insurance"],0),[])

*********************************** \ RPMT has returned (RPMT ["health insurance"],0)    :4_2:UnDeeper:
slRelPred> IN: Other "health insurance" UnDeeper UnDeep <…>
slRelPred> MATCH (COK): Other "health insurance"
slRelPred> VALUE: ((RPMT ["health insurance"],0),[])

********************************** \ slRelPred has returned (RPMT ["health insurance"],0) :4_2:UnDeeper:
********************************** / undeepers                                            :4_2:UnDeeper:
*********************************** > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers :4_2:UnDeeper:
*********************************** > sameLine: success!                                 :4_2:UnDeeper:
undeepers> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

********************************** \ undeepers has returned ()                            :4_2:UnDeeper:
pRelPred> IN: Other "health insurance" UnDeeper UnDeep <…>
pRelPred> MATCH (COK): Other "health insurance"
pRelPred> VALUE: (RPMT ["health insurance"],[])

********************************* \ pRelPred has returned RPMT ["health insurance"]        :4_2:UnDeeper:
term p/3:plain p> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/3:plain p> MATCH (COK): Other "health insurance"
term p/3:plain p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

******************************** \ term p/3:plain p has returned MyLeaf (RPMT ["health insurance"]) :4_2:UnDeeper:
term p/notLabelTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/notLabelTerm> MATCH (COK): Other "health insurance"
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

******************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["health insurance"]) :4_2:UnDeeper:
term p> IN: Other "health insurance" UnDeeper UnDeep <…>
term p> MATCH (COK): Other "health insurance"
term p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

****************************** \ term p has returned MyLeaf (RPMT ["health insurance"])       :4_2:UnDeeper:
****************************** / binary(Or)                                                   :4_2:UnDeeper:
binary(Or)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=23:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

****************************** / binary(And)                                                  :4_2:UnDeeper:
binary(And)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=23:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

****************************** / binary(SetLess)                                              :4_2:UnDeeper:
binary(SetLess)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=23:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

****************************** / binary(SetPlus)                                              :4_2:UnDeeper:
binary(SetPlus)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=23:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "health insurance" UnDeeper UnDeep <…>
expression> MATCH (COK): Other "health insurance"
expression> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

***************************** \ expression has returned MyLeaf (RPMT ["health insurance"])     :4_2:UnDeeper:
manyIndentation/leaf?> IN: Other "health insurance" UnDeeper UnDeep <…>
manyIndentation/leaf?> MATCH (COK): Other "health insurance"
manyIndentation/leaf?> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

**************************** \ manyIndentation/leaf? has returned MyLeaf (RPMT ["health insurance"]) :4_2:UnDeeper:
**************************** / myindented: consuming UnDeeper                                   :4_2:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

**************************** \ myindented: consuming UnDeeper has returned UnDeeper               :4_3:UnDeeper:
someIndentation> IN: GoDeeper Other "health insurance" UnDeep <…>
someIndentation> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
someIndentation> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

*************************** \ someIndentation has returned MyLeaf (RPMT ["health insurance"])      :4_3:UnDeeper:
term p/2:someIndentation expr p> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
term p/2:someIndentation expr p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

************************** \ term p/2:someIndentation expr p has returned MyLeaf (RPMT ["health insurance"]) :4_3:UnDeeper:
term p/notLabelTerm> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["health insurance"])      :4_3:UnDeeper:
term p> IN: GoDeeper Other "health insurance" UnDeep <…>
term p> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
term p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

************************ \ term p has returned MyLeaf (RPMT ["health insurance"])                     :4_3:UnDeeper:
************************ / binary(Or)                                                                 :4_3:UnDeeper:
binary(Or)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=24:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

************************ / binary(And)                                                                :4_3:UnDeeper:
binary(And)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=24:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

************************ / binary(SetLess)                                                            :4_3:UnDeeper:
binary(SetLess)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=24:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

************************ / binary(SetPlus)                                                            :4_3:UnDeeper:
binary(SetPlus)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=24:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "has" GoDeeper Other "health insur <…>
expression> MATCH (COK): Other "has" GoDeeper Other "health insur <…>
expression> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

*********************** \ expression has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])) :4_3:UnDeeper:
manyIndentation/leaf?> IN: Other "has" GoDeeper Other "health insur <…>
manyIndentation/leaf?> MATCH (COK): Other "has" GoDeeper Other "health insur <…>
manyIndentation/leaf?> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

********************** \ manyIndentation/leaf? has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])) :4_3:UnDeeper:
********************** / myindented: consuming UnDeeper                                                 :4_3:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

********************** \ myindented: consuming UnDeeper has returned UnDeeper                             :4_4:UnDeeper:
someIndentation> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
someIndentation> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
someIndentation> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

********************* \ someIndentation has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))  :4_4:UnDeeper:
term p/2:someIndentation expr p> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
term p/2:someIndentation expr p> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

******************** \ term p/2:someIndentation expr p has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])) :4_4:UnDeeper:
term p/notLabelTerm> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
term p/notLabelTerm> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

******************* \ term p/notLabelTerm has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))  :4_4:UnDeeper:
term p> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
term p> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

****************** \ term p has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))                 :4_4:UnDeeper:
****************** / binary(Or)                                                                               :4_4:UnDeeper:
binary(Or)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=25:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

****************** / binary(And)                                                                              :4_4:UnDeeper:
binary(And)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=25:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

****************** / binary(SetLess)                                                                          :4_4:UnDeeper:
binary(SetLess)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=25:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

****************** / binary(SetPlus)                                                                          :4_4:UnDeeper:
binary(SetPlus)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=25:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
expression> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
expression> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

***************** \ expression has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_4:UnDeeper:
manyIndentation/leaf?> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
manyIndentation/leaf?> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
manyIndentation/leaf?> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

**************** \ manyIndentation/leaf? has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_4:UnDeeper:
**************** / myindented: consuming UnDeeper                                                               :4_4:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

**************** \ myindented: consuming UnDeeper has returned UnDeeper                                  :4_1:May:
someIndentation> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someIndentation> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someIndentation> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*************** \ someIndentation has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
term p/2:someIndentation expr p> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/2:someIndentation expr p> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************** \ term p/2:someIndentation expr p has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
term p/notLabelTerm> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/notLabelTerm> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/notLabelTerm> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************* \ term p/notLabelTerm has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
term p> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************ \ term p has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
************ / binary(Or)                                                                                    :4_1:May:
binary(Or)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=26:
binary(Or)> unexpected May
binary(Or)> expecting Or

************ / binary(And)                                                                                   :4_1:May:
binary(And)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=26:
binary(And)> unexpected May
binary(And)> expecting And

************ / binary(SetLess)                                                                               :4_1:May:
binary(SetLess)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=26:
binary(SetLess)> unexpected May
binary(SetLess)> expecting SetLess

************ / binary(SetPlus)                                                                               :4_1:May:
binary(SetPlus)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=26:
binary(SetPlus)> unexpected May
binary(SetPlus)> expecting SetPlus

expression> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
expression> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
expression> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*********** \ expression has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
ppp inner> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
ppp inner> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
ppp inner> VALUE: (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********** \ ppp inner has returned Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])] :4_1:May:
pBSR> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pBSR> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pBSR> VALUE: (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********* \ pBSR has returned Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])] :4_1:May:
preambleBoolStructR [Who,Which,Whose]> IN: Who GoDeeper GoDeeper Other "is" GoDeepe <…>
preambleBoolStructR [Who,Which,Whose]> MATCH (COK): Who GoDeeper GoDeeper Other "is" GoDeepe <…>
preambleBoolStructR [Who,Which,Whose]> VALUE: ((Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******** \ preambleBoolStructR [Who,Which,Whose] has returned (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]) :4_1:May:
manyIndentation/leaf?> IN: Who GoDeeper GoDeeper Other "is" GoDeepe <…>
manyIndentation/leaf?> MATCH (COK): Who GoDeeper GoDeeper Other "is" GoDeepe <…>
manyIndentation/leaf?> VALUE: ((Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******* \ manyIndentation/leaf? has returned (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]) :4_1:May:
******* / WHERE                                                                                                   :4_1:May:
WHERE> IN: May GoDeeper Other "sharpen knives" UnDe <…>
WHERE> MATCH (EERR): <EMPTY>
WHERE> ERROR:
WHERE> offset=26:
WHERE> unexpected May
WHERE> expecting Where

******* / preambleParamText:[Having]                                                                              :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=26:
$>|> unexpected May
$>|> expecting Having

preambleParamText:[Having]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleParamText:[Having]> MATCH (EERR): <EMPTY>
preambleParamText:[Having]> ERROR:
preambleParamText:[Having]> offset=26:
preambleParamText:[Having]> unexpected May
preambleParamText:[Having]> expecting Having

******* / preambleParamText:[Given]                                                                               :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=26:
$>|> unexpected May
$>|> expecting Given

preambleParamText:[Given]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=26:
preambleParamText:[Given]> unexpected May
preambleParamText:[Given]> expecting Given

******* / preambleParamText:[Upon]                                                                                :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=26:
$>|> unexpected May
$>|> expecting Upon

preambleParamText:[Upon]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=26:
preambleParamText:[Upon]> unexpected May
preambleParamText:[Upon]> expecting Upon

******* / preambleBoolStructR [Unless]                                                                            :4_1:May:
preambleBoolStructR [Unless]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleBoolStructR [Unless]> MATCH (EERR): <EMPTY>
preambleBoolStructR [Unless]> ERROR:
preambleBoolStructR [Unless]> offset=26:
preambleBoolStructR [Unless]> unexpected May
preambleBoolStructR [Unless]> expecting Unless

******* / preambleBoolStructR [When,If]                                                                           :4_1:May:
preambleBoolStructR [When,If]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleBoolStructR [When,If]> MATCH (EERR): <EMPTY>
preambleBoolStructR [When,If]> ERROR:
preambleBoolStructR [When,If]> offset=26:
preambleBoolStructR [When,If]> unexpected May
preambleBoolStructR [When,If]> expecting If or When

******* / pDT                                                                                                     :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (COK): May
$>|> VALUE: (DMay,[])

******** \ $>| has returned DMay                                                                                  :4_2:GoDeeper:
******** / |>| calling $>>                                                                                        :4_2:GoDeeper:
********* / |>>/recurse                                                                                          :4_2:GoDeeper:
********** / |>>/recurse                                                                                         :4_2:Other "shar:
|>>/recurse> IN: Other "sharpen knives" UnDeeper
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=28:
|>>/recurse> unexpected Other "sharpen knives"
|>>/recurse> expecting GoDeeper

********** / |>>/base                                                                                            :4_2:Other "shar:
*********** / pTemporal/eventually                                                                              :4_2:Other "shar:
pTemporal/eventually> IN: Other "sharpen knives" UnDeeper
pTemporal/eventually> MATCH (EERR): <EMPTY>
pTemporal/eventually> ERROR:
pTemporal/eventually> offset=28:
pTemporal/eventually> unexpected Other "sharpen knives"
pTemporal/eventually> expecting Eventually

*********** / pTemporal/specifically                                                                            :4_2:Other "shar:
************ / $>|                                                                                             :4_2:Other "shar:
$>|> IN: Other "sharpen knives" UnDeeper
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=28:
$>|> unexpected Other "sharpen knives"
$>|> expecting After, Before, By, or On

pTemporal/specifically> IN: Other "sharpen knives" UnDeeper
pTemporal/specifically> MATCH (EERR): <EMPTY>
pTemporal/specifically> ERROR:
pTemporal/specifically> offset=28:
pTemporal/specifically> unexpected Other "sharpen knives"
pTemporal/specifically> expecting After, Before, By, or On

*********** / pTemporal/vaguely                                                                                 :4_2:Other "shar:
pTemporal/vaguely> IN: Other "sharpen knives" UnDeeper
pTemporal/vaguely> MATCH (COK): Other "sharpen knives"
pTemporal/vaguely> VALUE: (Just (TemporalConstraint TVague (Just 0) "sharpen knives"),[])

*********** \ pTemporal/vaguely has returned Just (TemporalConstraint TVague (Just 0) "sharpen knives")          :1_2:UnDeeper:
*********** > |>>/base got Just (Just (TemporalConstraint TVague (Just 0) "sharpen knives"))                     :1_2:UnDeeper:
|>>/base> IN: Other "sharpen knives" UnDeeper
|>>/base> MATCH (COK): Other "sharpen knives"
|>>/base> VALUE: ((Just (Just (TemporalConstraint TVague (Just 0) "sharpen knives")),0),[])

********** \ |>>/base has returned (Just (Just (TemporalConstraint TVague (Just 0) "sharpen knives")),0)          :1_2:UnDeeper:
|>>/recurse> IN: GoDeeper Other "sharpen knives" UnDeeper
|>>/recurse> MATCH (COK): GoDeeper Other "sharpen knives"
|>>/recurse> VALUE: ((Just (Just (TemporalConstraint TVague (Just 0) "sharpen knives")),1),[])

********* \ |>>/recurse has returned (Just (Just (TemporalConstraint TVague (Just 0) "sharpen knives")),1)         :1_2:UnDeeper:
|>| calling $>>> IN: GoDeeper Other "sharpen knives" UnDeeper
|>| calling $>>> MATCH (COK): GoDeeper Other "sharpen knives"
|>| calling $>>> VALUE: ((Just (Just (TemporalConstraint TVague (Just 0) "sharpen knives")),1),[])

******** \ |>| calling $>> has returned (Just (Just (TemporalConstraint TVague (Just 0) "sharpen knives")),1)       :1_2:UnDeeper:
******** / undeepers                                                                                                :1_2:UnDeeper:
********* > sameLine/undeepers: reached end of line; now need to clear 1 UnDeepers                                 :1_2:UnDeeper:
********* > sameLine: success!                                                                                :EOF:
undeepers> IN: UnDeeper
undeepers> MATCH (COK): UnDeeper
undeepers> VALUE: ((),[])

******** \ undeepers has returned ()                                                                           :EOF:
pDT> IN: May GoDeeper Other "sharpen knives" UnDe <…>
pDT> MATCH (COK): May GoDeeper Other "sharpen knives" UnDe <…>
pDT> VALUE: ((DMay,Just (TemporalConstraint TVague (Just 0) "sharpen knives")),[])

******* \ pDT has returned (DMay,Just (TemporalConstraint TVague (Just 0) "sharpen knives"))                    :EOF:
******* / WHERE                                                                                                 :EOF:
WHERE> IN: <EMPTY>
WHERE> MATCH (EERR): <EMPTY>
WHERE> ERROR:
WHERE> offset=30:
WHERE> unexpected end of input
WHERE> expecting Where

******* / preambleParamText:[Having]                                                                            :EOF:
******** / $>|                                                                                                 :EOF:
$>|> IN: <EMPTY>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=30:
$>|> unexpected end of input
$>|> expecting Having

preambleParamText:[Having]> IN: <EMPTY>
preambleParamText:[Having]> MATCH (EERR): <EMPTY>
preambleParamText:[Having]> ERROR:
preambleParamText:[Having]> offset=30:
preambleParamText:[Having]> unexpected end of input
preambleParamText:[Having]> expecting Having or any token

******* / preambleParamText:[Given]                                                                             :EOF:
******** / $>|                                                                                                 :EOF:
$>|> IN: <EMPTY>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=30:
$>|> unexpected end of input
$>|> expecting Given

preambleParamText:[Given]> IN: <EMPTY>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=30:
preambleParamText:[Given]> unexpected end of input
preambleParamText:[Given]> expecting Given or any token

******* / preambleParamText:[Upon]                                                                              :EOF:
******** / $>|                                                                                                 :EOF:
$>|> IN: <EMPTY>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=30:
$>|> unexpected end of input
$>|> expecting Upon

preambleParamText:[Upon]> IN: <EMPTY>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=30:
preambleParamText:[Upon]> unexpected end of input
preambleParamText:[Upon]> expecting Upon or any token

******* / preambleBoolStructR [Unless]                                                                          :EOF:
preambleBoolStructR [Unless]> IN: <EMPTY>
preambleBoolStructR [Unless]> MATCH (EERR): <EMPTY>
preambleBoolStructR [Unless]> ERROR:
preambleBoolStructR [Unless]> offset=30:
preambleBoolStructR [Unless]> unexpected end of input
preambleBoolStructR [Unless]> expecting Unless

******* / preambleBoolStructR [When,If]                                                                         :EOF:
preambleBoolStructR [When,If]> IN: <EMPTY>
preambleBoolStructR [When,If]> MATCH (EERR): <EMPTY>
preambleBoolStructR [When,If]> ERROR:
preambleBoolStructR [When,If]> offset=30:
preambleBoolStructR [When,If]> unexpected end of input
preambleBoolStructR [When,If]> expecting If or When

******* / pDoAction/Do                                                                                          :EOF:
pDoAction/Do> IN: <EMPTY>
pDoAction/Do> MATCH (EERR): <EMPTY>
pDoAction/Do> ERROR:
pDoAction/Do> offset=30:
pDoAction/Do> unexpected end of input
pDoAction/Do> expecting Do

regulative permutation with deontic-temporal> IN: Every GoDeeper Other "person" UnDeeper W <…>
regulative permutation with deontic-temporal> MATCH (CERR): Every GoDeeper Other "person" UnDeeper W <…>
regulative permutation with deontic-temporal> ERROR:
regulative permutation with deontic-temporal> offset=30:
regulative permutation with deontic-temporal> unexpected end of input
regulative permutation with deontic-temporal> expecting Do, Given, Having, If, Unless, Upon, When, Where, or any token

****** / regulative permutation with deontic-action                                                                :1_1:Every:
******* / WHERE                                                                                                   :1_1:Every:
WHERE> IN: Every GoDeeper Other "person" UnDeeper W <…>
WHERE> MATCH (EERR): <EMPTY>
WHERE> ERROR:
WHERE> offset=0:
WHERE> unexpected Every
WHERE> expecting Where

******* / preambleParamText:[Having]                                                                              :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting Having

preambleParamText:[Having]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleParamText:[Having]> MATCH (EERR): <EMPTY>
preambleParamText:[Having]> ERROR:
preambleParamText:[Having]> offset=0:
preambleParamText:[Having]> unexpected Every
preambleParamText:[Having]> expecting Having

******* / preambleParamText:[Given]                                                                               :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting Given

preambleParamText:[Given]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=0:
preambleParamText:[Given]> unexpected Every
preambleParamText:[Given]> expecting Given

******* / preambleParamText:[Upon]                                                                                :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting Upon

preambleParamText:[Upon]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=0:
preambleParamText:[Upon]> unexpected Every
preambleParamText:[Upon]> expecting Upon

******* / preambleBoolStructR [Unless]                                                                            :1_1:Every:
preambleBoolStructR [Unless]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleBoolStructR [Unless]> MATCH (EERR): <EMPTY>
preambleBoolStructR [Unless]> ERROR:
preambleBoolStructR [Unless]> offset=0:
preambleBoolStructR [Unless]> unexpected Every
preambleBoolStructR [Unless]> expecting Unless

******* / preambleBoolStructR [When,If]                                                                           :1_1:Every:
preambleBoolStructR [When,If]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleBoolStructR [When,If]> MATCH (EERR): <EMPTY>
preambleBoolStructR [When,If]> ERROR:
preambleBoolStructR [When,If]> offset=0:
preambleBoolStructR [When,If]> unexpected Every
preambleBoolStructR [When,If]> expecting If or When

******* / pTemporal/eventually                                                                                    :1_1:Every:
pTemporal/eventually> IN: Every GoDeeper Other "person" UnDeeper W <…>
pTemporal/eventually> MATCH (EERR): <EMPTY>
pTemporal/eventually> ERROR:
pTemporal/eventually> offset=0:
pTemporal/eventually> unexpected Every
pTemporal/eventually> expecting Eventually

******* / pTemporal/specifically                                                                                  :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting After, Before, By, or On

pTemporal/specifically> IN: Every GoDeeper Other "person" UnDeeper W <…>
pTemporal/specifically> MATCH (EERR): <EMPTY>
pTemporal/specifically> ERROR:
pTemporal/specifically> offset=0:
pTemporal/specifically> unexpected Every
pTemporal/specifically> expecting After, Before, By, or On

******* / pTemporal/vaguely                                                                                       :1_1:Every:
pTemporal/vaguely> IN: Every GoDeeper Other "person" UnDeeper W <…>
pTemporal/vaguely> MATCH (EERR): <EMPTY>
pTemporal/vaguely> ERROR:
pTemporal/vaguely> offset=0:
pTemporal/vaguely> unexpected Every
pTemporal/vaguely> expecting Other text

******* / pActor [Every,Party,TokAll]                                                                             :1_1:Every:
******** / someIndentation                                                                                        :1_2:GoDeeper:
********* / myindented: consuming GoDeeper                                                                       :1_2:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "person" UnDeeper Who GoD <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

********* \ myindented: consuming GoDeeper has returned GoDeeper                                                  :1_2:Other "pers:
********* / manyIndentation/leaf?                                                                                 :1_2:Other "pers:
********** / pMultiTermAka                                                                                       :1_2:Other "pers:
*********** / pAKA                                                                                              :1_2:Other "pers:
************ / slAKA                                                                                           :1_2:Other "pers:
************* / $*|                                                                                           :1_2:Other "pers:
************** / slAKA base                                                                                  :1_2:Other "pers:
*************** / slMultiTerm                                                                               :1_2:Other "pers:
**************** / someSL                                                                                  :1_2:Other "pers:
someSL> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
someSL> MATCH (COK): Other "person"
someSL> VALUE: ((["person"],0),[])

**************** \ someSL has returned (["person"],0)                                                       :2_2:UnDeeper:
slMultiTerm> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
slMultiTerm> MATCH (COK): Other "person"
slMultiTerm> VALUE: ((["person"],0),[])

*************** \ slMultiTerm has returned (["person"],0)                                                    :2_2:UnDeeper:
slAKA base> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
slAKA base> MATCH (COK): Other "person"
slAKA base> VALUE: ((["person"],0),[])

************** \ slAKA base has returned (["person"],0)                                                       :2_2:UnDeeper:
$*|> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
$*|> MATCH (COK): Other "person"
$*|> VALUE: ((["person"],0),[])

************* \ $*| has returned (["person"],0)                                                                :2_2:UnDeeper:
************* / |>>/recurse                                                                                    :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************* / |>>/base                                                                                       :2_2:UnDeeper:
************** / slAKA optional akapart                                                                       :2_2:UnDeeper:
*************** / |?| optional something                                                                     :2_2:UnDeeper:
**************** / |>>/recurse                                                                              :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

**************** / |>>/base                                                                                 :2_2:UnDeeper:
***************** / PAKA/akapart                                                                           :2_2:UnDeeper:
****************** / $>|                                                                                  :2_2:UnDeeper:
******************* / Aka Token                                                                          :2_2:UnDeeper:
Aka Token> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
Aka Token> MATCH (EERR): <EMPTY>
Aka Token> ERROR:
Aka Token> offset=3:
Aka Token> unexpected UnDeeper
Aka Token> expecting Aka

$>|> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=3:
$>|> unexpected UnDeeper
$>|> expecting Aka

PAKA/akapart> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
PAKA/akapart> MATCH (EERR): <EMPTY>
PAKA/akapart> ERROR:
PAKA/akapart> offset=3:
PAKA/akapart> unexpected UnDeeper
PAKA/akapart> expecting Aka

|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=3:
|>>/base> unexpected UnDeeper
|>>/base> expecting Aka

|?| optional something> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

*************** \ |?| optional something has returned (Nothing,0)                                            :2_2:UnDeeper:
slAKA optional akapart> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
slAKA optional akapart> MATCH (EOK): <EMPTY>
slAKA optional akapart> VALUE: ((Nothing,0),[])

************** \ slAKA optional akapart has returned (Nothing,0)                                              :2_2:UnDeeper:
************** > |>>/base got Nothing                                                                         :2_2:UnDeeper:
|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************* \ |>>/base has returned (Nothing,0)                                                              :2_2:UnDeeper:
************* / |>>/recurse                                                                                    :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************* / |>>/base                                                                                       :2_2:UnDeeper:
************** / slAKA optional typically                                                                     :2_2:UnDeeper:
*************** / |?| optional something                                                                     :2_2:UnDeeper:
**************** / |>>/recurse                                                                              :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

**************** / |>>/base                                                                                 :2_2:UnDeeper:
***************** / typically                                                                              :2_2:UnDeeper:
****************** / $>|                                                                                  :2_2:UnDeeper:
$>|> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=3:
$>|> unexpected UnDeeper
$>|> expecting Typically

typically> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
typically> MATCH (EERR): <EMPTY>
typically> ERROR:
typically> offset=3:
typically> unexpected UnDeeper
typically> expecting Typically

|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=3:
|>>/base> unexpected UnDeeper
|>>/base> expecting Typically

|?| optional something> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

*************** \ |?| optional something has returned (Nothing,0)                                            :2_2:UnDeeper:
slAKA optional typically> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
slAKA optional typically> MATCH (EOK): <EMPTY>
slAKA optional typically> VALUE: ((Nothing,0),[])

************** \ slAKA optional typically has returned (Nothing,0)                                            :2_2:UnDeeper:
************** > |>>/base got Nothing                                                                         :2_2:UnDeeper:
|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************* \ |>>/base has returned (Nothing,0)                                                              :2_2:UnDeeper:
************* > slAKA: proceeding after base and entityalias are retrieved ...                                 :2_2:UnDeeper:
************* > pAKA: entityalias = Nothing                                                                    :2_2:UnDeeper:
slAKA> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
slAKA> MATCH (COK): Other "person"
slAKA> VALUE: ((["person"],0),[])

************ \ slAKA has returned (["person"],0)                                                                :2_2:UnDeeper:
************ / undeepers                                                                                        :2_2:UnDeeper:
************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers                         :2_2:UnDeeper:
************* > sameLine: success!                                                                             :2_2:UnDeeper:
undeepers> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

************ \ undeepers has returned ()                                                                        :2_2:UnDeeper:
pAKA> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
pAKA> MATCH (COK): Other "person"
pAKA> VALUE: (["person"],[])

*********** \ pAKA has returned ["person"]                                                                       :2_2:UnDeeper:
pMultiTermAka> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
pMultiTermAka> MATCH (COK): Other "person"
pMultiTermAka> VALUE: (["person"],[])

********** \ pMultiTermAka has returned ["person"]                                                                :2_2:UnDeeper:
manyIndentation/leaf?> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
manyIndentation/leaf?> MATCH (COK): Other "person"
manyIndentation/leaf?> VALUE: (["person"],[])

********* \ manyIndentation/leaf? has returned ["person"]                                                          :2_2:UnDeeper:
********* / myindented: consuming UnDeeper                                                                         :2_2:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

********* \ myindented: consuming UnDeeper has returned UnDeeper                                                :2_1:Who:
someIndentation> IN: GoDeeper Other "person" UnDeeper Who GoD <…>
someIndentation> MATCH (COK): GoDeeper Other "person" UnDeeper
someIndentation> VALUE: (["person"],[])

******** \ someIndentation has returned ["person"]                                                               :2_1:Who:
pActor [Every,Party,TokAll]> IN: Every GoDeeper Other "person" UnDeeper W <…>
pActor [Every,Party,TokAll]> MATCH (COK): Every GoDeeper Other "person" UnDeeper
pActor [Every,Party,TokAll]> VALUE: ((Every,Leaf (("person" :| [],Nothing) :| [])),[])

******* \ pActor [Every,Party,TokAll] has returned (Every,Leaf (("person" :| [],Nothing) :| []))                  :2_1:Who:
******* / manyIndentation/leaf?                                                                                   :2_1:Who:
******** / preambleBoolStructR [Who,Which,Whose]                                                                 :2_1:Who:
********* / pBSR                                                                                                 :2_2:GoDeeper:
********** / ppp inner                                                                                          :2_2:GoDeeper:
*********** / expression                                                                                       :2_2:GoDeeper:
************ / labelPrefix                                                                                    :2_2:GoDeeper:
labelPrefix> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=5:
labelPrefix> unexpected GoDeeper
labelPrefix> expecting Other text

************ / term p                                                                                         :2_2:GoDeeper:
************* / term p/1a:label directly above                                                               :2_2:GoDeeper:
************** / $*|                                                                                        :2_2:GoDeeper:
*************** / someSL                                                                                   :2_2:GoDeeper:
**************** / pNumAsText                                                                             :2_2:GoDeeper:
pNumAsText> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=5:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=5:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=5:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=5:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

************* / term p/b:label to the left of line below, with EOL                                           :2_2:GoDeeper:
************** / someSL                                                                                     :2_2:GoDeeper:
*************** / pNumAsText                                                                               :2_2:GoDeeper:
pNumAsText> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=5:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=5:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=5:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

************* / term p/notLabelTerm                                                                          :2_2:GoDeeper:
************** / term p/2:someIndentation expr p                                                            :2_2:GoDeeper:
*************** / someIndentation                                                                          :2_2:GoDeeper:
**************** / myindented: consuming GoDeeper                                                         :2_2:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

**************** \ myindented: consuming GoDeeper has returned GoDeeper                                     :2_3:GoDeeper:
**************** / manyIndentation/leaf?                                                                    :2_3:GoDeeper:
***************** / expression                                                                             :2_3:GoDeeper:
****************** / labelPrefix                                                                          :2_3:GoDeeper:
labelPrefix> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=6:
labelPrefix> unexpected GoDeeper
labelPrefix> expecting Other text

****************** / term p                                                                               :2_3:GoDeeper:
******************* / term p/1a:label directly above                                                     :2_3:GoDeeper:
******************** / $*|                                                                              :2_3:GoDeeper:
********************* / someSL                                                                         :2_3:GoDeeper:
********************** / pNumAsText                                                                   :2_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=6:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=6:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=6:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=6:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

******************* / term p/b:label to the left of line below, with EOL                                 :2_3:GoDeeper:
******************** / someSL                                                                           :2_3:GoDeeper:
********************* / pNumAsText                                                                     :2_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=6:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=6:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=6:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

******************* / term p/notLabelTerm                                                                :2_3:GoDeeper:
******************** / term p/2:someIndentation expr p                                                  :2_3:GoDeeper:
********************* / someIndentation                                                                :2_3:GoDeeper:
********************** / myindented: consuming GoDeeper                                               :2_3:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

********************** \ myindented: consuming GoDeeper has returned GoDeeper                          :2_3:Other "is":
********************** / manyIndentation/leaf?                                                         :2_3:Other "is":
*********************** / expression                                                                  :2_3:Other "is":
************************ / labelPrefix                                                               :2_3:Other "is":
labelPrefix> IN: Other "is" GoDeeper Other "immortal" GoD <…>
labelPrefix> MATCH (COK): Other "is"
labelPrefix> VALUE: ("is",[])

************************ \ labelPrefix has returned "is"                                              :2_4:GoDeeper:
************************ / term p                                                                     :2_4:GoDeeper:
************************* / term p/1a:label directly above                                           :2_4:GoDeeper:
************************** / $*|                                                                    :2_4:GoDeeper:
*************************** / someSL                                                               :2_4:GoDeeper:
**************************** / pNumAsText                                                         :2_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=8:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=8:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=8:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=8:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

************************* / term p/b:label to the left of line below, with EOL                       :2_4:GoDeeper:
************************** / someSL                                                                 :2_4:GoDeeper:
*************************** / pNumAsText                                                           :2_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=8:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=8:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=8:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

************************* / term p/notLabelTerm                                                      :2_4:GoDeeper:
************************** / term p/2:someIndentation expr p                                        :2_4:GoDeeper:
*************************** / someIndentation                                                      :2_4:GoDeeper:
**************************** / myindented: consuming GoDeeper                                     :2_4:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

**************************** \ myindented: consuming GoDeeper has returned GoDeeper                :2_4:Other "immo:
**************************** / manyIndentation/leaf?                                               :2_4:Other "immo:
***************************** / expression                                                        :2_4:Other "immo:
****************************** / labelPrefix                                                     :2_4:Other "immo:
labelPrefix> IN: Other "immortal" GoDeeper Typically GoDe <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=10:
labelPrefix> unexpected GoDeeper

****************************** / term p                                                          :2_4:Other "immo:
******************************* / term p/1a:label directly above                                :2_4:Other "immo:
******************************** / $*|                                                         :2_4:Other "immo:
********************************* / someSL                                                    :2_4:Other "immo:
********************************** / pNumAsText                                                :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

********************************* \ someSL has returned (["immortal"],0)                       :2_5:GoDeeper:
********************************* / pNumAsText                                                 :2_5:GoDeeper:
pNumAsText> IN: GoDeeper Typically GoDeeper Other "false <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (CERR): Other "immortal"
$*|> ERROR:
$*|> offset=10:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/1a:label directly above> MATCH (CERR): Other "immortal"
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=10:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

******************************* / term p/b:label to the left of line below, with EOL            :2_4:Other "immo:
******************************** / someSL                                                      :2_4:Other "immo:
********************************* / pNumAsText                                                  :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

******************************** \ someSL has returned (["immortal"],0)                         :2_5:GoDeeper:
******************************** / undeepers                                                    :2_5:GoDeeper:
********************************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers :2_5:GoDeeper:
********************************* > sameLine: success!                                         :2_5:GoDeeper:
undeepers> IN: GoDeeper Typically GoDeeper Other "false <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

******************************** \ undeepers has returned ()                                    :2_5:GoDeeper:
******************************** / matching EOL                                                 :2_5:GoDeeper:
matching EOL> IN: GoDeeper Typically GoDeeper Other "false <…>
matching EOL> MATCH (EERR): <EMPTY>
matching EOL> ERROR:
matching EOL> offset=10:
matching EOL> unexpected GoDeeper
matching EOL> expecting EOL

term p/b:label to the left of line below, with EOL> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/b:label to the left of line below, with EOL> MATCH (CERR): Other "immortal"
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=10:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting EOL

******************************* / term p/notLabelTerm                                           :2_4:Other "immo:
******************************** / term p/2:someIndentation expr p                             :2_4:Other "immo:
********************************* / someIndentation                                           :2_4:Other "immo:
********************************** / myindented: consuming GoDeeper                          :2_4:Other "immo:
myindented: consuming GoDeeper> IN: Other "immortal" GoDeeper Typically GoDe <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=9:
myindented: consuming GoDeeper> unexpected Other "immortal"
myindented: consuming GoDeeper> expecting GoDeeper

someIndentation> IN: Other "immortal" GoDeeper Typically GoDe <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=9:
someIndentation> unexpected Other "immortal"
someIndentation> expecting GoDeeper

term p/2:someIndentation expr p> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/2:someIndentation expr p> MATCH (EERR): <EMPTY>
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=9:
term p/2:someIndentation expr p> unexpected Other "immortal"
term p/2:someIndentation expr p> expecting GoDeeper

******************************** / term p/3:plain p                                            :2_4:Other "immo:
********************************* / pRelPred                                                  :2_4:Other "immo:
********************************** / slRelPred                                               :2_4:Other "immo:
*********************************** / nested simpleHorn                                     :2_4:Other "immo:
************************************ > |^|                                                 :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slMultiTerm                                       :2_4:Other "immo:
************************************** / someSL                                          :2_4:Other "immo:
*************************************** / pNumAsText                                      :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

************************************** \ someSL has returned (["immortal"],0)             :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

************************************* \ slMultiTerm has returned (["immortal"],0)          :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************ \ $*| has returned (["immortal"],0)                    :2_5:GoDeeper:
************************************ / |^| deeps                                            :2_5:GoDeeper:
|^| deeps> IN: GoDeeper Typically GoDeeper Other "false <…>
|^| deeps> MATCH (COK): GoDeeper
|^| deeps> VALUE: (([()],1),[])

************************************ \ |^| deeps has returned ([()],1)                       :2_5:Typically:
nested simpleHorn> IN: Other "immortal" GoDeeper Typically GoDe <…>
nested simpleHorn> MATCH (CERR): Other "immortal" GoDeeper
nested simpleHorn> ERROR:
nested simpleHorn> offset=11:
nested simpleHorn> unexpected Typically
nested simpleHorn> expecting GoDeeper or Means

*********************************** / RPConstraint                                          :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slMultiTerm                                       :2_4:Other "immo:
************************************** / someSL                                          :2_4:Other "immo:
*************************************** / pNumAsText                                      :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

************************************** \ someSL has returned (["immortal"],0)             :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

************************************* \ slMultiTerm has returned (["immortal"],0)          :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************ \ $*| has returned (["immortal"],0)                    :2_5:GoDeeper:
************************************ / |>| calling $>>                                      :2_5:GoDeeper:
************************************* / |>>/recurse                                        :2_5:GoDeeper:
************************************** / |>>/recurse                                       :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                          :2_5:Typically:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=11:
|>>/base> unexpected Typically
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>>/recurse> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/recurse> MATCH (CERR): GoDeeper
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

************************************* / |>>/base                                           :2_5:GoDeeper:
|>>/base> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=10:
|>>/base> unexpected GoDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: GoDeeper Typically GoDeeper Other "false <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=11:
|>| calling $>>> unexpected Typically
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPConstraint> IN: Other "immortal" GoDeeper Typically GoDe <…>
RPConstraint> MATCH (CERR): Other "immortal"
RPConstraint> ERROR:
RPConstraint> offset=11:
RPConstraint> unexpected Typically
RPConstraint> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPBoolStructR                                         :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slMultiTerm                                       :2_4:Other "immo:
************************************** / someSL                                          :2_4:Other "immo:
*************************************** / pNumAsText                                      :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

************************************** \ someSL has returned (["immortal"],0)             :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

************************************* \ slMultiTerm has returned (["immortal"],0)          :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************ \ $*| has returned (["immortal"],0)                    :2_5:GoDeeper:
************************************ / |>| calling $>>                                      :2_5:GoDeeper:
************************************* / |>>/recurse                                        :2_5:GoDeeper:
************************************** / |>>/recurse                                       :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                          :2_5:Typically:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=11:
|>>/base> unexpected Typically
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>>/recurse> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/recurse> MATCH (CERR): GoDeeper
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

************************************* / |>>/base                                           :2_5:GoDeeper:
|>>/base> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=10:
|>>/base> unexpected GoDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: GoDeeper Typically GoDeeper Other "false <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=11:
|>| calling $>>> unexpected Typically
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPBoolStructR> IN: Other "immortal" GoDeeper Typically GoDe <…>
RPBoolStructR> MATCH (CERR): Other "immortal"
RPBoolStructR> ERROR:
RPBoolStructR> offset=11:
RPBoolStructR> unexpected Typically
RPBoolStructR> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPMT                                                  :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slAKA                                             :2_4:Other "immo:
************************************** / $*|                                             :2_4:Other "immo:
*************************************** / slAKA base                                    :2_4:Other "immo:
**************************************** / slMultiTerm                                 :2_4:Other "immo:
***************************************** / someSL                                    :2_4:Other "immo:
****************************************** / pNumAsText                                :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

***************************************** \ someSL has returned (["immortal"],0)       :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

**************************************** \ slMultiTerm has returned (["immortal"],0)    :2_5:GoDeeper:
slAKA base> IN: Other "immortal" GoDeeper Typically GoDe <…>
slAKA base> MATCH (COK): Other "immortal"
slAKA base> VALUE: ((["immortal"],0),[])

*************************************** \ slAKA base has returned (["immortal"],0)       :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************** \ $*| has returned (["immortal"],0)                :2_5:GoDeeper:
************************************** / |>>/recurse                                      :2_5:GoDeeper:
*************************************** / |>>/recurse                                     :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

*************************************** / |>>/base                                        :2_5:Typically:
**************************************** / slAKA optional akapart                        :2_5:Typically:
***************************************** / |?| optional something                      :2_5:Typically:
****************************************** / |>>/recurse                               :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

****************************************** / |>>/base                                  :2_5:Typically:
******************************************* / PAKA/akapart                            :2_5:Typically:
******************************************** / $>|                                   :2_5:Typically:
********************************************* / Aka Token                           :2_5:Typically:
Aka Token> IN: Typically GoDeeper Other "false" UnDeepe <…>
Aka Token> MATCH (EERR): <EMPTY>
Aka Token> ERROR:
Aka Token> offset=11:
Aka Token> unexpected Typically
Aka Token> expecting Aka

$>|> IN: Typically GoDeeper Other "false" UnDeepe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=11:
$>|> unexpected Typically
$>|> expecting Aka

PAKA/akapart> IN: Typically GoDeeper Other "false" UnDeepe <…>
PAKA/akapart> MATCH (EERR): <EMPTY>
PAKA/akapart> ERROR:
PAKA/akapart> offset=11:
PAKA/akapart> unexpected Typically
PAKA/akapart> expecting Aka

|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=11:
|>>/base> unexpected Typically
|>>/base> expecting Aka

|?| optional something> IN: Typically GoDeeper Other "false" UnDeepe <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

***************************************** \ |?| optional something has returned (Nothing,0) :2_5:Typically:
slAKA optional akapart> IN: Typically GoDeeper Other "false" UnDeepe <…>
slAKA optional akapart> MATCH (EOK): <EMPTY>
slAKA optional akapart> VALUE: ((Nothing,0),[])

**************************************** \ slAKA optional akapart has returned (Nothing,0) :2_5:Typically:
**************************************** > |>>/base got Nothing                          :2_5:Typically:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

*************************************** \ |>>/base has returned (Nothing,0)               :2_5:Typically:
|>>/recurse> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/recurse> MATCH (COK): GoDeeper
|>>/recurse> VALUE: ((Nothing,1),[])

************************************** \ |>>/recurse has returned (Nothing,1)              :2_5:Typically:
************************************** / |>>/recurse                                       :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                          :2_5:Typically:
*************************************** / slAKA optional typically                        :2_5:Typically:
**************************************** / |?| optional something                        :2_5:Typically:
***************************************** / |>>/recurse                                 :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

***************************************** / |>>/base                                    :2_5:Typically:
****************************************** / typically                                 :2_5:Typically:
******************************************* / $>|                                     :2_5:Typically:
$>|> IN: Typically GoDeeper Other "false" UnDeepe <…>
$>|> MATCH (COK): Typically
$>|> VALUE: (Typically,[])

******************************************* \ $>| has returned Typically               :2_6:GoDeeper:
******************************************* / |>>/recurse                              :2_6:GoDeeper:
******************************************** / |>>/recurse                             :2_6:Other "fals:
|>>/recurse> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=13:
|>>/recurse> unexpected Other "false"
|>>/recurse> expecting GoDeeper

******************************************** / |>>/base                                :2_6:Other "fals:
********************************************* / slMultiTerm                           :2_6:Other "fals:
********************************************** / someSL                              :2_6:Other "fals:
someSL> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
someSL> MATCH (COK): Other "false"
someSL> VALUE: ((["false"],0),[])

********************************************** \ someSL has returned (["false"],0) :3_3:UnDeeper:
slMultiTerm> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
slMultiTerm> MATCH (COK): Other "false"
slMultiTerm> VALUE: ((["false"],0),[])

********************************************* \ slMultiTerm has returned (["false"],0) :3_3:UnDeeper:
********************************************* > |>>/base got ["false"]           :3_3:UnDeeper:
|>>/base> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
|>>/base> MATCH (COK): Other "false"
|>>/base> VALUE: ((["false"],0),[])

******************************************** \ |>>/base has returned (["false"],0) :3_3:UnDeeper:
|>>/recurse> IN: GoDeeper Other "false" UnDeeper UnDeeper <…>
|>>/recurse> MATCH (COK): GoDeeper Other "false"
|>>/recurse> VALUE: ((["false"],1),[])

******************************************* \ |>>/recurse has returned (["false"],1) :3_3:UnDeeper:
typically> IN: Typically GoDeeper Other "false" UnDeepe <…>
typically> MATCH (COK): Typically GoDeeper Other "false"
typically> VALUE: ((["false"],1),[])

****************************************** \ typically has returned (["false"],1)   :3_3:UnDeeper:
****************************************** > |>>/base got ["false"]                 :3_3:UnDeeper:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (COK): Typically GoDeeper Other "false"
|>>/base> VALUE: ((["false"],1),[])

***************************************** \ |>>/base has returned (["false"],1)      :3_3:UnDeeper:
|?| optional something> IN: Typically GoDeeper Other "false" UnDeepe <…>
|?| optional something> MATCH (COK): Typically GoDeeper Other "false"
|?| optional something> VALUE: ((Just ["false"],1),[])

**************************************** \ |?| optional something has returned (Just ["false"],1) :3_3:UnDeeper:
slAKA optional typically> IN: Typically GoDeeper Other "false" UnDeepe <…>
slAKA optional typically> MATCH (COK): Typically GoDeeper Other "false"
slAKA optional typically> VALUE: ((Just ["false"],1),[])

*************************************** \ slAKA optional typically has returned (Just ["false"],1) :3_3:UnDeeper:
*************************************** > |>>/base got Just ["false"]                  :3_3:UnDeeper:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (COK): Typically GoDeeper Other "false"
|>>/base> VALUE: ((Just ["false"],1),[])

************************************** \ |>>/base has returned (Just ["false"],1)       :3_3:UnDeeper:
************************************** > slAKA: proceeding after base and entityalias are retrieved ... :3_3:UnDeeper:
************************************** > pAKA: entityalias = Nothing                    :3_3:UnDeeper:
slAKA> IN: Other "immortal" GoDeeper Typically GoDe <…>
slAKA> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
slAKA> VALUE: ((["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************************* \ slAKA has returned (["immortal"],2)              :3_3:UnDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
$*|> VALUE: ((["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************************ \ $*| has returned (["immortal"],2)                  :3_3:UnDeeper:
RPMT> IN: Other "immortal" GoDeeper Typically GoDe <…>
RPMT> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
RPMT> VALUE: ((RPMT ["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*********************************** \ RPMT has returned (RPMT ["immortal"],2)              :3_3:UnDeeper:
slRelPred> IN: Other "immortal" GoDeeper Typically GoDe <…>
slRelPred> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
slRelPred> VALUE: ((RPMT ["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************************** \ slRelPred has returned (RPMT ["immortal"],2)           :3_3:UnDeeper:
********************************** / undeepers                                              :3_3:UnDeeper:
*********************************** > sameLine/undeepers: reached end of line; now need to clear 2 UnDeepers :3_3:UnDeeper:
*********************************** > sameLine: success!                                       :3_5:UnDeeper:
undeepers> IN: UnDeeper UnDeeper UnDeeper UnDeeper Or G <…>
undeepers> MATCH (COK): UnDeeper UnDeeper
undeepers> VALUE: ((),[])

********************************** \ undeepers has returned ()                                  :3_5:UnDeeper:
pRelPred> IN: Other "immortal" GoDeeper Typically GoDe <…>
pRelPred> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
pRelPred> VALUE: (RPMT ["immortal"],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************************* \ pRelPred has returned RPMT ["immortal"]                      :3_5:UnDeeper:
term p/3:plain p> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/3:plain p> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
term p/3:plain p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************************** \ term p/3:plain p has returned MyLeaf (RPMT ["immortal"])       :3_5:UnDeeper:
term p/notLabelTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/notLabelTerm> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["immortal"])      :3_5:UnDeeper:
term p> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
term p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

****************************** \ term p has returned MyLeaf (RPMT ["immortal"])                     :3_5:UnDeeper:
****************************** / binary(Or)                                                         :3_5:UnDeeper:
binary(Or)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=16:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

****************************** / binary(And)                                                        :3_5:UnDeeper:
binary(And)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=16:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

****************************** / binary(SetLess)                                                    :3_5:UnDeeper:
binary(SetLess)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=16:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

****************************** / binary(SetPlus)                                                    :3_5:UnDeeper:
binary(SetPlus)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=16:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "immortal" GoDeeper Typically GoDe <…>
expression> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
expression> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

***************************** \ expression has returned MyLeaf (RPMT ["immortal"])                   :3_5:UnDeeper:
manyIndentation/leaf?> IN: Other "immortal" GoDeeper Typically GoDe <…>
manyIndentation/leaf?> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
manyIndentation/leaf?> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

**************************** \ manyIndentation/leaf? has returned MyLeaf (RPMT ["immortal"])          :3_5:UnDeeper:
**************************** / myindented: consuming UnDeeper                                         :3_5:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

**************************** \ myindented: consuming UnDeeper has returned UnDeeper                     :3_6:UnDeeper:
someIndentation> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
someIndentation> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
someIndentation> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*************************** \ someIndentation has returned MyLeaf (RPMT ["immortal"])                    :3_6:UnDeeper:
term p/2:someIndentation expr p> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
term p/2:someIndentation expr p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************** \ term p/2:someIndentation expr p has returned MyLeaf (RPMT ["immortal"])      :3_6:UnDeeper:
term p/notLabelTerm> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["immortal"])                    :3_6:UnDeeper:
term p> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
term p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************ \ term p has returned MyLeaf (RPMT ["immortal"])                                   :3_6:UnDeeper:
************************ / binary(Or)                                                                       :3_6:UnDeeper:
binary(Or)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=17:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

************************ / binary(And)                                                                      :3_6:UnDeeper:
binary(And)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=17:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

************************ / binary(SetLess)                                                                  :3_6:UnDeeper:
binary(SetLess)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=17:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

************************ / binary(SetPlus)                                                                  :3_6:UnDeeper:
binary(SetPlus)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=17:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "is" GoDeeper Other "immortal" GoD <…>
expression> MATCH (COK): Other "is" GoDeeper Other "immortal" GoD <…>
expression> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*********************** \ expression has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))                :3_6:UnDeeper:
manyIndentation/leaf?> IN: Other "is" GoDeeper Other "immortal" GoD <…>
manyIndentation/leaf?> MATCH (COK): Other "is" GoDeeper Other "immortal" GoD <…>
manyIndentation/leaf?> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************** \ manyIndentation/leaf? has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))       :3_6:UnDeeper:
********************** / myindented: consuming UnDeeper                                                       :3_6:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

********************** \ myindented: consuming UnDeeper has returned UnDeeper                        :3_2:Or:
someIndentation> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
someIndentation> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
someIndentation> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************* \ someIndentation has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))      :3_2:Or:
term p/2:someIndentation expr p> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
term p/2:someIndentation expr p> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************** \ term p/2:someIndentation expr p has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"])) :3_2:Or:
term p/notLabelTerm> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
term p/notLabelTerm> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************* \ term p/notLabelTerm has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))      :3_2:Or:
term p> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
term p> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

****************** \ term p has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))                     :3_2:Or:
****************** / binary(Or)                                                                          :3_2:Or:
binary(Or)> IN: Or GoDeeper Other "has" GoDeeper Other " <…>
binary(Or)> MATCH (COK): Or
binary(Or)> VALUE: (Or,[])

****************** \ binary(Or) has returned Or                                                           :3_3:GoDeeper:
****************** / term p                                                                               :3_3:GoDeeper:
******************* / term p/1a:label directly above                                                     :3_3:GoDeeper:
******************** / $*|                                                                              :3_3:GoDeeper:
********************* / someSL                                                                         :3_3:GoDeeper:
********************** / pNumAsText                                                                   :3_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=19:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=19:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=19:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=19:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

******************* / term p/b:label to the left of line below, with EOL                                 :3_3:GoDeeper:
******************** / someSL                                                                           :3_3:GoDeeper:
********************* / pNumAsText                                                                     :3_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=19:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=19:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=19:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

******************* / term p/notLabelTerm                                                                :3_3:GoDeeper:
******************** / term p/2:someIndentation expr p                                                  :3_3:GoDeeper:
********************* / someIndentation                                                                :3_3:GoDeeper:
********************** / myindented: consuming GoDeeper                                               :3_3:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

********************** \ myindented: consuming GoDeeper has returned GoDeeper                          :3_3:Other "has":
********************** / manyIndentation/leaf?                                                         :3_3:Other "has":
*********************** / expression                                                                  :3_3:Other "has":
************************ / labelPrefix                                                               :3_3:Other "has":
labelPrefix> IN: Other "has" GoDeeper Other "health insur <…>
labelPrefix> MATCH (COK): Other "has"
labelPrefix> VALUE: ("has",[])

************************ \ labelPrefix has returned "has"                                             :3_4:GoDeeper:
************************ / term p                                                                     :3_4:GoDeeper:
************************* / term p/1a:label directly above                                           :3_4:GoDeeper:
************************** / $*|                                                                    :3_4:GoDeeper:
*************************** / someSL                                                               :3_4:GoDeeper:
**************************** / pNumAsText                                                         :3_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "health insurance" UnDeep <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=21:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "health insurance" UnDeep <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=21:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "health insurance" UnDeep <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=21:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=21:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

************************* / term p/b:label to the left of line below, with EOL                       :3_4:GoDeeper:
************************** / someSL                                                                 :3_4:GoDeeper:
*************************** / pNumAsText                                                           :3_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "health insurance" UnDeep <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=21:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "health insurance" UnDeep <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=21:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=21:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

************************* / term p/notLabelTerm                                                      :3_4:GoDeeper:
************************** / term p/2:someIndentation expr p                                        :3_4:GoDeeper:
*************************** / someIndentation                                                      :3_4:GoDeeper:
**************************** / myindented: consuming GoDeeper                                     :3_4:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "health insurance" UnDeep <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

**************************** \ myindented: consuming GoDeeper has returned GoDeeper                :3_4:Other "heal:
**************************** / manyIndentation/leaf?                                               :3_4:Other "heal:
***************************** / expression                                                        :3_4:Other "heal:
****************************** / labelPrefix                                                     :3_4:Other "heal:
labelPrefix> IN: Other "health insurance" UnDeeper UnDeep <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=23:
labelPrefix> unexpected UnDeeper

****************************** / term p                                                          :3_4:Other "heal:
******************************* / term p/1a:label directly above                                :3_4:Other "heal:
******************************** / $*|                                                         :3_4:Other "heal:
********************************* / someSL                                                    :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

********************************* \ someSL has returned (["health insurance"],0)           :4_2:UnDeeper:
********************************* / pNumAsText                                             :4_2:UnDeeper:
pNumAsText> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=23:
pNumAsText> unexpected UnDeeper
pNumAsText> expecting number

$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (CERR): Other "health insurance"
$*|> ERROR:
$*|> offset=23:
$*|> unexpected UnDeeper
$*|> expecting GoDeeper or other text or number

term p/1a:label directly above> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/1a:label directly above> MATCH (CERR): Other "health insurance"
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=23:
term p/1a:label directly above> unexpected UnDeeper
term p/1a:label directly above> expecting GoDeeper or other text or number

******************************* / term p/b:label to the left of line below, with EOL            :3_4:Other "heal:
******************************** / someSL                                                      :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

******************************** \ someSL has returned (["health insurance"],0)             :4_2:UnDeeper:
******************************** / undeepers                                                :4_2:UnDeeper:
********************************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers :4_2:UnDeeper:
********************************* > sameLine: success!                                     :4_2:UnDeeper:
undeepers> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

******************************** \ undeepers has returned ()                                :4_2:UnDeeper:
******************************** / matching EOL                                             :4_2:UnDeeper:
matching EOL> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
matching EOL> MATCH (EERR): <EMPTY>
matching EOL> ERROR:
matching EOL> offset=23:
matching EOL> unexpected UnDeeper
matching EOL> expecting EOL

term p/b:label to the left of line below, with EOL> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/b:label to the left of line below, with EOL> MATCH (CERR): Other "health insurance"
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=23:
term p/b:label to the left of line below, with EOL> unexpected UnDeeper
term p/b:label to the left of line below, with EOL> expecting EOL or GoDeeper

******************************* / term p/notLabelTerm                                           :3_4:Other "heal:
******************************** / term p/2:someIndentation expr p                             :3_4:Other "heal:
********************************* / someIndentation                                           :3_4:Other "heal:
********************************** / myindented: consuming GoDeeper                          :3_4:Other "heal:
myindented: consuming GoDeeper> IN: Other "health insurance" UnDeeper UnDeep <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=22:
myindented: consuming GoDeeper> unexpected Other "health insurance"
myindented: consuming GoDeeper> expecting GoDeeper

someIndentation> IN: Other "health insurance" UnDeeper UnDeep <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=22:
someIndentation> unexpected Other "health insurance"
someIndentation> expecting GoDeeper

term p/2:someIndentation expr p> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/2:someIndentation expr p> MATCH (EERR): <EMPTY>
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=22:
term p/2:someIndentation expr p> unexpected Other "health insurance"
term p/2:someIndentation expr p> expecting GoDeeper

******************************** / term p/3:plain p                                            :3_4:Other "heal:
********************************* / pRelPred                                                  :3_4:Other "heal:
********************************** / slRelPred                                               :3_4:Other "heal:
*********************************** / nested simpleHorn                                     :3_4:Other "heal:
************************************ > |^|                                                 :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slMultiTerm                                       :3_4:Other "heal:
************************************** / someSL                                          :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

************************************* \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
************************************ / |^| deeps                                        :4_2:UnDeeper:
|^| deeps> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|^| deeps> MATCH (COK): UnDeeper UnDeeper UnDeeper
|^| deeps> VALUE: (([(),(),()],-3),[])

************************************ \ |^| deeps has returned ([(),(),()],-3)        :4_1:May:
nested simpleHorn> IN: Other "health insurance" UnDeeper UnDeep <…>
nested simpleHorn> MATCH (CERR): Other "health insurance" UnDeeper UnDeep <…>
nested simpleHorn> ERROR:
nested simpleHorn> offset=26:
nested simpleHorn> unexpected May
nested simpleHorn> expecting Means or UnDeeper

*********************************** / RPConstraint                                          :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slMultiTerm                                       :3_4:Other "heal:
************************************** / someSL                                          :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

************************************* \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
************************************ / |>| calling $>>                                  :4_2:UnDeeper:
************************************* / |>>/recurse                                    :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************* / |>>/base                                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=23:
|>| calling $>>> unexpected UnDeeper
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPConstraint> IN: Other "health insurance" UnDeeper UnDeep <…>
RPConstraint> MATCH (CERR): Other "health insurance"
RPConstraint> ERROR:
RPConstraint> offset=23:
RPConstraint> unexpected UnDeeper
RPConstraint> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPBoolStructR                                         :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slMultiTerm                                       :3_4:Other "heal:
************************************** / someSL                                          :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

************************************* \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
************************************ / |>| calling $>>                                  :4_2:UnDeeper:
************************************* / |>>/recurse                                    :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************* / |>>/base                                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=23:
|>| calling $>>> unexpected UnDeeper
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPBoolStructR> IN: Other "health insurance" UnDeeper UnDeep <…>
RPBoolStructR> MATCH (CERR): Other "health insurance"
RPBoolStructR> ERROR:
RPBoolStructR> offset=23:
RPBoolStructR> unexpected UnDeeper
RPBoolStructR> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPMT                                                  :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slAKA                                             :3_4:Other "heal:
************************************** / $*|                                             :3_4:Other "heal:
*************************************** / slAKA base                                    :3_4:Other "heal:
**************************************** / slMultiTerm                                 :3_4:Other "heal:
***************************************** / someSL                                    :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

***************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

**************************************** \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
slAKA base> IN: Other "health insurance" UnDeeper UnDeep <…>
slAKA base> MATCH (COK): Other "health insurance"
slAKA base> VALUE: ((["health insurance"],0),[])

*************************************** \ slAKA base has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************** \ $*| has returned (["health insurance"],0)    :4_2:UnDeeper:
************************************** / |>>/recurse                                  :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                     :4_2:UnDeeper:
*************************************** / slAKA optional akapart                     :4_2:UnDeeper:
**************************************** / |?| optional something                   :4_2:UnDeeper:
***************************************** / |>>/recurse                            :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

***************************************** / |>>/base                               :4_2:UnDeeper:
****************************************** / PAKA/akapart                         :4_2:UnDeeper:
******************************************* / $>|                                :4_2:UnDeeper:
******************************************** / Aka Token                        :4_2:UnDeeper:
Aka Token> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
Aka Token> MATCH (EERR): <EMPTY>
Aka Token> ERROR:
Aka Token> offset=23:
Aka Token> unexpected UnDeeper
Aka Token> expecting Aka

$>|> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=23:
$>|> unexpected UnDeeper
$>|> expecting Aka

PAKA/akapart> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
PAKA/akapart> MATCH (EERR): <EMPTY>
PAKA/akapart> ERROR:
PAKA/akapart> offset=23:
PAKA/akapart> unexpected UnDeeper
PAKA/akapart> expecting Aka

|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Aka

|?| optional something> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

**************************************** \ |?| optional something has returned (Nothing,0) :4_2:UnDeeper:
slAKA optional akapart> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
slAKA optional akapart> MATCH (EOK): <EMPTY>
slAKA optional akapart> VALUE: ((Nothing,0),[])

*************************************** \ slAKA optional akapart has returned (Nothing,0) :4_2:UnDeeper:
*************************************** > |>>/base got Nothing                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************************************** \ |>>/base has returned (Nothing,0)            :4_2:UnDeeper:
************************************** / |>>/recurse                                  :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                     :4_2:UnDeeper:
*************************************** / slAKA optional typically                   :4_2:UnDeeper:
**************************************** / |?| optional something                   :4_2:UnDeeper:
***************************************** / |>>/recurse                            :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

***************************************** / |>>/base                               :4_2:UnDeeper:
****************************************** / typically                            :4_2:UnDeeper:
******************************************* / $>|                                :4_2:UnDeeper:
$>|> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=23:
$>|> unexpected UnDeeper
$>|> expecting Typically

typically> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
typically> MATCH (EERR): <EMPTY>
typically> ERROR:
typically> offset=23:
typically> unexpected UnDeeper
typically> expecting Typically

|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Typically

|?| optional something> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

**************************************** \ |?| optional something has returned (Nothing,0) :4_2:UnDeeper:
slAKA optional typically> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
slAKA optional typically> MATCH (EOK): <EMPTY>
slAKA optional typically> VALUE: ((Nothing,0),[])

*************************************** \ slAKA optional typically has returned (Nothing,0) :4_2:UnDeeper:
*************************************** > |>>/base got Nothing                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************************************** \ |>>/base has returned (Nothing,0)            :4_2:UnDeeper:
************************************** > slAKA: proceeding after base and entityalias are retrieved ... :4_2:UnDeeper:
************************************** > pAKA: entityalias = Nothing                  :4_2:UnDeeper:
slAKA> IN: Other "health insurance" UnDeeper UnDeep <…>
slAKA> MATCH (COK): Other "health insurance"
slAKA> VALUE: ((["health insurance"],0),[])

************************************* \ slAKA has returned (["health insurance"],0)    :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
RPMT> IN: Other "health insurance" UnDeeper UnDeep <…>
RPMT> MATCH (COK): Other "health insurance"
RPMT> VALUE: ((RPMT ["health insurance"],0),[])

*********************************** \ RPMT has returned (RPMT ["health insurance"],0)    :4_2:UnDeeper:
slRelPred> IN: Other "health insurance" UnDeeper UnDeep <…>
slRelPred> MATCH (COK): Other "health insurance"
slRelPred> VALUE: ((RPMT ["health insurance"],0),[])

********************************** \ slRelPred has returned (RPMT ["health insurance"],0) :4_2:UnDeeper:
********************************** / undeepers                                            :4_2:UnDeeper:
*********************************** > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers :4_2:UnDeeper:
*********************************** > sameLine: success!                                 :4_2:UnDeeper:
undeepers> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

********************************** \ undeepers has returned ()                            :4_2:UnDeeper:
pRelPred> IN: Other "health insurance" UnDeeper UnDeep <…>
pRelPred> MATCH (COK): Other "health insurance"
pRelPred> VALUE: (RPMT ["health insurance"],[])

********************************* \ pRelPred has returned RPMT ["health insurance"]        :4_2:UnDeeper:
term p/3:plain p> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/3:plain p> MATCH (COK): Other "health insurance"
term p/3:plain p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

******************************** \ term p/3:plain p has returned MyLeaf (RPMT ["health insurance"]) :4_2:UnDeeper:
term p/notLabelTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/notLabelTerm> MATCH (COK): Other "health insurance"
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

******************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["health insurance"]) :4_2:UnDeeper:
term p> IN: Other "health insurance" UnDeeper UnDeep <…>
term p> MATCH (COK): Other "health insurance"
term p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

****************************** \ term p has returned MyLeaf (RPMT ["health insurance"])       :4_2:UnDeeper:
****************************** / binary(Or)                                                   :4_2:UnDeeper:
binary(Or)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=23:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

****************************** / binary(And)                                                  :4_2:UnDeeper:
binary(And)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=23:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

****************************** / binary(SetLess)                                              :4_2:UnDeeper:
binary(SetLess)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=23:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

****************************** / binary(SetPlus)                                              :4_2:UnDeeper:
binary(SetPlus)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=23:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "health insurance" UnDeeper UnDeep <…>
expression> MATCH (COK): Other "health insurance"
expression> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

***************************** \ expression has returned MyLeaf (RPMT ["health insurance"])     :4_2:UnDeeper:
manyIndentation/leaf?> IN: Other "health insurance" UnDeeper UnDeep <…>
manyIndentation/leaf?> MATCH (COK): Other "health insurance"
manyIndentation/leaf?> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

**************************** \ manyIndentation/leaf? has returned MyLeaf (RPMT ["health insurance"]) :4_2:UnDeeper:
**************************** / myindented: consuming UnDeeper                                   :4_2:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

**************************** \ myindented: consuming UnDeeper has returned UnDeeper               :4_3:UnDeeper:
someIndentation> IN: GoDeeper Other "health insurance" UnDeep <…>
someIndentation> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
someIndentation> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

*************************** \ someIndentation has returned MyLeaf (RPMT ["health insurance"])      :4_3:UnDeeper:
term p/2:someIndentation expr p> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
term p/2:someIndentation expr p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

************************** \ term p/2:someIndentation expr p has returned MyLeaf (RPMT ["health insurance"]) :4_3:UnDeeper:
term p/notLabelTerm> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["health insurance"])      :4_3:UnDeeper:
term p> IN: GoDeeper Other "health insurance" UnDeep <…>
term p> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
term p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

************************ \ term p has returned MyLeaf (RPMT ["health insurance"])                     :4_3:UnDeeper:
************************ / binary(Or)                                                                 :4_3:UnDeeper:
binary(Or)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=24:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

************************ / binary(And)                                                                :4_3:UnDeeper:
binary(And)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=24:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

************************ / binary(SetLess)                                                            :4_3:UnDeeper:
binary(SetLess)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=24:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

************************ / binary(SetPlus)                                                            :4_3:UnDeeper:
binary(SetPlus)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=24:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "has" GoDeeper Other "health insur <…>
expression> MATCH (COK): Other "has" GoDeeper Other "health insur <…>
expression> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

*********************** \ expression has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])) :4_3:UnDeeper:
manyIndentation/leaf?> IN: Other "has" GoDeeper Other "health insur <…>
manyIndentation/leaf?> MATCH (COK): Other "has" GoDeeper Other "health insur <…>
manyIndentation/leaf?> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

********************** \ manyIndentation/leaf? has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])) :4_3:UnDeeper:
********************** / myindented: consuming UnDeeper                                                 :4_3:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

********************** \ myindented: consuming UnDeeper has returned UnDeeper                             :4_4:UnDeeper:
someIndentation> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
someIndentation> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
someIndentation> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

********************* \ someIndentation has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))  :4_4:UnDeeper:
term p/2:someIndentation expr p> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
term p/2:someIndentation expr p> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

******************** \ term p/2:someIndentation expr p has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])) :4_4:UnDeeper:
term p/notLabelTerm> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
term p/notLabelTerm> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

******************* \ term p/notLabelTerm has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))  :4_4:UnDeeper:
term p> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
term p> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

****************** \ term p has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))                 :4_4:UnDeeper:
****************** / binary(Or)                                                                               :4_4:UnDeeper:
binary(Or)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=25:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

****************** / binary(And)                                                                              :4_4:UnDeeper:
binary(And)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=25:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

****************** / binary(SetLess)                                                                          :4_4:UnDeeper:
binary(SetLess)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=25:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

****************** / binary(SetPlus)                                                                          :4_4:UnDeeper:
binary(SetPlus)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=25:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
expression> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
expression> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

***************** \ expression has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_4:UnDeeper:
manyIndentation/leaf?> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
manyIndentation/leaf?> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
manyIndentation/leaf?> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

**************** \ manyIndentation/leaf? has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_4:UnDeeper:
**************** / myindented: consuming UnDeeper                                                               :4_4:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

**************** \ myindented: consuming UnDeeper has returned UnDeeper                                  :4_1:May:
someIndentation> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someIndentation> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someIndentation> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*************** \ someIndentation has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
term p/2:someIndentation expr p> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/2:someIndentation expr p> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************** \ term p/2:someIndentation expr p has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
term p/notLabelTerm> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/notLabelTerm> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/notLabelTerm> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************* \ term p/notLabelTerm has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
term p> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************ \ term p has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
************ / binary(Or)                                                                                    :4_1:May:
binary(Or)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=26:
binary(Or)> unexpected May
binary(Or)> expecting Or

************ / binary(And)                                                                                   :4_1:May:
binary(And)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=26:
binary(And)> unexpected May
binary(And)> expecting And

************ / binary(SetLess)                                                                               :4_1:May:
binary(SetLess)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=26:
binary(SetLess)> unexpected May
binary(SetLess)> expecting SetLess

************ / binary(SetPlus)                                                                               :4_1:May:
binary(SetPlus)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=26:
binary(SetPlus)> unexpected May
binary(SetPlus)> expecting SetPlus

expression> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
expression> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
expression> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*********** \ expression has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
ppp inner> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
ppp inner> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
ppp inner> VALUE: (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********** \ ppp inner has returned Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])] :4_1:May:
pBSR> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pBSR> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pBSR> VALUE: (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********* \ pBSR has returned Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])] :4_1:May:
preambleBoolStructR [Who,Which,Whose]> IN: Who GoDeeper GoDeeper Other "is" GoDeepe <…>
preambleBoolStructR [Who,Which,Whose]> MATCH (COK): Who GoDeeper GoDeeper Other "is" GoDeepe <…>
preambleBoolStructR [Who,Which,Whose]> VALUE: ((Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******** \ preambleBoolStructR [Who,Which,Whose] has returned (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]) :4_1:May:
manyIndentation/leaf?> IN: Who GoDeeper GoDeeper Other "is" GoDeepe <…>
manyIndentation/leaf?> MATCH (COK): Who GoDeeper GoDeeper Other "is" GoDeepe <…>
manyIndentation/leaf?> VALUE: ((Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******* \ manyIndentation/leaf? has returned (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]) :4_1:May:
******* / WHERE                                                                                                   :4_1:May:
WHERE> IN: May GoDeeper Other "sharpen knives" UnDe <…>
WHERE> MATCH (EERR): <EMPTY>
WHERE> ERROR:
WHERE> offset=26:
WHERE> unexpected May
WHERE> expecting Where

******* / preambleParamText:[Having]                                                                              :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=26:
$>|> unexpected May
$>|> expecting Having

preambleParamText:[Having]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleParamText:[Having]> MATCH (EERR): <EMPTY>
preambleParamText:[Having]> ERROR:
preambleParamText:[Having]> offset=26:
preambleParamText:[Having]> unexpected May
preambleParamText:[Having]> expecting Having

******* / preambleParamText:[Given]                                                                               :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=26:
$>|> unexpected May
$>|> expecting Given

preambleParamText:[Given]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=26:
preambleParamText:[Given]> unexpected May
preambleParamText:[Given]> expecting Given

******* / preambleParamText:[Upon]                                                                                :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=26:
$>|> unexpected May
$>|> expecting Upon

preambleParamText:[Upon]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=26:
preambleParamText:[Upon]> unexpected May
preambleParamText:[Upon]> expecting Upon

******* / preambleBoolStructR [Unless]                                                                            :4_1:May:
preambleBoolStructR [Unless]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleBoolStructR [Unless]> MATCH (EERR): <EMPTY>
preambleBoolStructR [Unless]> ERROR:
preambleBoolStructR [Unless]> offset=26:
preambleBoolStructR [Unless]> unexpected May
preambleBoolStructR [Unless]> expecting Unless

******* / preambleBoolStructR [When,If]                                                                           :4_1:May:
preambleBoolStructR [When,If]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleBoolStructR [When,If]> MATCH (EERR): <EMPTY>
preambleBoolStructR [When,If]> ERROR:
preambleBoolStructR [When,If]> offset=26:
preambleBoolStructR [When,If]> unexpected May
preambleBoolStructR [When,If]> expecting If or When

******* / pTemporal/eventually                                                                                    :4_1:May:
pTemporal/eventually> IN: May GoDeeper Other "sharpen knives" UnDe <…>
pTemporal/eventually> MATCH (EERR): <EMPTY>
pTemporal/eventually> ERROR:
pTemporal/eventually> offset=26:
pTemporal/eventually> unexpected May
pTemporal/eventually> expecting Eventually

******* / pTemporal/specifically                                                                                  :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=26:
$>|> unexpected May
$>|> expecting After, Before, By, or On

pTemporal/specifically> IN: May GoDeeper Other "sharpen knives" UnDe <…>
pTemporal/specifically> MATCH (EERR): <EMPTY>
pTemporal/specifically> ERROR:
pTemporal/specifically> offset=26:
pTemporal/specifically> unexpected May
pTemporal/specifically> expecting After, Before, By, or On

******* / pTemporal/vaguely                                                                                       :4_1:May:
pTemporal/vaguely> IN: May GoDeeper Other "sharpen knives" UnDe <…>
pTemporal/vaguely> MATCH (EERR): <EMPTY>
pTemporal/vaguely> ERROR:
pTemporal/vaguely> offset=26:
pTemporal/vaguely> unexpected May
pTemporal/vaguely> expecting Other text

******* / pDA                                                                                                     :4_1:May:
******** / pAction calling dBoolStructP                                                                           :4_2:GoDeeper:
********* / dBoolStructP calling exprP                                                                           :4_2:GoDeeper:
********** / expr pParamText                                                                                    :4_2:GoDeeper:
*********** / expression                                                                                       :4_2:GoDeeper:
************ / labelPrefix                                                                                    :4_2:GoDeeper:
labelPrefix> IN: GoDeeper Other "sharpen knives" UnDeeper
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=27:
labelPrefix> unexpected GoDeeper
labelPrefix> expecting Other text

************ / term p                                                                                         :4_2:GoDeeper:
************* / term p/1a:label directly above                                                               :4_2:GoDeeper:
************** / $*|                                                                                        :4_2:GoDeeper:
*************** / someSL                                                                                   :4_2:GoDeeper:
**************** / pNumAsText                                                                             :4_2:GoDeeper:
pNumAsText> IN: GoDeeper Other "sharpen knives" UnDeeper
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=27:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "sharpen knives" UnDeeper
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=27:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "sharpen knives" UnDeeper
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=27:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "sharpen knives" UnDeeper
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=27:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

************* / term p/b:label to the left of line below, with EOL                                           :4_2:GoDeeper:
************** / someSL                                                                                     :4_2:GoDeeper:
*************** / pNumAsText                                                                               :4_2:GoDeeper:
pNumAsText> IN: GoDeeper Other "sharpen knives" UnDeeper
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=27:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "sharpen knives" UnDeeper
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=27:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "sharpen knives" UnDeeper
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=27:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

************* / term p/notLabelTerm                                                                          :4_2:GoDeeper:
************** / term p/2:someIndentation expr p                                                            :4_2:GoDeeper:
*************** / someIndentation                                                                          :4_2:GoDeeper:
**************** / myindented: consuming GoDeeper                                                         :4_2:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "sharpen knives" UnDeeper
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

**************** \ myindented: consuming GoDeeper has returned GoDeeper                                    :4_2:Other "shar:
**************** / manyIndentation/leaf?                                                                   :4_2:Other "shar:
***************** / expression                                                                            :4_2:Other "shar:
****************** / labelPrefix                                                                         :4_2:Other "shar:
labelPrefix> IN: Other "sharpen knives" UnDeeper
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=29:
labelPrefix> unexpected UnDeeper

****************** / term p                                                                              :4_2:Other "shar:
******************* / term p/1a:label directly above                                                    :4_2:Other "shar:
******************** / $*|                                                                             :4_2:Other "shar:
********************* / someSL                                                                        :4_2:Other "shar:
someSL> IN: Other "sharpen knives" UnDeeper
someSL> MATCH (COK): Other "sharpen knives"
someSL> VALUE: ((["sharpen knives"],0),[])

********************* \ someSL has returned (["sharpen knives"],0)                                     :1_2:UnDeeper:
********************* / pNumAsText                                                                     :1_2:UnDeeper:
pNumAsText> IN: UnDeeper
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=29:
pNumAsText> unexpected UnDeeper
pNumAsText> expecting number

$*|> IN: Other "sharpen knives" UnDeeper
$*|> MATCH (CERR): Other "sharpen knives"
$*|> ERROR:
$*|> offset=29:
$*|> unexpected UnDeeper
$*|> expecting GoDeeper or other text or number

term p/1a:label directly above> IN: Other "sharpen knives" UnDeeper
term p/1a:label directly above> MATCH (CERR): Other "sharpen knives"
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=29:
term p/1a:label directly above> unexpected UnDeeper
term p/1a:label directly above> expecting GoDeeper or other text or number

******************* / term p/b:label to the left of line below, with EOL                                :4_2:Other "shar:
******************** / someSL                                                                          :4_2:Other "shar:
someSL> IN: Other "sharpen knives" UnDeeper
someSL> MATCH (COK): Other "sharpen knives"
someSL> VALUE: ((["sharpen knives"],0),[])

******************** \ someSL has returned (["sharpen knives"],0)                                       :1_2:UnDeeper:
******************** / undeepers                                                                        :1_2:UnDeeper:
********************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers         :1_2:UnDeeper:
********************* > sameLine: success!                                                             :1_2:UnDeeper:
undeepers> IN: UnDeeper
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

******************** \ undeepers has returned ()                                                        :1_2:UnDeeper:
******************** / matching EOL                                                                     :1_2:UnDeeper:
matching EOL> IN: UnDeeper
matching EOL> MATCH (EERR): <EMPTY>
matching EOL> ERROR:
matching EOL> offset=29:
matching EOL> unexpected UnDeeper
matching EOL> expecting EOL

term p/b:label to the left of line below, with EOL> IN: Other "sharpen knives" UnDeeper
term p/b:label to the left of line below, with EOL> MATCH (CERR): Other "sharpen knives"
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=29:
term p/b:label to the left of line below, with EOL> unexpected UnDeeper
term p/b:label to the left of line below, with EOL> expecting EOL or GoDeeper

******************* / term p/notLabelTerm                                                               :4_2:Other "shar:
******************** / term p/2:someIndentation expr p                                                 :4_2:Other "shar:
********************* / someIndentation                                                               :4_2:Other "shar:
********************** / myindented: consuming GoDeeper                                              :4_2:Other "shar:
myindented: consuming GoDeeper> IN: Other "sharpen knives" UnDeeper
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=28:
myindented: consuming GoDeeper> unexpected Other "sharpen knives"
myindented: consuming GoDeeper> expecting GoDeeper

someIndentation> IN: Other "sharpen knives" UnDeeper
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=28:
someIndentation> unexpected Other "sharpen knives"
someIndentation> expecting GoDeeper

term p/2:someIndentation expr p> IN: Other "sharpen knives" UnDeeper
term p/2:someIndentation expr p> MATCH (EERR): <EMPTY>
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=28:
term p/2:someIndentation expr p> unexpected Other "sharpen knives"
term p/2:someIndentation expr p> expecting GoDeeper

******************** / term p/3:plain p                                                                :4_2:Other "shar:
********************* / pParamText                                                                    :4_2:Other "shar:
********************** / pParamText(flat) first line: pKeyValues                                     :4_2:Other "shar:
*********************** / pKeyValuesAka                                                             :4_2:Other "shar:
************************ / slAKA                                                                   :4_2:Other "shar:
************************* / $*|                                                                   :4_2:Other "shar:
************************** / slAKA base                                                          :4_2:Other "shar:
*************************** / slKeyValues                                                       :4_2:Other "shar:
**************************** / $*|                                                             :4_2:Other "shar:
***************************** / someSL                                                        :4_2:Other "shar:
someSL> IN: Other "sharpen knives" UnDeeper
someSL> MATCH (COK): Other "sharpen knives"
someSL> VALUE: ((["sharpen knives"],0),[])

***************************** \ someSL has returned (["sharpen knives"],0)                     :1_2:UnDeeper:
$*|> IN: Other "sharpen knives" UnDeeper
$*|> MATCH (COK): Other "sharpen knives"
$*|> VALUE: ((["sharpen knives"],0),[])

**************************** \ $*| has returned (["sharpen knives"],0)                          :1_2:UnDeeper:
**************************** / |>>/recurse                                                      :1_2:UnDeeper:
|>>/recurse> IN: UnDeeper
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=29:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

**************************** / |>>/base                                                         :1_2:UnDeeper:
***************************** / |?| optional something                                         :1_2:UnDeeper:
****************************** / |>>/recurse                                                  :1_2:UnDeeper:
|>>/recurse> IN: UnDeeper
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=29:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

****************************** / |>>/base                                                     :1_2:UnDeeper:
******************************* / slTypeSig                                                  :1_2:UnDeeper:
******************************** / $>|                                                      :1_2:UnDeeper:
$>|> IN: UnDeeper
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=29:
$>|> unexpected UnDeeper
$>|> expecting Is or TypeSeparator

slTypeSig> IN: UnDeeper
slTypeSig> MATCH (EERR): <EMPTY>
slTypeSig> ERROR:
slTypeSig> offset=29:
slTypeSig> unexpected UnDeeper
slTypeSig> expecting Is or TypeSeparator

|>>/base> IN: UnDeeper
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=29:
|>>/base> unexpected UnDeeper
|>>/base> expecting Is or TypeSeparator

|?| optional something> IN: UnDeeper
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

***************************** \ |?| optional something has returned (Nothing,0)                :1_2:UnDeeper:
***************************** > |>>/base got Nothing                                           :1_2:UnDeeper:
|>>/base> IN: UnDeeper
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

**************************** \ |>>/base has returned (Nothing,0)                                :1_2:UnDeeper:
slKeyValues> IN: Other "sharpen knives" UnDeeper
slKeyValues> MATCH (COK): Other "sharpen knives"
slKeyValues> VALUE: ((("sharpen knives" :| [],Nothing),0),[])

*************************** \ slKeyValues has returned (("sharpen knives" :| [],Nothing),0)      :1_2:UnDeeper:
slAKA base> IN: Other "sharpen knives" UnDeeper
slAKA base> MATCH (COK): Other "sharpen knives"
slAKA base> VALUE: ((("sharpen knives" :| [],Nothing),0),[])

************************** \ slAKA base has returned (("sharpen knives" :| [],Nothing),0)         :1_2:UnDeeper:
$*|> IN: Other "sharpen knives" UnDeeper
$*|> MATCH (COK): Other "sharpen knives"
$*|> VALUE: ((("sharpen knives" :| [],Nothing),0),[])

************************* \ $*| has returned (("sharpen knives" :| [],Nothing),0)                  :1_2:UnDeeper:
************************* / |>>/recurse                                                            :1_2:UnDeeper:
|>>/recurse> IN: UnDeeper
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=29:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************* / |>>/base                                                               :1_2:UnDeeper:
************************** / slAKA optional akapart                                               :1_2:UnDeeper:
*************************** / |?| optional something                                             :1_2:UnDeeper:
**************************** / |>>/recurse                                                      :1_2:UnDeeper:
|>>/recurse> IN: UnDeeper
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=29:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

**************************** / |>>/base                                                         :1_2:UnDeeper:
***************************** / PAKA/akapart                                                   :1_2:UnDeeper:
****************************** / $>|                                                          :1_2:UnDeeper:
******************************* / Aka Token                                                  :1_2:UnDeeper:
Aka Token> IN: UnDeeper
Aka Token> MATCH (EERR): <EMPTY>
Aka Token> ERROR:
Aka Token> offset=29:
Aka Token> unexpected UnDeeper
Aka Token> expecting Aka

$>|> IN: UnDeeper
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=29:
$>|> unexpected UnDeeper
$>|> expecting Aka

PAKA/akapart> IN: UnDeeper
PAKA/akapart> MATCH (EERR): <EMPTY>
PAKA/akapart> ERROR:
PAKA/akapart> offset=29:
PAKA/akapart> unexpected UnDeeper
PAKA/akapart> expecting Aka

|>>/base> IN: UnDeeper
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=29:
|>>/base> unexpected UnDeeper
|>>/base> expecting Aka

|?| optional something> IN: UnDeeper
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

*************************** \ |?| optional something has returned (Nothing,0)                    :1_2:UnDeeper:
slAKA optional akapart> IN: UnDeeper
slAKA optional akapart> MATCH (EOK): <EMPTY>
slAKA optional akapart> VALUE: ((Nothing,0),[])

************************** \ slAKA optional akapart has returned (Nothing,0)                      :1_2:UnDeeper:
************************** > |>>/base got Nothing                                                 :1_2:UnDeeper:
|>>/base> IN: UnDeeper
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************************* \ |>>/base has returned (Nothing,0)                                      :1_2:UnDeeper:
************************* / |>>/recurse                                                            :1_2:UnDeeper:
|>>/recurse> IN: UnDeeper
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=29:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************* / |>>/base                                                               :1_2:UnDeeper:
************************** / slAKA optional typically                                             :1_2:UnDeeper:
*************************** / |?| optional something                                             :1_2:UnDeeper:
**************************** / |>>/recurse                                                      :1_2:UnDeeper:
|>>/recurse> IN: UnDeeper
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=29:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

**************************** / |>>/base                                                         :1_2:UnDeeper:
***************************** / typically                                                      :1_2:UnDeeper:
****************************** / $>|                                                          :1_2:UnDeeper:
$>|> IN: UnDeeper
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=29:
$>|> unexpected UnDeeper
$>|> expecting Typically

typically> IN: UnDeeper
typically> MATCH (EERR): <EMPTY>
typically> ERROR:
typically> offset=29:
typically> unexpected UnDeeper
typically> expecting Typically

|>>/base> IN: UnDeeper
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=29:
|>>/base> unexpected UnDeeper
|>>/base> expecting Typically

|?| optional something> IN: UnDeeper
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

*************************** \ |?| optional something has returned (Nothing,0)                    :1_2:UnDeeper:
slAKA optional typically> IN: UnDeeper
slAKA optional typically> MATCH (EOK): <EMPTY>
slAKA optional typically> VALUE: ((Nothing,0),[])

************************** \ slAKA optional typically has returned (Nothing,0)                    :1_2:UnDeeper:
************************** > |>>/base got Nothing                                                 :1_2:UnDeeper:
|>>/base> IN: UnDeeper
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************************* \ |>>/base has returned (Nothing,0)                                      :1_2:UnDeeper:
************************* > slAKA: proceeding after base and entityalias are retrieved ...         :1_2:UnDeeper:
************************* > pAKA: entityalias = Nothing                                            :1_2:UnDeeper:
slAKA> IN: Other "sharpen knives" UnDeeper
slAKA> MATCH (COK): Other "sharpen knives"
slAKA> VALUE: ((("sharpen knives" :| [],Nothing),0),[])

************************ \ slAKA has returned (("sharpen knives" :| [],Nothing),0)                  :1_2:UnDeeper:
************************ / undeepers                                                                :1_2:UnDeeper:
************************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers :1_2:UnDeeper:
************************* > sameLine: success!                                                     :1_2:UnDeeper:
undeepers> IN: UnDeeper
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

************************ \ undeepers has returned ()                                                :1_2:UnDeeper:
pKeyValuesAka> IN: Other "sharpen knives" UnDeeper
pKeyValuesAka> MATCH (COK): Other "sharpen knives"
pKeyValuesAka> VALUE: (("sharpen knives" :| [],Nothing),[])

*********************** \ pKeyValuesAka has returned ("sharpen knives" :| [],Nothing)                :1_2:UnDeeper:
pParamText(flat) first line: pKeyValues> IN: Other "sharpen knives" UnDeeper
pParamText(flat) first line: pKeyValues> MATCH (COK): Other "sharpen knives"
pParamText(flat) first line: pKeyValues> VALUE: (("sharpen knives" :| [],Nothing),[])

********************** \ pParamText(flat) first line: pKeyValues has returned ("sharpen knives" :| [],Nothing) :1_2:UnDeeper:
********************** / pParamText(flat) subsequent lines: sameMany pKeyValues                       :1_2:UnDeeper:
*********************** / manyIndentation/leaf?                                                      :1_2:UnDeeper:
************************ / sameMany                                                                 :1_2:UnDeeper:
************************* / pKeyValuesAka                                                          :1_2:UnDeeper:
************************** / slAKA                                                                :1_2:UnDeeper:
*************************** / $*|                                                                :1_2:UnDeeper:
**************************** / slAKA base                                                       :1_2:UnDeeper:
***************************** / slKeyValues                                                    :1_2:UnDeeper:
****************************** / $*|                                                          :1_2:UnDeeper:
******************************* / someSL                                                     :1_2:UnDeeper:
******************************** / pNumAsText                                               :1_2:UnDeeper:
pNumAsText> IN: UnDeeper
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=29:
pNumAsText> unexpected UnDeeper
pNumAsText> expecting number

someSL> IN: UnDeeper
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=29:
someSL> unexpected UnDeeper
someSL> expecting other text or number

$*|> IN: UnDeeper
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=29:
$*|> unexpected UnDeeper
$*|> expecting other text or number

slKeyValues> IN: UnDeeper
slKeyValues> MATCH (EERR): <EMPTY>
slKeyValues> ERROR:
slKeyValues> offset=29:
slKeyValues> unexpected UnDeeper
slKeyValues> expecting other text or number

slAKA base> IN: UnDeeper
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=29:
slAKA base> unexpected UnDeeper
slAKA base> expecting other text or number

$*|> IN: UnDeeper
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=29:
$*|> unexpected UnDeeper
$*|> expecting other text or number

slAKA> IN: UnDeeper
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=29:
slAKA> unexpected UnDeeper
slAKA> expecting other text or number

pKeyValuesAka> IN: UnDeeper
pKeyValuesAka> MATCH (EERR): <EMPTY>
pKeyValuesAka> ERROR:
pKeyValuesAka> offset=29:
pKeyValuesAka> unexpected UnDeeper
pKeyValuesAka> expecting other text or number

sameMany> IN: UnDeeper
sameMany> MATCH (EOK): <EMPTY>
sameMany> VALUE: ([],[])

************************ \ sameMany has returned []                                                 :1_2:UnDeeper:
manyIndentation/leaf?> IN: UnDeeper
manyIndentation/leaf?> MATCH (EOK): <EMPTY>
manyIndentation/leaf?> VALUE: ([],[])

*********************** \ manyIndentation/leaf? has returned []                                      :1_2:UnDeeper:
pParamText(flat) subsequent lines: sameMany pKeyValues> IN: UnDeeper
pParamText(flat) subsequent lines: sameMany pKeyValues> MATCH (EOK): <EMPTY>
pParamText(flat) subsequent lines: sameMany pKeyValues> VALUE: ([],[])

********************** \ pParamText(flat) subsequent lines: sameMany pKeyValues has returned []       :1_2:UnDeeper:
pParamText> IN: Other "sharpen knives" UnDeeper
pParamText> MATCH (COK): Other "sharpen knives"
pParamText> VALUE: (("sharpen knives" :| [],Nothing) :| [],[])

********************* \ pParamText has returned ("sharpen knives" :| [],Nothing) :| []                 :1_2:UnDeeper:
term p/3:plain p> IN: Other "sharpen knives" UnDeeper
term p/3:plain p> MATCH (COK): Other "sharpen knives"
term p/3:plain p> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

******************** \ term p/3:plain p has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])    :1_2:UnDeeper:
term p/notLabelTerm> IN: Other "sharpen knives" UnDeeper
term p/notLabelTerm> MATCH (COK): Other "sharpen knives"
term p/notLabelTerm> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

******************* \ term p/notLabelTerm has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])   :1_2:UnDeeper:
term p> IN: Other "sharpen knives" UnDeeper
term p> MATCH (COK): Other "sharpen knives"
term p> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

****************** \ term p has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])                  :1_2:UnDeeper:
****************** / binary(Or)                                                                           :1_2:UnDeeper:
binary(Or)> IN: UnDeeper
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=29:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

****************** / binary(And)                                                                          :1_2:UnDeeper:
binary(And)> IN: UnDeeper
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=29:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

****************** / binary(SetLess)                                                                      :1_2:UnDeeper:
binary(SetLess)> IN: UnDeeper
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=29:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

****************** / binary(SetPlus)                                                                      :1_2:UnDeeper:
binary(SetPlus)> IN: UnDeeper
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=29:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "sharpen knives" UnDeeper
expression> MATCH (COK): Other "sharpen knives"
expression> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

***************** \ expression has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])                :1_2:UnDeeper:
manyIndentation/leaf?> IN: Other "sharpen knives" UnDeeper
manyIndentation/leaf?> MATCH (COK): Other "sharpen knives"
manyIndentation/leaf?> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

**************** \ manyIndentation/leaf? has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])       :1_2:UnDeeper:
**************** / myindented: consuming UnDeeper                                                           :1_2:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

**************** \ myindented: consuming UnDeeper has returned UnDeeper                                :EOF:
someIndentation> IN: GoDeeper Other "sharpen knives" UnDeeper
someIndentation> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
someIndentation> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

*************** \ someIndentation has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])          :EOF:
term p/2:someIndentation expr p> IN: GoDeeper Other "sharpen knives" UnDeeper
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
term p/2:someIndentation expr p> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

************** \ term p/2:someIndentation expr p has returned MyLeaf (("sharpen knives" :| [],Nothing) :| []) :EOF:
term p/notLabelTerm> IN: GoDeeper Other "sharpen knives" UnDeeper
term p/notLabelTerm> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
term p/notLabelTerm> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

************* \ term p/notLabelTerm has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])          :EOF:
term p> IN: GoDeeper Other "sharpen knives" UnDeeper
term p> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
term p> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

************ \ term p has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])                         :EOF:
************ / binary(Or)                                                                                  :EOF:
binary(Or)> IN: <EMPTY>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=30:
binary(Or)> unexpected end of input
binary(Or)> expecting Or

************ / binary(And)                                                                                 :EOF:
binary(And)> IN: <EMPTY>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=30:
binary(And)> unexpected end of input
binary(And)> expecting And

************ / binary(SetLess)                                                                             :EOF:
binary(SetLess)> IN: <EMPTY>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=30:
binary(SetLess)> unexpected end of input
binary(SetLess)> expecting SetLess

************ / binary(SetPlus)                                                                             :EOF:
binary(SetPlus)> IN: <EMPTY>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=30:
binary(SetPlus)> unexpected end of input
binary(SetPlus)> expecting SetPlus

expression> IN: GoDeeper Other "sharpen knives" UnDeeper
expression> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
expression> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

*********** \ expression has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])                       :EOF:
expr pParamText> IN: GoDeeper Other "sharpen knives" UnDeeper
expr pParamText> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
expr pParamText> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

********** \ expr pParamText has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])                    :EOF:
dBoolStructP calling exprP> IN: GoDeeper Other "sharpen knives" UnDeeper
dBoolStructP calling exprP> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
dBoolStructP calling exprP> VALUE: (Leaf (("sharpen knives" :| [],Nothing) :| []),[])

********* \ dBoolStructP calling exprP has returned Leaf (("sharpen knives" :| [],Nothing) :| [])             :EOF:
pAction calling dBoolStructP> IN: GoDeeper Other "sharpen knives" UnDeeper
pAction calling dBoolStructP> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
pAction calling dBoolStructP> VALUE: (Leaf (("sharpen knives" :| [],Nothing) :| []),[])

******** \ pAction calling dBoolStructP has returned Leaf (("sharpen knives" :| [],Nothing) :| [])             :EOF:
pDA> IN: May GoDeeper Other "sharpen knives" UnDe <…>
pDA> MATCH (COK): May GoDeeper Other "sharpen knives" UnDe <…>
pDA> VALUE: ((DMay,Leaf (("sharpen knives" :| [],Nothing) :| [])),[])

******* \ pDA has returned (DMay,Leaf (("sharpen knives" :| [],Nothing) :| []))                                 :EOF:
******* / WHERE                                                                                                 :EOF:
WHERE> IN: <EMPTY>
WHERE> MATCH (EERR): <EMPTY>
WHERE> ERROR:
WHERE> offset=30:
WHERE> unexpected end of input
WHERE> expecting Where

******* / preambleParamText:[Having]                                                                            :EOF:
******** / $>|                                                                                                 :EOF:
$>|> IN: <EMPTY>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=30:
$>|> unexpected end of input
$>|> expecting Having

preambleParamText:[Having]> IN: <EMPTY>
preambleParamText:[Having]> MATCH (EERR): <EMPTY>
preambleParamText:[Having]> ERROR:
preambleParamText:[Having]> offset=30:
preambleParamText:[Having]> unexpected end of input
preambleParamText:[Having]> expecting Having or any token

******* / preambleParamText:[Given]                                                                             :EOF:
******** / $>|                                                                                                 :EOF:
$>|> IN: <EMPTY>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=30:
$>|> unexpected end of input
$>|> expecting Given

preambleParamText:[Given]> IN: <EMPTY>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=30:
preambleParamText:[Given]> unexpected end of input
preambleParamText:[Given]> expecting Given or any token

******* / preambleParamText:[Upon]                                                                              :EOF:
******** / $>|                                                                                                 :EOF:
$>|> IN: <EMPTY>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=30:
$>|> unexpected end of input
$>|> expecting Upon

preambleParamText:[Upon]> IN: <EMPTY>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=30:
preambleParamText:[Upon]> unexpected end of input
preambleParamText:[Upon]> expecting Upon or any token

******* / preambleBoolStructR [Unless]                                                                          :EOF:
preambleBoolStructR [Unless]> IN: <EMPTY>
preambleBoolStructR [Unless]> MATCH (EERR): <EMPTY>
preambleBoolStructR [Unless]> ERROR:
preambleBoolStructR [Unless]> offset=30:
preambleBoolStructR [Unless]> unexpected end of input
preambleBoolStructR [Unless]> expecting Unless

******* / preambleBoolStructR [When,If]                                                                         :EOF:
preambleBoolStructR [When,If]> IN: <EMPTY>
preambleBoolStructR [When,If]> MATCH (EERR): <EMPTY>
preambleBoolStructR [When,If]> ERROR:
preambleBoolStructR [When,If]> offset=30:
preambleBoolStructR [When,If]> unexpected end of input
preambleBoolStructR [When,If]> expecting If or When

******* / pTemporal/eventually                                                                                  :EOF:
pTemporal/eventually> IN: <EMPTY>
pTemporal/eventually> MATCH (EERR): <EMPTY>
pTemporal/eventually> ERROR:
pTemporal/eventually> offset=30:
pTemporal/eventually> unexpected end of input
pTemporal/eventually> expecting Eventually

******* / pTemporal/specifically                                                                                :EOF:
******** / $>|                                                                                                 :EOF:
$>|> IN: <EMPTY>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=30:
$>|> unexpected end of input
$>|> expecting After, Before, By, or On

pTemporal/specifically> IN: <EMPTY>
pTemporal/specifically> MATCH (EERR): <EMPTY>
pTemporal/specifically> ERROR:
pTemporal/specifically> offset=30:
pTemporal/specifically> unexpected end of input
pTemporal/specifically> expecting After, Before, By, On, or any token

******* / pTemporal/vaguely                                                                                     :EOF:
pTemporal/vaguely> IN: <EMPTY>
pTemporal/vaguely> MATCH (EERR): <EMPTY>
pTemporal/vaguely> ERROR:
pTemporal/vaguely> offset=30:
pTemporal/vaguely> unexpected end of input
pTemporal/vaguely> expecting Other text

regulative permutation with deontic-action> IN: Every GoDeeper Other "person" UnDeeper W <…>
regulative permutation with deontic-action> MATCH (COK): Every GoDeeper Other "person" UnDeeper W <…>
regulative permutation with deontic-action> VALUE: (RuleBody {rbaction = Leaf (("sharpen knives" :| [],Nothing) :| []), rbpbrs = [], rbpbrneg = [], rbdeon = DMay, rbtemporal = Nothing, rbupon = [], rbgiven = [], rbhaving = Nothing, rbkeyname = (Every,Leaf (("person" :| [],Nothing) :| [])), rbwho = Just (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), rbwhere = []},[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

****** \ regulative permutation with deontic-action has returned RuleBody {rbaction = Leaf (("sharpen knives" :| [],Nothing) :| []), rbpbrs = [], rbpbrneg = [], rbdeon = DMay, rbtemporal = Nothing, rbupon = [], rbgiven = [], rbhaving = Nothing, rbkeyname = (Every,Leaf (("person" :| [],Nothing) :| [])), rbwho = Just (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), rbwhere = []} :EOF:
permutationsReg> IN: Every GoDeeper Other "person" UnDeeper W <…>
permutationsReg> MATCH (COK): Every GoDeeper Other "person" UnDeeper W <…>
permutationsReg> VALUE: (RuleBody {rbaction = Leaf (("sharpen knives" :| [],Nothing) :| []), rbpbrs = [], rbpbrneg = [], rbdeon = DMay, rbtemporal = Nothing, rbupon = [], rbgiven = [], rbhaving = Nothing, rbkeyname = (Every,Leaf (("person" :| [],Nothing) :| [])), rbwho = Just (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), rbwhere = []},[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

***** \ permutationsReg has returned RuleBody {rbaction = Leaf (("sharpen knives" :| [],Nothing) :| []), rbpbrs = [], rbpbrneg = [], rbdeon = DMay, rbtemporal = Nothing, rbupon = [], rbgiven = [], rbhaving = Nothing, rbkeyname = (Every,Leaf (("person" :| [],Nothing) :| [])), rbwho = Just (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), rbwhere = []} :EOF:
***** / pHenceLest-Hence                                                                                          :EOF:
pHenceLest-Hence> IN: <EMPTY>
pHenceLest-Hence> MATCH (EERR): <EMPTY>
pHenceLest-Hence> ERROR:
pHenceLest-Hence> offset=30:
pHenceLest-Hence> unexpected end of input
pHenceLest-Hence> expecting Hence

***** / pHenceLest-Lest                                                                                           :EOF:
pHenceLest-Lest> IN: <EMPTY>
pHenceLest-Lest> MATCH (EERR): <EMPTY>
pHenceLest-Lest> ERROR:
pHenceLest-Lest> offset=30:
pHenceLest-Lest> unexpected end of input
pHenceLest-Lest> expecting Lest

****   pRegRuleNormal: permutations returned rulebody RuleBody {rbaction = Leaf (("sharpen knives" :| [],Nothing) :| []), rbpbrs = [], rbpbrneg = [], rbdeon = DMay, rbtemporal = Nothing, rbupon = [], rbgiven = [], rbhaving = Nothing, rbkeyname = (Every,Leaf (("person" :| [],Nothing) :| [])), rbwho = Just (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), rbwhere = []} :EOF:
****   pRegRuleNormal: the positive preamble is Nothing                                                           :EOF:
****   pRegRuleNormal: the negative preamble is Nothing                                                           :EOF:
****   pRegRuleNormal: returning Regulative {subj = Leaf (("person" :| [],Nothing) :| []), keyword = Every, who = Just (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), cond = Nothing, deontic = DMay, action = Leaf (("sharpen knives" :| [],Nothing) :| []), temporal = Nothing, hence = Nothing, lest = Nothing, rlabel = Nothing, lsource = Nothing, srcref = Nothing, upon = Nothing, given = Nothing, having = Nothing, wwhere = [], defaults = [], symtab = []} :EOF:
pRegRuleNormal> IN: Every GoDeeper Other "person" UnDeeper W <…>
pRegRuleNormal> MATCH (COK): Every GoDeeper Other "person" UnDeeper W <…>
pRegRuleNormal> VALUE: (Regulative {subj = Leaf (("person" :| [],Nothing) :| []), keyword = Every, who = Just (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), cond = Nothing, deontic = DMay, action = Leaf (("sharpen knives" :| [],Nothing) :| []), temporal = Nothing, hence = Nothing, lest = Nothing, rlabel = Nothing, lsource = Nothing, srcref = Nothing, upon = Nothing, given = Nothing, having = Nothing, wwhere = [], defaults = [], symtab = []},[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

**** \ pRegRuleNormal has returned Regulative {subj = Leaf (("person" :| [],Nothing) :| []), keyword = Every, who = Just (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), cond = Nothing, deontic = DMay, action = Leaf (("sharpen knives" :| [],Nothing) :| []), temporal = Nothing, hence = Nothing, lest = Nothing, rlabel = Nothing, lsource = Nothing, srcref = Nothing, upon = Nothing, given = Nothing, having = Nothing, wwhere = [], defaults = [], symtab = []} :EOF:
pRegRule> IN: Every GoDeeper Other "person" UnDeeper W <…>
pRegRule> MATCH (COK): Every GoDeeper Other "person" UnDeeper W <…>
pRegRule> VALUE: (Regulative {subj = Leaf (("person" :| [],Nothing) :| []), keyword = Every, who = Just (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), cond = Nothing, deontic = DMay, action = Leaf (("sharpen knives" :| [],Nothing) :| []), temporal = Nothing, hence = Nothing, lest = Nothing, rlabel = Nothing, lsource = Nothing, srcref = Nothing, upon = Nothing, given = Nothing, having = Nothing, wwhere = [], defaults = [], symtab = []},[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*** \ pRegRule has returned Regulative {subj = Leaf (("person" :| [],Nothing) :| []), keyword = Every, who = Just (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), cond = Nothing, deontic = DMay, action = Leaf (("sharpen knives" :| [],Nothing) :| []), temporal = Nothing, hence = Nothing, lest = Nothing, rlabel = Nothing, lsource = Nothing, srcref = Nothing, upon = Nothing, given = Nothing, having = Nothing, wwhere = [], defaults = [], symtab = []} :EOF:
pRule> IN: Every GoDeeper Other "person" UnDeeper W <…>
pRule> MATCH (COK): Every GoDeeper Other "person" UnDeeper W <…>
pRule> VALUE: (Regulative {subj = Leaf (("person" :| [],Nothing) :| []), keyword = Every, who = Just (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), cond = Nothing, deontic = DMay, action = Leaf (("sharpen knives" :| [],Nothing) :| []), temporal = Nothing, hence = Nothing, lest = Nothing, rlabel = Nothing, lsource = Nothing, srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 1, srccol = 1, version = Nothing}), upon = Nothing, given = Nothing, having = Nothing, wwhere = [], defaults = [], symtab = []},[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

** \ pRule has returned Regulative {subj = Leaf (("person" :| [],Nothing) :| []), keyword = Every, who = Just (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), cond = Nothing, deontic = DMay, action = Leaf (("sharpen knives" :| [],Nothing) :| []), temporal = Nothing, hence = Nothing, lest = Nothing, rlabel = Nothing, lsource = Nothing, srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 1, srccol = 1, version = Nothing}), upon = Nothing, given = Nothing, having = Nothing, wwhere = [], defaults = [], symtab = []} :EOF:
[Every,GoDeeper,Other "person",UnDeeper,Who,GoDeeper,GoDeeper,Other "is",GoDeeper,Other "immortal",GoDeeper,Typically,GoDeeper,Other "false",UnDeeper,UnDeeper,UnDeeper,UnDeeper,Or,GoDeeper,Other "has",GoDeeper,Other "health insurance",UnDeeper,UnDeeper,UnDeeper,May,GoDeeper,Other "sharpen knives",UnDeeper]
** / pRule                                                                                                             :1_1:Every:
*** / pRegRule                                                                                                        :1_1:Every:
**** / pRuleLabel                                                                                                    :1_1:Every:
***** / $>|                                                                                                         :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting RuleMarker 1 "\167"

pRuleLabel> IN: Every GoDeeper Other "person" UnDeeper W <…>
pRuleLabel> MATCH (EERR): <EMPTY>
pRuleLabel> ERROR:
pRuleLabel> offset=0:
pRuleLabel> unexpected Every
pRuleLabel> expecting RuleMarker 1 "\167"

**** / pRegRuleSugary                                                                                                :1_1:Every:
***** / someDeep                                                                                                    :1_1:Every:
****** / someDeep first part calls base directly                                                                   :1_1:Every:
someDeep first part calls base directly> IN: Every GoDeeper Other "person" UnDeeper W <…>
someDeep first part calls base directly> MATCH (EERR): <EMPTY>
someDeep first part calls base directly> ERROR:
someDeep first part calls base directly> offset=0:
someDeep first part calls base directly> unexpected Every
someDeep first part calls base directly> expecting Other text

someDeep> IN: Every GoDeeper Other "person" UnDeeper W <…>
someDeep> MATCH (EERR): <EMPTY>
someDeep> ERROR:
someDeep> offset=0:
someDeep> unexpected Every
someDeep> expecting Other text

pRegRuleSugary> IN: Every GoDeeper Other "person" UnDeeper W <…>
pRegRuleSugary> MATCH (EERR): <EMPTY>
pRegRuleSugary> ERROR:
pRegRuleSugary> offset=0:
pRegRuleSugary> unexpected Every
pRegRuleSugary> expecting Other text

**** / pRegRuleNormal                                                                                                :1_1:Every:
***** / permutationsReg                                                                                             :1_1:Every:
****** / regulative permutation with deontic-temporal                                                              :1_1:Every:
******* / WHERE                                                                                                   :1_1:Every:
WHERE> IN: Every GoDeeper Other "person" UnDeeper W <…>
WHERE> MATCH (EERR): <EMPTY>
WHERE> ERROR:
WHERE> offset=0:
WHERE> unexpected Every
WHERE> expecting Where

******* / preambleParamText:[Having]                                                                              :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting Having

preambleParamText:[Having]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleParamText:[Having]> MATCH (EERR): <EMPTY>
preambleParamText:[Having]> ERROR:
preambleParamText:[Having]> offset=0:
preambleParamText:[Having]> unexpected Every
preambleParamText:[Having]> expecting Having

******* / preambleParamText:[Given]                                                                               :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting Given

preambleParamText:[Given]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=0:
preambleParamText:[Given]> unexpected Every
preambleParamText:[Given]> expecting Given

******* / preambleParamText:[Upon]                                                                                :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting Upon

preambleParamText:[Upon]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=0:
preambleParamText:[Upon]> unexpected Every
preambleParamText:[Upon]> expecting Upon

******* / preambleBoolStructR [Unless]                                                                            :1_1:Every:
preambleBoolStructR [Unless]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleBoolStructR [Unless]> MATCH (EERR): <EMPTY>
preambleBoolStructR [Unless]> ERROR:
preambleBoolStructR [Unless]> offset=0:
preambleBoolStructR [Unless]> unexpected Every
preambleBoolStructR [Unless]> expecting Unless

******* / preambleBoolStructR [When,If]                                                                           :1_1:Every:
preambleBoolStructR [When,If]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleBoolStructR [When,If]> MATCH (EERR): <EMPTY>
preambleBoolStructR [When,If]> ERROR:
preambleBoolStructR [When,If]> offset=0:
preambleBoolStructR [When,If]> unexpected Every
preambleBoolStructR [When,If]> expecting If or When

******* / pDT                                                                                                     :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting May, Must, or Shant

pDT> IN: Every GoDeeper Other "person" UnDeeper W <…>
pDT> MATCH (EERR): <EMPTY>
pDT> ERROR:
pDT> offset=0:
pDT> unexpected Every
pDT> expecting May, Must, or Shant

******* / pActor [Every,Party,TokAll]                                                                             :1_1:Every:
******** / someIndentation                                                                                        :1_2:GoDeeper:
********* / myindented: consuming GoDeeper                                                                       :1_2:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "person" UnDeeper Who GoD <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

********* \ myindented: consuming GoDeeper has returned GoDeeper                                                  :1_2:Other "pers:
********* / manyIndentation/leaf?                                                                                 :1_2:Other "pers:
********** / pMultiTermAka                                                                                       :1_2:Other "pers:
*********** / pAKA                                                                                              :1_2:Other "pers:
************ / slAKA                                                                                           :1_2:Other "pers:
************* / $*|                                                                                           :1_2:Other "pers:
************** / slAKA base                                                                                  :1_2:Other "pers:
*************** / slMultiTerm                                                                               :1_2:Other "pers:
**************** / someSL                                                                                  :1_2:Other "pers:
someSL> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
someSL> MATCH (COK): Other "person"
someSL> VALUE: ((["person"],0),[])

**************** \ someSL has returned (["person"],0)                                                       :2_2:UnDeeper:
slMultiTerm> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
slMultiTerm> MATCH (COK): Other "person"
slMultiTerm> VALUE: ((["person"],0),[])

*************** \ slMultiTerm has returned (["person"],0)                                                    :2_2:UnDeeper:
slAKA base> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
slAKA base> MATCH (COK): Other "person"
slAKA base> VALUE: ((["person"],0),[])

************** \ slAKA base has returned (["person"],0)                                                       :2_2:UnDeeper:
$*|> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
$*|> MATCH (COK): Other "person"
$*|> VALUE: ((["person"],0),[])

************* \ $*| has returned (["person"],0)                                                                :2_2:UnDeeper:
************* / |>>/recurse                                                                                    :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************* / |>>/base                                                                                       :2_2:UnDeeper:
************** / slAKA optional akapart                                                                       :2_2:UnDeeper:
*************** / |?| optional something                                                                     :2_2:UnDeeper:
**************** / |>>/recurse                                                                              :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

**************** / |>>/base                                                                                 :2_2:UnDeeper:
***************** / PAKA/akapart                                                                           :2_2:UnDeeper:
****************** / $>|                                                                                  :2_2:UnDeeper:
******************* / Aka Token                                                                          :2_2:UnDeeper:
Aka Token> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
Aka Token> MATCH (EERR): <EMPTY>
Aka Token> ERROR:
Aka Token> offset=3:
Aka Token> unexpected UnDeeper
Aka Token> expecting Aka

$>|> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=3:
$>|> unexpected UnDeeper
$>|> expecting Aka

PAKA/akapart> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
PAKA/akapart> MATCH (EERR): <EMPTY>
PAKA/akapart> ERROR:
PAKA/akapart> offset=3:
PAKA/akapart> unexpected UnDeeper
PAKA/akapart> expecting Aka

|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=3:
|>>/base> unexpected UnDeeper
|>>/base> expecting Aka

|?| optional something> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

*************** \ |?| optional something has returned (Nothing,0)                                            :2_2:UnDeeper:
slAKA optional akapart> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
slAKA optional akapart> MATCH (EOK): <EMPTY>
slAKA optional akapart> VALUE: ((Nothing,0),[])

************** \ slAKA optional akapart has returned (Nothing,0)                                              :2_2:UnDeeper:
************** > |>>/base got Nothing                                                                         :2_2:UnDeeper:
|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************* \ |>>/base has returned (Nothing,0)                                                              :2_2:UnDeeper:
************* / |>>/recurse                                                                                    :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************* / |>>/base                                                                                       :2_2:UnDeeper:
************** / slAKA optional typically                                                                     :2_2:UnDeeper:
*************** / |?| optional something                                                                     :2_2:UnDeeper:
**************** / |>>/recurse                                                                              :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

**************** / |>>/base                                                                                 :2_2:UnDeeper:
***************** / typically                                                                              :2_2:UnDeeper:
****************** / $>|                                                                                  :2_2:UnDeeper:
$>|> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=3:
$>|> unexpected UnDeeper
$>|> expecting Typically

typically> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
typically> MATCH (EERR): <EMPTY>
typically> ERROR:
typically> offset=3:
typically> unexpected UnDeeper
typically> expecting Typically

|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=3:
|>>/base> unexpected UnDeeper
|>>/base> expecting Typically

|?| optional something> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

*************** \ |?| optional something has returned (Nothing,0)                                            :2_2:UnDeeper:
slAKA optional typically> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
slAKA optional typically> MATCH (EOK): <EMPTY>
slAKA optional typically> VALUE: ((Nothing,0),[])

************** \ slAKA optional typically has returned (Nothing,0)                                            :2_2:UnDeeper:
************** > |>>/base got Nothing                                                                         :2_2:UnDeeper:
|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************* \ |>>/base has returned (Nothing,0)                                                              :2_2:UnDeeper:
************* > slAKA: proceeding after base and entityalias are retrieved ...                                 :2_2:UnDeeper:
************* > pAKA: entityalias = Nothing                                                                    :2_2:UnDeeper:
slAKA> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
slAKA> MATCH (COK): Other "person"
slAKA> VALUE: ((["person"],0),[])

************ \ slAKA has returned (["person"],0)                                                                :2_2:UnDeeper:
************ / undeepers                                                                                        :2_2:UnDeeper:
************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers                         :2_2:UnDeeper:
************* > sameLine: success!                                                                             :2_2:UnDeeper:
undeepers> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

************ \ undeepers has returned ()                                                                        :2_2:UnDeeper:
pAKA> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
pAKA> MATCH (COK): Other "person"
pAKA> VALUE: (["person"],[])

*********** \ pAKA has returned ["person"]                                                                       :2_2:UnDeeper:
pMultiTermAka> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
pMultiTermAka> MATCH (COK): Other "person"
pMultiTermAka> VALUE: (["person"],[])

********** \ pMultiTermAka has returned ["person"]                                                                :2_2:UnDeeper:
manyIndentation/leaf?> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
manyIndentation/leaf?> MATCH (COK): Other "person"
manyIndentation/leaf?> VALUE: (["person"],[])

********* \ manyIndentation/leaf? has returned ["person"]                                                          :2_2:UnDeeper:
********* / myindented: consuming UnDeeper                                                                         :2_2:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

********* \ myindented: consuming UnDeeper has returned UnDeeper                                                :2_1:Who:
someIndentation> IN: GoDeeper Other "person" UnDeeper Who GoD <…>
someIndentation> MATCH (COK): GoDeeper Other "person" UnDeeper
someIndentation> VALUE: (["person"],[])

******** \ someIndentation has returned ["person"]                                                               :2_1:Who:
pActor [Every,Party,TokAll]> IN: Every GoDeeper Other "person" UnDeeper W <…>
pActor [Every,Party,TokAll]> MATCH (COK): Every GoDeeper Other "person" UnDeeper
pActor [Every,Party,TokAll]> VALUE: ((Every,Leaf (("person" :| [],Nothing) :| [])),[])

******* \ pActor [Every,Party,TokAll] has returned (Every,Leaf (("person" :| [],Nothing) :| []))                  :2_1:Who:
******* / manyIndentation/leaf?                                                                                   :2_1:Who:
******** / preambleBoolStructR [Who,Which,Whose]                                                                 :2_1:Who:
********* / pBSR                                                                                                 :2_2:GoDeeper:
********** / ppp inner                                                                                          :2_2:GoDeeper:
*********** / expression                                                                                       :2_2:GoDeeper:
************ / labelPrefix                                                                                    :2_2:GoDeeper:
labelPrefix> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=5:
labelPrefix> unexpected GoDeeper
labelPrefix> expecting Other text

************ / term p                                                                                         :2_2:GoDeeper:
************* / term p/1a:label directly above                                                               :2_2:GoDeeper:
************** / $*|                                                                                        :2_2:GoDeeper:
*************** / someSL                                                                                   :2_2:GoDeeper:
**************** / pNumAsText                                                                             :2_2:GoDeeper:
pNumAsText> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=5:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=5:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=5:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=5:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

************* / term p/b:label to the left of line below, with EOL                                           :2_2:GoDeeper:
************** / someSL                                                                                     :2_2:GoDeeper:
*************** / pNumAsText                                                                               :2_2:GoDeeper:
pNumAsText> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=5:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=5:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=5:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

************* / term p/notLabelTerm                                                                          :2_2:GoDeeper:
************** / term p/2:someIndentation expr p                                                            :2_2:GoDeeper:
*************** / someIndentation                                                                          :2_2:GoDeeper:
**************** / myindented: consuming GoDeeper                                                         :2_2:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

**************** \ myindented: consuming GoDeeper has returned GoDeeper                                     :2_3:GoDeeper:
**************** / manyIndentation/leaf?                                                                    :2_3:GoDeeper:
***************** / expression                                                                             :2_3:GoDeeper:
****************** / labelPrefix                                                                          :2_3:GoDeeper:
labelPrefix> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=6:
labelPrefix> unexpected GoDeeper
labelPrefix> expecting Other text

****************** / term p                                                                               :2_3:GoDeeper:
******************* / term p/1a:label directly above                                                     :2_3:GoDeeper:
******************** / $*|                                                                              :2_3:GoDeeper:
********************* / someSL                                                                         :2_3:GoDeeper:
********************** / pNumAsText                                                                   :2_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=6:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=6:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=6:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=6:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

******************* / term p/b:label to the left of line below, with EOL                                 :2_3:GoDeeper:
******************** / someSL                                                                           :2_3:GoDeeper:
********************* / pNumAsText                                                                     :2_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=6:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=6:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=6:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

******************* / term p/notLabelTerm                                                                :2_3:GoDeeper:
******************** / term p/2:someIndentation expr p                                                  :2_3:GoDeeper:
********************* / someIndentation                                                                :2_3:GoDeeper:
********************** / myindented: consuming GoDeeper                                               :2_3:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

********************** \ myindented: consuming GoDeeper has returned GoDeeper                          :2_3:Other "is":
********************** / manyIndentation/leaf?                                                         :2_3:Other "is":
*********************** / expression                                                                  :2_3:Other "is":
************************ / labelPrefix                                                               :2_3:Other "is":
labelPrefix> IN: Other "is" GoDeeper Other "immortal" GoD <…>
labelPrefix> MATCH (COK): Other "is"
labelPrefix> VALUE: ("is",[])

************************ \ labelPrefix has returned "is"                                              :2_4:GoDeeper:
************************ / term p                                                                     :2_4:GoDeeper:
************************* / term p/1a:label directly above                                           :2_4:GoDeeper:
************************** / $*|                                                                    :2_4:GoDeeper:
*************************** / someSL                                                               :2_4:GoDeeper:
**************************** / pNumAsText                                                         :2_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=8:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=8:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=8:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=8:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

************************* / term p/b:label to the left of line below, with EOL                       :2_4:GoDeeper:
************************** / someSL                                                                 :2_4:GoDeeper:
*************************** / pNumAsText                                                           :2_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=8:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=8:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=8:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

************************* / term p/notLabelTerm                                                      :2_4:GoDeeper:
************************** / term p/2:someIndentation expr p                                        :2_4:GoDeeper:
*************************** / someIndentation                                                      :2_4:GoDeeper:
**************************** / myindented: consuming GoDeeper                                     :2_4:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

**************************** \ myindented: consuming GoDeeper has returned GoDeeper                :2_4:Other "immo:
**************************** / manyIndentation/leaf?                                               :2_4:Other "immo:
***************************** / expression                                                        :2_4:Other "immo:
****************************** / labelPrefix                                                     :2_4:Other "immo:
labelPrefix> IN: Other "immortal" GoDeeper Typically GoDe <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=10:
labelPrefix> unexpected GoDeeper

****************************** / term p                                                          :2_4:Other "immo:
******************************* / term p/1a:label directly above                                :2_4:Other "immo:
******************************** / $*|                                                         :2_4:Other "immo:
********************************* / someSL                                                    :2_4:Other "immo:
********************************** / pNumAsText                                                :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

********************************* \ someSL has returned (["immortal"],0)                       :2_5:GoDeeper:
********************************* / pNumAsText                                                 :2_5:GoDeeper:
pNumAsText> IN: GoDeeper Typically GoDeeper Other "false <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (CERR): Other "immortal"
$*|> ERROR:
$*|> offset=10:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/1a:label directly above> MATCH (CERR): Other "immortal"
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=10:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

******************************* / term p/b:label to the left of line below, with EOL            :2_4:Other "immo:
******************************** / someSL                                                      :2_4:Other "immo:
********************************* / pNumAsText                                                  :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

******************************** \ someSL has returned (["immortal"],0)                         :2_5:GoDeeper:
******************************** / undeepers                                                    :2_5:GoDeeper:
********************************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers :2_5:GoDeeper:
********************************* > sameLine: success!                                         :2_5:GoDeeper:
undeepers> IN: GoDeeper Typically GoDeeper Other "false <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

******************************** \ undeepers has returned ()                                    :2_5:GoDeeper:
******************************** / matching EOL                                                 :2_5:GoDeeper:
matching EOL> IN: GoDeeper Typically GoDeeper Other "false <…>
matching EOL> MATCH (EERR): <EMPTY>
matching EOL> ERROR:
matching EOL> offset=10:
matching EOL> unexpected GoDeeper
matching EOL> expecting EOL

term p/b:label to the left of line below, with EOL> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/b:label to the left of line below, with EOL> MATCH (CERR): Other "immortal"
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=10:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting EOL

******************************* / term p/notLabelTerm                                           :2_4:Other "immo:
******************************** / term p/2:someIndentation expr p                             :2_4:Other "immo:
********************************* / someIndentation                                           :2_4:Other "immo:
********************************** / myindented: consuming GoDeeper                          :2_4:Other "immo:
myindented: consuming GoDeeper> IN: Other "immortal" GoDeeper Typically GoDe <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=9:
myindented: consuming GoDeeper> unexpected Other "immortal"
myindented: consuming GoDeeper> expecting GoDeeper

someIndentation> IN: Other "immortal" GoDeeper Typically GoDe <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=9:
someIndentation> unexpected Other "immortal"
someIndentation> expecting GoDeeper

term p/2:someIndentation expr p> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/2:someIndentation expr p> MATCH (EERR): <EMPTY>
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=9:
term p/2:someIndentation expr p> unexpected Other "immortal"
term p/2:someIndentation expr p> expecting GoDeeper

******************************** / term p/3:plain p                                            :2_4:Other "immo:
********************************* / pRelPred                                                  :2_4:Other "immo:
********************************** / slRelPred                                               :2_4:Other "immo:
*********************************** / nested simpleHorn                                     :2_4:Other "immo:
************************************ > |^|                                                 :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slMultiTerm                                       :2_4:Other "immo:
************************************** / someSL                                          :2_4:Other "immo:
*************************************** / pNumAsText                                      :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

************************************** \ someSL has returned (["immortal"],0)             :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

************************************* \ slMultiTerm has returned (["immortal"],0)          :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************ \ $*| has returned (["immortal"],0)                    :2_5:GoDeeper:
************************************ / |^| deeps                                            :2_5:GoDeeper:
|^| deeps> IN: GoDeeper Typically GoDeeper Other "false <…>
|^| deeps> MATCH (COK): GoDeeper
|^| deeps> VALUE: (([()],1),[])

************************************ \ |^| deeps has returned ([()],1)                       :2_5:Typically:
nested simpleHorn> IN: Other "immortal" GoDeeper Typically GoDe <…>
nested simpleHorn> MATCH (CERR): Other "immortal" GoDeeper
nested simpleHorn> ERROR:
nested simpleHorn> offset=11:
nested simpleHorn> unexpected Typically
nested simpleHorn> expecting GoDeeper or Means

*********************************** / RPConstraint                                          :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slMultiTerm                                       :2_4:Other "immo:
************************************** / someSL                                          :2_4:Other "immo:
*************************************** / pNumAsText                                      :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

************************************** \ someSL has returned (["immortal"],0)             :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

************************************* \ slMultiTerm has returned (["immortal"],0)          :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************ \ $*| has returned (["immortal"],0)                    :2_5:GoDeeper:
************************************ / |>| calling $>>                                      :2_5:GoDeeper:
************************************* / |>>/recurse                                        :2_5:GoDeeper:
************************************** / |>>/recurse                                       :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                          :2_5:Typically:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=11:
|>>/base> unexpected Typically
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>>/recurse> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/recurse> MATCH (CERR): GoDeeper
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

************************************* / |>>/base                                           :2_5:GoDeeper:
|>>/base> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=10:
|>>/base> unexpected GoDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: GoDeeper Typically GoDeeper Other "false <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=11:
|>| calling $>>> unexpected Typically
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPConstraint> IN: Other "immortal" GoDeeper Typically GoDe <…>
RPConstraint> MATCH (CERR): Other "immortal"
RPConstraint> ERROR:
RPConstraint> offset=11:
RPConstraint> unexpected Typically
RPConstraint> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPBoolStructR                                         :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slMultiTerm                                       :2_4:Other "immo:
************************************** / someSL                                          :2_4:Other "immo:
*************************************** / pNumAsText                                      :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

************************************** \ someSL has returned (["immortal"],0)             :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

************************************* \ slMultiTerm has returned (["immortal"],0)          :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************ \ $*| has returned (["immortal"],0)                    :2_5:GoDeeper:
************************************ / |>| calling $>>                                      :2_5:GoDeeper:
************************************* / |>>/recurse                                        :2_5:GoDeeper:
************************************** / |>>/recurse                                       :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                          :2_5:Typically:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=11:
|>>/base> unexpected Typically
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>>/recurse> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/recurse> MATCH (CERR): GoDeeper
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

************************************* / |>>/base                                           :2_5:GoDeeper:
|>>/base> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=10:
|>>/base> unexpected GoDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: GoDeeper Typically GoDeeper Other "false <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=11:
|>| calling $>>> unexpected Typically
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPBoolStructR> IN: Other "immortal" GoDeeper Typically GoDe <…>
RPBoolStructR> MATCH (CERR): Other "immortal"
RPBoolStructR> ERROR:
RPBoolStructR> offset=11:
RPBoolStructR> unexpected Typically
RPBoolStructR> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPMT                                                  :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slAKA                                             :2_4:Other "immo:
************************************** / $*|                                             :2_4:Other "immo:
*************************************** / slAKA base                                    :2_4:Other "immo:
**************************************** / slMultiTerm                                 :2_4:Other "immo:
***************************************** / someSL                                    :2_4:Other "immo:
****************************************** / pNumAsText                                :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

***************************************** \ someSL has returned (["immortal"],0)       :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

**************************************** \ slMultiTerm has returned (["immortal"],0)    :2_5:GoDeeper:
slAKA base> IN: Other "immortal" GoDeeper Typically GoDe <…>
slAKA base> MATCH (COK): Other "immortal"
slAKA base> VALUE: ((["immortal"],0),[])

*************************************** \ slAKA base has returned (["immortal"],0)       :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************** \ $*| has returned (["immortal"],0)                :2_5:GoDeeper:
************************************** / |>>/recurse                                      :2_5:GoDeeper:
*************************************** / |>>/recurse                                     :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

*************************************** / |>>/base                                        :2_5:Typically:
**************************************** / slAKA optional akapart                        :2_5:Typically:
***************************************** / |?| optional something                      :2_5:Typically:
****************************************** / |>>/recurse                               :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

****************************************** / |>>/base                                  :2_5:Typically:
******************************************* / PAKA/akapart                            :2_5:Typically:
******************************************** / $>|                                   :2_5:Typically:
********************************************* / Aka Token                           :2_5:Typically:
Aka Token> IN: Typically GoDeeper Other "false" UnDeepe <…>
Aka Token> MATCH (EERR): <EMPTY>
Aka Token> ERROR:
Aka Token> offset=11:
Aka Token> unexpected Typically
Aka Token> expecting Aka

$>|> IN: Typically GoDeeper Other "false" UnDeepe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=11:
$>|> unexpected Typically
$>|> expecting Aka

PAKA/akapart> IN: Typically GoDeeper Other "false" UnDeepe <…>
PAKA/akapart> MATCH (EERR): <EMPTY>
PAKA/akapart> ERROR:
PAKA/akapart> offset=11:
PAKA/akapart> unexpected Typically
PAKA/akapart> expecting Aka

|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=11:
|>>/base> unexpected Typically
|>>/base> expecting Aka

|?| optional something> IN: Typically GoDeeper Other "false" UnDeepe <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

***************************************** \ |?| optional something has returned (Nothing,0) :2_5:Typically:
slAKA optional akapart> IN: Typically GoDeeper Other "false" UnDeepe <…>
slAKA optional akapart> MATCH (EOK): <EMPTY>
slAKA optional akapart> VALUE: ((Nothing,0),[])

**************************************** \ slAKA optional akapart has returned (Nothing,0) :2_5:Typically:
**************************************** > |>>/base got Nothing                          :2_5:Typically:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

*************************************** \ |>>/base has returned (Nothing,0)               :2_5:Typically:
|>>/recurse> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/recurse> MATCH (COK): GoDeeper
|>>/recurse> VALUE: ((Nothing,1),[])

************************************** \ |>>/recurse has returned (Nothing,1)              :2_5:Typically:
************************************** / |>>/recurse                                       :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                          :2_5:Typically:
*************************************** / slAKA optional typically                        :2_5:Typically:
**************************************** / |?| optional something                        :2_5:Typically:
***************************************** / |>>/recurse                                 :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

***************************************** / |>>/base                                    :2_5:Typically:
****************************************** / typically                                 :2_5:Typically:
******************************************* / $>|                                     :2_5:Typically:
$>|> IN: Typically GoDeeper Other "false" UnDeepe <…>
$>|> MATCH (COK): Typically
$>|> VALUE: (Typically,[])

******************************************* \ $>| has returned Typically               :2_6:GoDeeper:
******************************************* / |>>/recurse                              :2_6:GoDeeper:
******************************************** / |>>/recurse                             :2_6:Other "fals:
|>>/recurse> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=13:
|>>/recurse> unexpected Other "false"
|>>/recurse> expecting GoDeeper

******************************************** / |>>/base                                :2_6:Other "fals:
********************************************* / slMultiTerm                           :2_6:Other "fals:
********************************************** / someSL                              :2_6:Other "fals:
someSL> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
someSL> MATCH (COK): Other "false"
someSL> VALUE: ((["false"],0),[])

********************************************** \ someSL has returned (["false"],0) :3_3:UnDeeper:
slMultiTerm> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
slMultiTerm> MATCH (COK): Other "false"
slMultiTerm> VALUE: ((["false"],0),[])

********************************************* \ slMultiTerm has returned (["false"],0) :3_3:UnDeeper:
********************************************* > |>>/base got ["false"]           :3_3:UnDeeper:
|>>/base> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
|>>/base> MATCH (COK): Other "false"
|>>/base> VALUE: ((["false"],0),[])

******************************************** \ |>>/base has returned (["false"],0) :3_3:UnDeeper:
|>>/recurse> IN: GoDeeper Other "false" UnDeeper UnDeeper <…>
|>>/recurse> MATCH (COK): GoDeeper Other "false"
|>>/recurse> VALUE: ((["false"],1),[])

******************************************* \ |>>/recurse has returned (["false"],1) :3_3:UnDeeper:
typically> IN: Typically GoDeeper Other "false" UnDeepe <…>
typically> MATCH (COK): Typically GoDeeper Other "false"
typically> VALUE: ((["false"],1),[])

****************************************** \ typically has returned (["false"],1)   :3_3:UnDeeper:
****************************************** > |>>/base got ["false"]                 :3_3:UnDeeper:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (COK): Typically GoDeeper Other "false"
|>>/base> VALUE: ((["false"],1),[])

***************************************** \ |>>/base has returned (["false"],1)      :3_3:UnDeeper:
|?| optional something> IN: Typically GoDeeper Other "false" UnDeepe <…>
|?| optional something> MATCH (COK): Typically GoDeeper Other "false"
|?| optional something> VALUE: ((Just ["false"],1),[])

**************************************** \ |?| optional something has returned (Just ["false"],1) :3_3:UnDeeper:
slAKA optional typically> IN: Typically GoDeeper Other "false" UnDeepe <…>
slAKA optional typically> MATCH (COK): Typically GoDeeper Other "false"
slAKA optional typically> VALUE: ((Just ["false"],1),[])

*************************************** \ slAKA optional typically has returned (Just ["false"],1) :3_3:UnDeeper:
*************************************** > |>>/base got Just ["false"]                  :3_3:UnDeeper:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (COK): Typically GoDeeper Other "false"
|>>/base> VALUE: ((Just ["false"],1),[])

************************************** \ |>>/base has returned (Just ["false"],1)       :3_3:UnDeeper:
************************************** > slAKA: proceeding after base and entityalias are retrieved ... :3_3:UnDeeper:
************************************** > pAKA: entityalias = Nothing                    :3_3:UnDeeper:
slAKA> IN: Other "immortal" GoDeeper Typically GoDe <…>
slAKA> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
slAKA> VALUE: ((["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************************* \ slAKA has returned (["immortal"],2)              :3_3:UnDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
$*|> VALUE: ((["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************************ \ $*| has returned (["immortal"],2)                  :3_3:UnDeeper:
RPMT> IN: Other "immortal" GoDeeper Typically GoDe <…>
RPMT> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
RPMT> VALUE: ((RPMT ["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*********************************** \ RPMT has returned (RPMT ["immortal"],2)              :3_3:UnDeeper:
slRelPred> IN: Other "immortal" GoDeeper Typically GoDe <…>
slRelPred> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
slRelPred> VALUE: ((RPMT ["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************************** \ slRelPred has returned (RPMT ["immortal"],2)           :3_3:UnDeeper:
********************************** / undeepers                                              :3_3:UnDeeper:
*********************************** > sameLine/undeepers: reached end of line; now need to clear 2 UnDeepers :3_3:UnDeeper:
*********************************** > sameLine: success!                                       :3_5:UnDeeper:
undeepers> IN: UnDeeper UnDeeper UnDeeper UnDeeper Or G <…>
undeepers> MATCH (COK): UnDeeper UnDeeper
undeepers> VALUE: ((),[])

********************************** \ undeepers has returned ()                                  :3_5:UnDeeper:
pRelPred> IN: Other "immortal" GoDeeper Typically GoDe <…>
pRelPred> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
pRelPred> VALUE: (RPMT ["immortal"],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************************* \ pRelPred has returned RPMT ["immortal"]                      :3_5:UnDeeper:
term p/3:plain p> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/3:plain p> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
term p/3:plain p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************************** \ term p/3:plain p has returned MyLeaf (RPMT ["immortal"])       :3_5:UnDeeper:
term p/notLabelTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/notLabelTerm> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["immortal"])      :3_5:UnDeeper:
term p> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
term p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

****************************** \ term p has returned MyLeaf (RPMT ["immortal"])                     :3_5:UnDeeper:
****************************** / binary(Or)                                                         :3_5:UnDeeper:
binary(Or)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=16:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

****************************** / binary(And)                                                        :3_5:UnDeeper:
binary(And)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=16:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

****************************** / binary(SetLess)                                                    :3_5:UnDeeper:
binary(SetLess)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=16:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

****************************** / binary(SetPlus)                                                    :3_5:UnDeeper:
binary(SetPlus)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=16:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "immortal" GoDeeper Typically GoDe <…>
expression> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
expression> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

***************************** \ expression has returned MyLeaf (RPMT ["immortal"])                   :3_5:UnDeeper:
manyIndentation/leaf?> IN: Other "immortal" GoDeeper Typically GoDe <…>
manyIndentation/leaf?> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
manyIndentation/leaf?> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

**************************** \ manyIndentation/leaf? has returned MyLeaf (RPMT ["immortal"])          :3_5:UnDeeper:
**************************** / myindented: consuming UnDeeper                                         :3_5:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

**************************** \ myindented: consuming UnDeeper has returned UnDeeper                     :3_6:UnDeeper:
someIndentation> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
someIndentation> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
someIndentation> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*************************** \ someIndentation has returned MyLeaf (RPMT ["immortal"])                    :3_6:UnDeeper:
term p/2:someIndentation expr p> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
term p/2:someIndentation expr p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************** \ term p/2:someIndentation expr p has returned MyLeaf (RPMT ["immortal"])      :3_6:UnDeeper:
term p/notLabelTerm> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["immortal"])                    :3_6:UnDeeper:
term p> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
term p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************ \ term p has returned MyLeaf (RPMT ["immortal"])                                   :3_6:UnDeeper:
************************ / binary(Or)                                                                       :3_6:UnDeeper:
binary(Or)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=17:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

************************ / binary(And)                                                                      :3_6:UnDeeper:
binary(And)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=17:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

************************ / binary(SetLess)                                                                  :3_6:UnDeeper:
binary(SetLess)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=17:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

************************ / binary(SetPlus)                                                                  :3_6:UnDeeper:
binary(SetPlus)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=17:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "is" GoDeeper Other "immortal" GoD <…>
expression> MATCH (COK): Other "is" GoDeeper Other "immortal" GoD <…>
expression> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*********************** \ expression has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))                :3_6:UnDeeper:
manyIndentation/leaf?> IN: Other "is" GoDeeper Other "immortal" GoD <…>
manyIndentation/leaf?> MATCH (COK): Other "is" GoDeeper Other "immortal" GoD <…>
manyIndentation/leaf?> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************** \ manyIndentation/leaf? has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))       :3_6:UnDeeper:
********************** / myindented: consuming UnDeeper                                                       :3_6:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

********************** \ myindented: consuming UnDeeper has returned UnDeeper                        :3_2:Or:
someIndentation> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
someIndentation> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
someIndentation> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************* \ someIndentation has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))      :3_2:Or:
term p/2:someIndentation expr p> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
term p/2:someIndentation expr p> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************** \ term p/2:someIndentation expr p has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"])) :3_2:Or:
term p/notLabelTerm> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
term p/notLabelTerm> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************* \ term p/notLabelTerm has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))      :3_2:Or:
term p> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
term p> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

****************** \ term p has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))                     :3_2:Or:
****************** / binary(Or)                                                                          :3_2:Or:
binary(Or)> IN: Or GoDeeper Other "has" GoDeeper Other " <…>
binary(Or)> MATCH (COK): Or
binary(Or)> VALUE: (Or,[])

****************** \ binary(Or) has returned Or                                                           :3_3:GoDeeper:
****************** / term p                                                                               :3_3:GoDeeper:
******************* / term p/1a:label directly above                                                     :3_3:GoDeeper:
******************** / $*|                                                                              :3_3:GoDeeper:
********************* / someSL                                                                         :3_3:GoDeeper:
********************** / pNumAsText                                                                   :3_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=19:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=19:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=19:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=19:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

******************* / term p/b:label to the left of line below, with EOL                                 :3_3:GoDeeper:
******************** / someSL                                                                           :3_3:GoDeeper:
********************* / pNumAsText                                                                     :3_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=19:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=19:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=19:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

******************* / term p/notLabelTerm                                                                :3_3:GoDeeper:
******************** / term p/2:someIndentation expr p                                                  :3_3:GoDeeper:
********************* / someIndentation                                                                :3_3:GoDeeper:
********************** / myindented: consuming GoDeeper                                               :3_3:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

********************** \ myindented: consuming GoDeeper has returned GoDeeper                          :3_3:Other "has":
********************** / manyIndentation/leaf?                                                         :3_3:Other "has":
*********************** / expression                                                                  :3_3:Other "has":
************************ / labelPrefix                                                               :3_3:Other "has":
labelPrefix> IN: Other "has" GoDeeper Other "health insur <…>
labelPrefix> MATCH (COK): Other "has"
labelPrefix> VALUE: ("has",[])

************************ \ labelPrefix has returned "has"                                             :3_4:GoDeeper:
************************ / term p                                                                     :3_4:GoDeeper:
************************* / term p/1a:label directly above                                           :3_4:GoDeeper:
************************** / $*|                                                                    :3_4:GoDeeper:
*************************** / someSL                                                               :3_4:GoDeeper:
**************************** / pNumAsText                                                         :3_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "health insurance" UnDeep <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=21:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "health insurance" UnDeep <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=21:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "health insurance" UnDeep <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=21:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=21:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

************************* / term p/b:label to the left of line below, with EOL                       :3_4:GoDeeper:
************************** / someSL                                                                 :3_4:GoDeeper:
*************************** / pNumAsText                                                           :3_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "health insurance" UnDeep <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=21:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "health insurance" UnDeep <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=21:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=21:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

************************* / term p/notLabelTerm                                                      :3_4:GoDeeper:
************************** / term p/2:someIndentation expr p                                        :3_4:GoDeeper:
*************************** / someIndentation                                                      :3_4:GoDeeper:
**************************** / myindented: consuming GoDeeper                                     :3_4:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "health insurance" UnDeep <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

**************************** \ myindented: consuming GoDeeper has returned GoDeeper                :3_4:Other "heal:
**************************** / manyIndentation/leaf?                                               :3_4:Other "heal:
***************************** / expression                                                        :3_4:Other "heal:
****************************** / labelPrefix                                                     :3_4:Other "heal:
labelPrefix> IN: Other "health insurance" UnDeeper UnDeep <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=23:
labelPrefix> unexpected UnDeeper

****************************** / term p                                                          :3_4:Other "heal:
******************************* / term p/1a:label directly above                                :3_4:Other "heal:
******************************** / $*|                                                         :3_4:Other "heal:
********************************* / someSL                                                    :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

********************************* \ someSL has returned (["health insurance"],0)           :4_2:UnDeeper:
********************************* / pNumAsText                                             :4_2:UnDeeper:
pNumAsText> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=23:
pNumAsText> unexpected UnDeeper
pNumAsText> expecting number

$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (CERR): Other "health insurance"
$*|> ERROR:
$*|> offset=23:
$*|> unexpected UnDeeper
$*|> expecting GoDeeper or other text or number

term p/1a:label directly above> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/1a:label directly above> MATCH (CERR): Other "health insurance"
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=23:
term p/1a:label directly above> unexpected UnDeeper
term p/1a:label directly above> expecting GoDeeper or other text or number

******************************* / term p/b:label to the left of line below, with EOL            :3_4:Other "heal:
******************************** / someSL                                                      :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

******************************** \ someSL has returned (["health insurance"],0)             :4_2:UnDeeper:
******************************** / undeepers                                                :4_2:UnDeeper:
********************************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers :4_2:UnDeeper:
********************************* > sameLine: success!                                     :4_2:UnDeeper:
undeepers> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

******************************** \ undeepers has returned ()                                :4_2:UnDeeper:
******************************** / matching EOL                                             :4_2:UnDeeper:
matching EOL> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
matching EOL> MATCH (EERR): <EMPTY>
matching EOL> ERROR:
matching EOL> offset=23:
matching EOL> unexpected UnDeeper
matching EOL> expecting EOL

term p/b:label to the left of line below, with EOL> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/b:label to the left of line below, with EOL> MATCH (CERR): Other "health insurance"
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=23:
term p/b:label to the left of line below, with EOL> unexpected UnDeeper
term p/b:label to the left of line below, with EOL> expecting EOL or GoDeeper

******************************* / term p/notLabelTerm                                           :3_4:Other "heal:
******************************** / term p/2:someIndentation expr p                             :3_4:Other "heal:
********************************* / someIndentation                                           :3_4:Other "heal:
********************************** / myindented: consuming GoDeeper                          :3_4:Other "heal:
myindented: consuming GoDeeper> IN: Other "health insurance" UnDeeper UnDeep <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=22:
myindented: consuming GoDeeper> unexpected Other "health insurance"
myindented: consuming GoDeeper> expecting GoDeeper

someIndentation> IN: Other "health insurance" UnDeeper UnDeep <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=22:
someIndentation> unexpected Other "health insurance"
someIndentation> expecting GoDeeper

term p/2:someIndentation expr p> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/2:someIndentation expr p> MATCH (EERR): <EMPTY>
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=22:
term p/2:someIndentation expr p> unexpected Other "health insurance"
term p/2:someIndentation expr p> expecting GoDeeper

******************************** / term p/3:plain p                                            :3_4:Other "heal:
********************************* / pRelPred                                                  :3_4:Other "heal:
********************************** / slRelPred                                               :3_4:Other "heal:
*********************************** / nested simpleHorn                                     :3_4:Other "heal:
************************************ > |^|                                                 :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slMultiTerm                                       :3_4:Other "heal:
************************************** / someSL                                          :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

************************************* \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
************************************ / |^| deeps                                        :4_2:UnDeeper:
|^| deeps> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|^| deeps> MATCH (COK): UnDeeper UnDeeper UnDeeper
|^| deeps> VALUE: (([(),(),()],-3),[])

************************************ \ |^| deeps has returned ([(),(),()],-3)        :4_1:May:
nested simpleHorn> IN: Other "health insurance" UnDeeper UnDeep <…>
nested simpleHorn> MATCH (CERR): Other "health insurance" UnDeeper UnDeep <…>
nested simpleHorn> ERROR:
nested simpleHorn> offset=26:
nested simpleHorn> unexpected May
nested simpleHorn> expecting Means or UnDeeper

*********************************** / RPConstraint                                          :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slMultiTerm                                       :3_4:Other "heal:
************************************** / someSL                                          :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

************************************* \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
************************************ / |>| calling $>>                                  :4_2:UnDeeper:
************************************* / |>>/recurse                                    :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************* / |>>/base                                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=23:
|>| calling $>>> unexpected UnDeeper
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPConstraint> IN: Other "health insurance" UnDeeper UnDeep <…>
RPConstraint> MATCH (CERR): Other "health insurance"
RPConstraint> ERROR:
RPConstraint> offset=23:
RPConstraint> unexpected UnDeeper
RPConstraint> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPBoolStructR                                         :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slMultiTerm                                       :3_4:Other "heal:
************************************** / someSL                                          :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

************************************* \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
************************************ / |>| calling $>>                                  :4_2:UnDeeper:
************************************* / |>>/recurse                                    :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************* / |>>/base                                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=23:
|>| calling $>>> unexpected UnDeeper
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPBoolStructR> IN: Other "health insurance" UnDeeper UnDeep <…>
RPBoolStructR> MATCH (CERR): Other "health insurance"
RPBoolStructR> ERROR:
RPBoolStructR> offset=23:
RPBoolStructR> unexpected UnDeeper
RPBoolStructR> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPMT                                                  :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slAKA                                             :3_4:Other "heal:
************************************** / $*|                                             :3_4:Other "heal:
*************************************** / slAKA base                                    :3_4:Other "heal:
**************************************** / slMultiTerm                                 :3_4:Other "heal:
***************************************** / someSL                                    :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

***************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

**************************************** \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
slAKA base> IN: Other "health insurance" UnDeeper UnDeep <…>
slAKA base> MATCH (COK): Other "health insurance"
slAKA base> VALUE: ((["health insurance"],0),[])

*************************************** \ slAKA base has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************** \ $*| has returned (["health insurance"],0)    :4_2:UnDeeper:
************************************** / |>>/recurse                                  :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                     :4_2:UnDeeper:
*************************************** / slAKA optional akapart                     :4_2:UnDeeper:
**************************************** / |?| optional something                   :4_2:UnDeeper:
***************************************** / |>>/recurse                            :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

***************************************** / |>>/base                               :4_2:UnDeeper:
****************************************** / PAKA/akapart                         :4_2:UnDeeper:
******************************************* / $>|                                :4_2:UnDeeper:
******************************************** / Aka Token                        :4_2:UnDeeper:
Aka Token> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
Aka Token> MATCH (EERR): <EMPTY>
Aka Token> ERROR:
Aka Token> offset=23:
Aka Token> unexpected UnDeeper
Aka Token> expecting Aka

$>|> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=23:
$>|> unexpected UnDeeper
$>|> expecting Aka

PAKA/akapart> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
PAKA/akapart> MATCH (EERR): <EMPTY>
PAKA/akapart> ERROR:
PAKA/akapart> offset=23:
PAKA/akapart> unexpected UnDeeper
PAKA/akapart> expecting Aka

|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Aka

|?| optional something> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

**************************************** \ |?| optional something has returned (Nothing,0) :4_2:UnDeeper:
slAKA optional akapart> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
slAKA optional akapart> MATCH (EOK): <EMPTY>
slAKA optional akapart> VALUE: ((Nothing,0),[])

*************************************** \ slAKA optional akapart has returned (Nothing,0) :4_2:UnDeeper:
*************************************** > |>>/base got Nothing                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************************************** \ |>>/base has returned (Nothing,0)            :4_2:UnDeeper:
************************************** / |>>/recurse                                  :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                     :4_2:UnDeeper:
*************************************** / slAKA optional typically                   :4_2:UnDeeper:
**************************************** / |?| optional something                   :4_2:UnDeeper:
***************************************** / |>>/recurse                            :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

***************************************** / |>>/base                               :4_2:UnDeeper:
****************************************** / typically                            :4_2:UnDeeper:
******************************************* / $>|                                :4_2:UnDeeper:
$>|> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=23:
$>|> unexpected UnDeeper
$>|> expecting Typically

typically> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
typically> MATCH (EERR): <EMPTY>
typically> ERROR:
typically> offset=23:
typically> unexpected UnDeeper
typically> expecting Typically

|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Typically

|?| optional something> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

**************************************** \ |?| optional something has returned (Nothing,0) :4_2:UnDeeper:
slAKA optional typically> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
slAKA optional typically> MATCH (EOK): <EMPTY>
slAKA optional typically> VALUE: ((Nothing,0),[])

*************************************** \ slAKA optional typically has returned (Nothing,0) :4_2:UnDeeper:
*************************************** > |>>/base got Nothing                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************************************** \ |>>/base has returned (Nothing,0)            :4_2:UnDeeper:
************************************** > slAKA: proceeding after base and entityalias are retrieved ... :4_2:UnDeeper:
************************************** > pAKA: entityalias = Nothing                  :4_2:UnDeeper:
slAKA> IN: Other "health insurance" UnDeeper UnDeep <…>
slAKA> MATCH (COK): Other "health insurance"
slAKA> VALUE: ((["health insurance"],0),[])

************************************* \ slAKA has returned (["health insurance"],0)    :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
RPMT> IN: Other "health insurance" UnDeeper UnDeep <…>
RPMT> MATCH (COK): Other "health insurance"
RPMT> VALUE: ((RPMT ["health insurance"],0),[])

*********************************** \ RPMT has returned (RPMT ["health insurance"],0)    :4_2:UnDeeper:
slRelPred> IN: Other "health insurance" UnDeeper UnDeep <…>
slRelPred> MATCH (COK): Other "health insurance"
slRelPred> VALUE: ((RPMT ["health insurance"],0),[])

********************************** \ slRelPred has returned (RPMT ["health insurance"],0) :4_2:UnDeeper:
********************************** / undeepers                                            :4_2:UnDeeper:
*********************************** > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers :4_2:UnDeeper:
*********************************** > sameLine: success!                                 :4_2:UnDeeper:
undeepers> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

********************************** \ undeepers has returned ()                            :4_2:UnDeeper:
pRelPred> IN: Other "health insurance" UnDeeper UnDeep <…>
pRelPred> MATCH (COK): Other "health insurance"
pRelPred> VALUE: (RPMT ["health insurance"],[])

********************************* \ pRelPred has returned RPMT ["health insurance"]        :4_2:UnDeeper:
term p/3:plain p> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/3:plain p> MATCH (COK): Other "health insurance"
term p/3:plain p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

******************************** \ term p/3:plain p has returned MyLeaf (RPMT ["health insurance"]) :4_2:UnDeeper:
term p/notLabelTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/notLabelTerm> MATCH (COK): Other "health insurance"
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

******************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["health insurance"]) :4_2:UnDeeper:
term p> IN: Other "health insurance" UnDeeper UnDeep <…>
term p> MATCH (COK): Other "health insurance"
term p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

****************************** \ term p has returned MyLeaf (RPMT ["health insurance"])       :4_2:UnDeeper:
****************************** / binary(Or)                                                   :4_2:UnDeeper:
binary(Or)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=23:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

****************************** / binary(And)                                                  :4_2:UnDeeper:
binary(And)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=23:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

****************************** / binary(SetLess)                                              :4_2:UnDeeper:
binary(SetLess)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=23:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

****************************** / binary(SetPlus)                                              :4_2:UnDeeper:
binary(SetPlus)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=23:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "health insurance" UnDeeper UnDeep <…>
expression> MATCH (COK): Other "health insurance"
expression> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

***************************** \ expression has returned MyLeaf (RPMT ["health insurance"])     :4_2:UnDeeper:
manyIndentation/leaf?> IN: Other "health insurance" UnDeeper UnDeep <…>
manyIndentation/leaf?> MATCH (COK): Other "health insurance"
manyIndentation/leaf?> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

**************************** \ manyIndentation/leaf? has returned MyLeaf (RPMT ["health insurance"]) :4_2:UnDeeper:
**************************** / myindented: consuming UnDeeper                                   :4_2:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

**************************** \ myindented: consuming UnDeeper has returned UnDeeper               :4_3:UnDeeper:
someIndentation> IN: GoDeeper Other "health insurance" UnDeep <…>
someIndentation> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
someIndentation> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

*************************** \ someIndentation has returned MyLeaf (RPMT ["health insurance"])      :4_3:UnDeeper:
term p/2:someIndentation expr p> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
term p/2:someIndentation expr p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

************************** \ term p/2:someIndentation expr p has returned MyLeaf (RPMT ["health insurance"]) :4_3:UnDeeper:
term p/notLabelTerm> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["health insurance"])      :4_3:UnDeeper:
term p> IN: GoDeeper Other "health insurance" UnDeep <…>
term p> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
term p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

************************ \ term p has returned MyLeaf (RPMT ["health insurance"])                     :4_3:UnDeeper:
************************ / binary(Or)                                                                 :4_3:UnDeeper:
binary(Or)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=24:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

************************ / binary(And)                                                                :4_3:UnDeeper:
binary(And)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=24:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

************************ / binary(SetLess)                                                            :4_3:UnDeeper:
binary(SetLess)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=24:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

************************ / binary(SetPlus)                                                            :4_3:UnDeeper:
binary(SetPlus)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=24:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "has" GoDeeper Other "health insur <…>
expression> MATCH (COK): Other "has" GoDeeper Other "health insur <…>
expression> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

*********************** \ expression has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])) :4_3:UnDeeper:
manyIndentation/leaf?> IN: Other "has" GoDeeper Other "health insur <…>
manyIndentation/leaf?> MATCH (COK): Other "has" GoDeeper Other "health insur <…>
manyIndentation/leaf?> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

********************** \ manyIndentation/leaf? has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])) :4_3:UnDeeper:
********************** / myindented: consuming UnDeeper                                                 :4_3:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

********************** \ myindented: consuming UnDeeper has returned UnDeeper                             :4_4:UnDeeper:
someIndentation> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
someIndentation> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
someIndentation> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

********************* \ someIndentation has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))  :4_4:UnDeeper:
term p/2:someIndentation expr p> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
term p/2:someIndentation expr p> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

******************** \ term p/2:someIndentation expr p has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])) :4_4:UnDeeper:
term p/notLabelTerm> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
term p/notLabelTerm> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

******************* \ term p/notLabelTerm has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))  :4_4:UnDeeper:
term p> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
term p> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

****************** \ term p has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))                 :4_4:UnDeeper:
****************** / binary(Or)                                                                               :4_4:UnDeeper:
binary(Or)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=25:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

****************** / binary(And)                                                                              :4_4:UnDeeper:
binary(And)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=25:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

****************** / binary(SetLess)                                                                          :4_4:UnDeeper:
binary(SetLess)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=25:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

****************** / binary(SetPlus)                                                                          :4_4:UnDeeper:
binary(SetPlus)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=25:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
expression> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
expression> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

***************** \ expression has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_4:UnDeeper:
manyIndentation/leaf?> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
manyIndentation/leaf?> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
manyIndentation/leaf?> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

**************** \ manyIndentation/leaf? has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_4:UnDeeper:
**************** / myindented: consuming UnDeeper                                                               :4_4:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

**************** \ myindented: consuming UnDeeper has returned UnDeeper                                  :4_1:May:
someIndentation> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someIndentation> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someIndentation> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*************** \ someIndentation has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
term p/2:someIndentation expr p> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/2:someIndentation expr p> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************** \ term p/2:someIndentation expr p has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
term p/notLabelTerm> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/notLabelTerm> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/notLabelTerm> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************* \ term p/notLabelTerm has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
term p> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************ \ term p has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
************ / binary(Or)                                                                                    :4_1:May:
binary(Or)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=26:
binary(Or)> unexpected May
binary(Or)> expecting Or

************ / binary(And)                                                                                   :4_1:May:
binary(And)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=26:
binary(And)> unexpected May
binary(And)> expecting And

************ / binary(SetLess)                                                                               :4_1:May:
binary(SetLess)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=26:
binary(SetLess)> unexpected May
binary(SetLess)> expecting SetLess

************ / binary(SetPlus)                                                                               :4_1:May:
binary(SetPlus)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=26:
binary(SetPlus)> unexpected May
binary(SetPlus)> expecting SetPlus

expression> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
expression> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
expression> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*********** \ expression has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
ppp inner> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
ppp inner> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
ppp inner> VALUE: (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********** \ ppp inner has returned Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])] :4_1:May:
pBSR> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pBSR> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pBSR> VALUE: (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********* \ pBSR has returned Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])] :4_1:May:
preambleBoolStructR [Who,Which,Whose]> IN: Who GoDeeper GoDeeper Other "is" GoDeepe <…>
preambleBoolStructR [Who,Which,Whose]> MATCH (COK): Who GoDeeper GoDeeper Other "is" GoDeepe <…>
preambleBoolStructR [Who,Which,Whose]> VALUE: ((Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******** \ preambleBoolStructR [Who,Which,Whose] has returned (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]) :4_1:May:
manyIndentation/leaf?> IN: Who GoDeeper GoDeeper Other "is" GoDeepe <…>
manyIndentation/leaf?> MATCH (COK): Who GoDeeper GoDeeper Other "is" GoDeepe <…>
manyIndentation/leaf?> VALUE: ((Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******* \ manyIndentation/leaf? has returned (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]) :4_1:May:
******* / WHERE                                                                                                   :4_1:May:
WHERE> IN: May GoDeeper Other "sharpen knives" UnDe <…>
WHERE> MATCH (EERR): <EMPTY>
WHERE> ERROR:
WHERE> offset=26:
WHERE> unexpected May
WHERE> expecting Where

******* / preambleParamText:[Having]                                                                              :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=26:
$>|> unexpected May
$>|> expecting Having

preambleParamText:[Having]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleParamText:[Having]> MATCH (EERR): <EMPTY>
preambleParamText:[Having]> ERROR:
preambleParamText:[Having]> offset=26:
preambleParamText:[Having]> unexpected May
preambleParamText:[Having]> expecting Having

******* / preambleParamText:[Given]                                                                               :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=26:
$>|> unexpected May
$>|> expecting Given

preambleParamText:[Given]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=26:
preambleParamText:[Given]> unexpected May
preambleParamText:[Given]> expecting Given

******* / preambleParamText:[Upon]                                                                                :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=26:
$>|> unexpected May
$>|> expecting Upon

preambleParamText:[Upon]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=26:
preambleParamText:[Upon]> unexpected May
preambleParamText:[Upon]> expecting Upon

******* / preambleBoolStructR [Unless]                                                                            :4_1:May:
preambleBoolStructR [Unless]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleBoolStructR [Unless]> MATCH (EERR): <EMPTY>
preambleBoolStructR [Unless]> ERROR:
preambleBoolStructR [Unless]> offset=26:
preambleBoolStructR [Unless]> unexpected May
preambleBoolStructR [Unless]> expecting Unless

******* / preambleBoolStructR [When,If]                                                                           :4_1:May:
preambleBoolStructR [When,If]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleBoolStructR [When,If]> MATCH (EERR): <EMPTY>
preambleBoolStructR [When,If]> ERROR:
preambleBoolStructR [When,If]> offset=26:
preambleBoolStructR [When,If]> unexpected May
preambleBoolStructR [When,If]> expecting If or When

******* / pDT                                                                                                     :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (COK): May
$>|> VALUE: (DMay,[])

******** \ $>| has returned DMay                                                                                  :4_2:GoDeeper:
******** / |>| calling $>>                                                                                        :4_2:GoDeeper:
********* / |>>/recurse                                                                                          :4_2:GoDeeper:
********** / |>>/recurse                                                                                         :4_2:Other "shar:
|>>/recurse> IN: Other "sharpen knives" UnDeeper
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=28:
|>>/recurse> unexpected Other "sharpen knives"
|>>/recurse> expecting GoDeeper

********** / |>>/base                                                                                            :4_2:Other "shar:
*********** / pTemporal/eventually                                                                              :4_2:Other "shar:
pTemporal/eventually> IN: Other "sharpen knives" UnDeeper
pTemporal/eventually> MATCH (EERR): <EMPTY>
pTemporal/eventually> ERROR:
pTemporal/eventually> offset=28:
pTemporal/eventually> unexpected Other "sharpen knives"
pTemporal/eventually> expecting Eventually

*********** / pTemporal/specifically                                                                            :4_2:Other "shar:
************ / $>|                                                                                             :4_2:Other "shar:
$>|> IN: Other "sharpen knives" UnDeeper
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=28:
$>|> unexpected Other "sharpen knives"
$>|> expecting After, Before, By, or On

pTemporal/specifically> IN: Other "sharpen knives" UnDeeper
pTemporal/specifically> MATCH (EERR): <EMPTY>
pTemporal/specifically> ERROR:
pTemporal/specifically> offset=28:
pTemporal/specifically> unexpected Other "sharpen knives"
pTemporal/specifically> expecting After, Before, By, or On

*********** / pTemporal/vaguely                                                                                 :4_2:Other "shar:
pTemporal/vaguely> IN: Other "sharpen knives" UnDeeper
pTemporal/vaguely> MATCH (COK): Other "sharpen knives"
pTemporal/vaguely> VALUE: (Just (TemporalConstraint TVague (Just 0) "sharpen knives"),[])

*********** \ pTemporal/vaguely has returned Just (TemporalConstraint TVague (Just 0) "sharpen knives")          :1_2:UnDeeper:
*********** > |>>/base got Just (Just (TemporalConstraint TVague (Just 0) "sharpen knives"))                     :1_2:UnDeeper:
|>>/base> IN: Other "sharpen knives" UnDeeper
|>>/base> MATCH (COK): Other "sharpen knives"
|>>/base> VALUE: ((Just (Just (TemporalConstraint TVague (Just 0) "sharpen knives")),0),[])

********** \ |>>/base has returned (Just (Just (TemporalConstraint TVague (Just 0) "sharpen knives")),0)          :1_2:UnDeeper:
|>>/recurse> IN: GoDeeper Other "sharpen knives" UnDeeper
|>>/recurse> MATCH (COK): GoDeeper Other "sharpen knives"
|>>/recurse> VALUE: ((Just (Just (TemporalConstraint TVague (Just 0) "sharpen knives")),1),[])

********* \ |>>/recurse has returned (Just (Just (TemporalConstraint TVague (Just 0) "sharpen knives")),1)         :1_2:UnDeeper:
|>| calling $>>> IN: GoDeeper Other "sharpen knives" UnDeeper
|>| calling $>>> MATCH (COK): GoDeeper Other "sharpen knives"
|>| calling $>>> VALUE: ((Just (Just (TemporalConstraint TVague (Just 0) "sharpen knives")),1),[])

******** \ |>| calling $>> has returned (Just (Just (TemporalConstraint TVague (Just 0) "sharpen knives")),1)       :1_2:UnDeeper:
******** / undeepers                                                                                                :1_2:UnDeeper:
********* > sameLine/undeepers: reached end of line; now need to clear 1 UnDeepers                                 :1_2:UnDeeper:
********* > sameLine: success!                                                                                :EOF:
undeepers> IN: UnDeeper
undeepers> MATCH (COK): UnDeeper
undeepers> VALUE: ((),[])

******** \ undeepers has returned ()                                                                           :EOF:
pDT> IN: May GoDeeper Other "sharpen knives" UnDe <…>
pDT> MATCH (COK): May GoDeeper Other "sharpen knives" UnDe <…>
pDT> VALUE: ((DMay,Just (TemporalConstraint TVague (Just 0) "sharpen knives")),[])

******* \ pDT has returned (DMay,Just (TemporalConstraint TVague (Just 0) "sharpen knives"))                    :EOF:
******* / WHERE                                                                                                 :EOF:
WHERE> IN: <EMPTY>
WHERE> MATCH (EERR): <EMPTY>
WHERE> ERROR:
WHERE> offset=30:
WHERE> unexpected end of input
WHERE> expecting Where

******* / preambleParamText:[Having]                                                                            :EOF:
******** / $>|                                                                                                 :EOF:
$>|> IN: <EMPTY>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=30:
$>|> unexpected end of input
$>|> expecting Having

preambleParamText:[Having]> IN: <EMPTY>
preambleParamText:[Having]> MATCH (EERR): <EMPTY>
preambleParamText:[Having]> ERROR:
preambleParamText:[Having]> offset=30:
preambleParamText:[Having]> unexpected end of input
preambleParamText:[Having]> expecting Having or any token

******* / preambleParamText:[Given]                                                                             :EOF:
******** / $>|                                                                                                 :EOF:
$>|> IN: <EMPTY>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=30:
$>|> unexpected end of input
$>|> expecting Given

preambleParamText:[Given]> IN: <EMPTY>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=30:
preambleParamText:[Given]> unexpected end of input
preambleParamText:[Given]> expecting Given or any token

******* / preambleParamText:[Upon]                                                                              :EOF:
******** / $>|                                                                                                 :EOF:
$>|> IN: <EMPTY>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=30:
$>|> unexpected end of input
$>|> expecting Upon

preambleParamText:[Upon]> IN: <EMPTY>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=30:
preambleParamText:[Upon]> unexpected end of input
preambleParamText:[Upon]> expecting Upon or any token

******* / preambleBoolStructR [Unless]                                                                          :EOF:
preambleBoolStructR [Unless]> IN: <EMPTY>
preambleBoolStructR [Unless]> MATCH (EERR): <EMPTY>
preambleBoolStructR [Unless]> ERROR:
preambleBoolStructR [Unless]> offset=30:
preambleBoolStructR [Unless]> unexpected end of input
preambleBoolStructR [Unless]> expecting Unless

******* / preambleBoolStructR [When,If]                                                                         :EOF:
preambleBoolStructR [When,If]> IN: <EMPTY>
preambleBoolStructR [When,If]> MATCH (EERR): <EMPTY>
preambleBoolStructR [When,If]> ERROR:
preambleBoolStructR [When,If]> offset=30:
preambleBoolStructR [When,If]> unexpected end of input
preambleBoolStructR [When,If]> expecting If or When

******* / pDoAction/Do                                                                                          :EOF:
pDoAction/Do> IN: <EMPTY>
pDoAction/Do> MATCH (EERR): <EMPTY>
pDoAction/Do> ERROR:
pDoAction/Do> offset=30:
pDoAction/Do> unexpected end of input
pDoAction/Do> expecting Do

regulative permutation with deontic-temporal> IN: Every GoDeeper Other "person" UnDeeper W <…>
regulative permutation with deontic-temporal> MATCH (CERR): Every GoDeeper Other "person" UnDeeper W <…>
regulative permutation with deontic-temporal> ERROR:
regulative permutation with deontic-temporal> offset=30:
regulative permutation with deontic-temporal> unexpected end of input
regulative permutation with deontic-temporal> expecting Do, Given, Having, If, Unless, Upon, When, Where, or any token

****** / regulative permutation with deontic-action                                                                :1_1:Every:
******* / WHERE                                                                                                   :1_1:Every:
WHERE> IN: Every GoDeeper Other "person" UnDeeper W <…>
WHERE> MATCH (EERR): <EMPTY>
WHERE> ERROR:
WHERE> offset=0:
WHERE> unexpected Every
WHERE> expecting Where

******* / preambleParamText:[Having]                                                                              :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting Having

preambleParamText:[Having]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleParamText:[Having]> MATCH (EERR): <EMPTY>
preambleParamText:[Having]> ERROR:
preambleParamText:[Having]> offset=0:
preambleParamText:[Having]> unexpected Every
preambleParamText:[Having]> expecting Having

******* / preambleParamText:[Given]                                                                               :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting Given

preambleParamText:[Given]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=0:
preambleParamText:[Given]> unexpected Every
preambleParamText:[Given]> expecting Given

******* / preambleParamText:[Upon]                                                                                :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting Upon

preambleParamText:[Upon]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=0:
preambleParamText:[Upon]> unexpected Every
preambleParamText:[Upon]> expecting Upon

******* / preambleBoolStructR [Unless]                                                                            :1_1:Every:
preambleBoolStructR [Unless]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleBoolStructR [Unless]> MATCH (EERR): <EMPTY>
preambleBoolStructR [Unless]> ERROR:
preambleBoolStructR [Unless]> offset=0:
preambleBoolStructR [Unless]> unexpected Every
preambleBoolStructR [Unless]> expecting Unless

******* / preambleBoolStructR [When,If]                                                                           :1_1:Every:
preambleBoolStructR [When,If]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleBoolStructR [When,If]> MATCH (EERR): <EMPTY>
preambleBoolStructR [When,If]> ERROR:
preambleBoolStructR [When,If]> offset=0:
preambleBoolStructR [When,If]> unexpected Every
preambleBoolStructR [When,If]> expecting If or When

******* / pTemporal/eventually                                                                                    :1_1:Every:
pTemporal/eventually> IN: Every GoDeeper Other "person" UnDeeper W <…>
pTemporal/eventually> MATCH (EERR): <EMPTY>
pTemporal/eventually> ERROR:
pTemporal/eventually> offset=0:
pTemporal/eventually> unexpected Every
pTemporal/eventually> expecting Eventually

******* / pTemporal/specifically                                                                                  :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting After, Before, By, or On

pTemporal/specifically> IN: Every GoDeeper Other "person" UnDeeper W <…>
pTemporal/specifically> MATCH (EERR): <EMPTY>
pTemporal/specifically> ERROR:
pTemporal/specifically> offset=0:
pTemporal/specifically> unexpected Every
pTemporal/specifically> expecting After, Before, By, or On

******* / pTemporal/vaguely                                                                                       :1_1:Every:
pTemporal/vaguely> IN: Every GoDeeper Other "person" UnDeeper W <…>
pTemporal/vaguely> MATCH (EERR): <EMPTY>
pTemporal/vaguely> ERROR:
pTemporal/vaguely> offset=0:
pTemporal/vaguely> unexpected Every
pTemporal/vaguely> expecting Other text

******* / pActor [Every,Party,TokAll]                                                                             :1_1:Every:
******** / someIndentation                                                                                        :1_2:GoDeeper:
********* / myindented: consuming GoDeeper                                                                       :1_2:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "person" UnDeeper Who GoD <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

********* \ myindented: consuming GoDeeper has returned GoDeeper                                                  :1_2:Other "pers:
********* / manyIndentation/leaf?                                                                                 :1_2:Other "pers:
********** / pMultiTermAka                                                                                       :1_2:Other "pers:
*********** / pAKA                                                                                              :1_2:Other "pers:
************ / slAKA                                                                                           :1_2:Other "pers:
************* / $*|                                                                                           :1_2:Other "pers:
************** / slAKA base                                                                                  :1_2:Other "pers:
*************** / slMultiTerm                                                                               :1_2:Other "pers:
**************** / someSL                                                                                  :1_2:Other "pers:
someSL> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
someSL> MATCH (COK): Other "person"
someSL> VALUE: ((["person"],0),[])

**************** \ someSL has returned (["person"],0)                                                       :2_2:UnDeeper:
slMultiTerm> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
slMultiTerm> MATCH (COK): Other "person"
slMultiTerm> VALUE: ((["person"],0),[])

*************** \ slMultiTerm has returned (["person"],0)                                                    :2_2:UnDeeper:
slAKA base> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
slAKA base> MATCH (COK): Other "person"
slAKA base> VALUE: ((["person"],0),[])

************** \ slAKA base has returned (["person"],0)                                                       :2_2:UnDeeper:
$*|> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
$*|> MATCH (COK): Other "person"
$*|> VALUE: ((["person"],0),[])

************* \ $*| has returned (["person"],0)                                                                :2_2:UnDeeper:
************* / |>>/recurse                                                                                    :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************* / |>>/base                                                                                       :2_2:UnDeeper:
************** / slAKA optional akapart                                                                       :2_2:UnDeeper:
*************** / |?| optional something                                                                     :2_2:UnDeeper:
**************** / |>>/recurse                                                                              :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

**************** / |>>/base                                                                                 :2_2:UnDeeper:
***************** / PAKA/akapart                                                                           :2_2:UnDeeper:
****************** / $>|                                                                                  :2_2:UnDeeper:
******************* / Aka Token                                                                          :2_2:UnDeeper:
Aka Token> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
Aka Token> MATCH (EERR): <EMPTY>
Aka Token> ERROR:
Aka Token> offset=3:
Aka Token> unexpected UnDeeper
Aka Token> expecting Aka

$>|> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=3:
$>|> unexpected UnDeeper
$>|> expecting Aka

PAKA/akapart> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
PAKA/akapart> MATCH (EERR): <EMPTY>
PAKA/akapart> ERROR:
PAKA/akapart> offset=3:
PAKA/akapart> unexpected UnDeeper
PAKA/akapart> expecting Aka

|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=3:
|>>/base> unexpected UnDeeper
|>>/base> expecting Aka

|?| optional something> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

*************** \ |?| optional something has returned (Nothing,0)                                            :2_2:UnDeeper:
slAKA optional akapart> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
slAKA optional akapart> MATCH (EOK): <EMPTY>
slAKA optional akapart> VALUE: ((Nothing,0),[])

************** \ slAKA optional akapart has returned (Nothing,0)                                              :2_2:UnDeeper:
************** > |>>/base got Nothing                                                                         :2_2:UnDeeper:
|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************* \ |>>/base has returned (Nothing,0)                                                              :2_2:UnDeeper:
************* / |>>/recurse                                                                                    :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************* / |>>/base                                                                                       :2_2:UnDeeper:
************** / slAKA optional typically                                                                     :2_2:UnDeeper:
*************** / |?| optional something                                                                     :2_2:UnDeeper:
**************** / |>>/recurse                                                                              :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

**************** / |>>/base                                                                                 :2_2:UnDeeper:
***************** / typically                                                                              :2_2:UnDeeper:
****************** / $>|                                                                                  :2_2:UnDeeper:
$>|> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=3:
$>|> unexpected UnDeeper
$>|> expecting Typically

typically> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
typically> MATCH (EERR): <EMPTY>
typically> ERROR:
typically> offset=3:
typically> unexpected UnDeeper
typically> expecting Typically

|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=3:
|>>/base> unexpected UnDeeper
|>>/base> expecting Typically

|?| optional something> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

*************** \ |?| optional something has returned (Nothing,0)                                            :2_2:UnDeeper:
slAKA optional typically> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
slAKA optional typically> MATCH (EOK): <EMPTY>
slAKA optional typically> VALUE: ((Nothing,0),[])

************** \ slAKA optional typically has returned (Nothing,0)                                            :2_2:UnDeeper:
************** > |>>/base got Nothing                                                                         :2_2:UnDeeper:
|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************* \ |>>/base has returned (Nothing,0)                                                              :2_2:UnDeeper:
************* > slAKA: proceeding after base and entityalias are retrieved ...                                 :2_2:UnDeeper:
************* > pAKA: entityalias = Nothing                                                                    :2_2:UnDeeper:
slAKA> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
slAKA> MATCH (COK): Other "person"
slAKA> VALUE: ((["person"],0),[])

************ \ slAKA has returned (["person"],0)                                                                :2_2:UnDeeper:
************ / undeepers                                                                                        :2_2:UnDeeper:
************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers                         :2_2:UnDeeper:
************* > sameLine: success!                                                                             :2_2:UnDeeper:
undeepers> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

************ \ undeepers has returned ()                                                                        :2_2:UnDeeper:
pAKA> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
pAKA> MATCH (COK): Other "person"
pAKA> VALUE: (["person"],[])

*********** \ pAKA has returned ["person"]                                                                       :2_2:UnDeeper:
pMultiTermAka> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
pMultiTermAka> MATCH (COK): Other "person"
pMultiTermAka> VALUE: (["person"],[])

********** \ pMultiTermAka has returned ["person"]                                                                :2_2:UnDeeper:
manyIndentation/leaf?> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
manyIndentation/leaf?> MATCH (COK): Other "person"
manyIndentation/leaf?> VALUE: (["person"],[])

********* \ manyIndentation/leaf? has returned ["person"]                                                          :2_2:UnDeeper:
********* / myindented: consuming UnDeeper                                                                         :2_2:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

********* \ myindented: consuming UnDeeper has returned UnDeeper                                                :2_1:Who:
someIndentation> IN: GoDeeper Other "person" UnDeeper Who GoD <…>
someIndentation> MATCH (COK): GoDeeper Other "person" UnDeeper
someIndentation> VALUE: (["person"],[])

******** \ someIndentation has returned ["person"]                                                               :2_1:Who:
pActor [Every,Party,TokAll]> IN: Every GoDeeper Other "person" UnDeeper W <…>
pActor [Every,Party,TokAll]> MATCH (COK): Every GoDeeper Other "person" UnDeeper
pActor [Every,Party,TokAll]> VALUE: ((Every,Leaf (("person" :| [],Nothing) :| [])),[])

******* \ pActor [Every,Party,TokAll] has returned (Every,Leaf (("person" :| [],Nothing) :| []))                  :2_1:Who:
******* / manyIndentation/leaf?                                                                                   :2_1:Who:
******** / preambleBoolStructR [Who,Which,Whose]                                                                 :2_1:Who:
********* / pBSR                                                                                                 :2_2:GoDeeper:
********** / ppp inner                                                                                          :2_2:GoDeeper:
*********** / expression                                                                                       :2_2:GoDeeper:
************ / labelPrefix                                                                                    :2_2:GoDeeper:
labelPrefix> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=5:
labelPrefix> unexpected GoDeeper
labelPrefix> expecting Other text

************ / term p                                                                                         :2_2:GoDeeper:
************* / term p/1a:label directly above                                                               :2_2:GoDeeper:
************** / $*|                                                                                        :2_2:GoDeeper:
*************** / someSL                                                                                   :2_2:GoDeeper:
**************** / pNumAsText                                                                             :2_2:GoDeeper:
pNumAsText> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=5:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=5:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=5:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=5:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

************* / term p/b:label to the left of line below, with EOL                                           :2_2:GoDeeper:
************** / someSL                                                                                     :2_2:GoDeeper:
*************** / pNumAsText                                                                               :2_2:GoDeeper:
pNumAsText> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=5:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=5:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=5:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

************* / term p/notLabelTerm                                                                          :2_2:GoDeeper:
************** / term p/2:someIndentation expr p                                                            :2_2:GoDeeper:
*************** / someIndentation                                                                          :2_2:GoDeeper:
**************** / myindented: consuming GoDeeper                                                         :2_2:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

**************** \ myindented: consuming GoDeeper has returned GoDeeper                                     :2_3:GoDeeper:
**************** / manyIndentation/leaf?                                                                    :2_3:GoDeeper:
***************** / expression                                                                             :2_3:GoDeeper:
****************** / labelPrefix                                                                          :2_3:GoDeeper:
labelPrefix> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=6:
labelPrefix> unexpected GoDeeper
labelPrefix> expecting Other text

****************** / term p                                                                               :2_3:GoDeeper:
******************* / term p/1a:label directly above                                                     :2_3:GoDeeper:
******************** / $*|                                                                              :2_3:GoDeeper:
********************* / someSL                                                                         :2_3:GoDeeper:
********************** / pNumAsText                                                                   :2_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=6:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=6:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=6:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=6:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

******************* / term p/b:label to the left of line below, with EOL                                 :2_3:GoDeeper:
******************** / someSL                                                                           :2_3:GoDeeper:
********************* / pNumAsText                                                                     :2_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=6:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=6:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=6:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

******************* / term p/notLabelTerm                                                                :2_3:GoDeeper:
******************** / term p/2:someIndentation expr p                                                  :2_3:GoDeeper:
********************* / someIndentation                                                                :2_3:GoDeeper:
********************** / myindented: consuming GoDeeper                                               :2_3:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

********************** \ myindented: consuming GoDeeper has returned GoDeeper                          :2_3:Other "is":
********************** / manyIndentation/leaf?                                                         :2_3:Other "is":
*********************** / expression                                                                  :2_3:Other "is":
************************ / labelPrefix                                                               :2_3:Other "is":
labelPrefix> IN: Other "is" GoDeeper Other "immortal" GoD <…>
labelPrefix> MATCH (COK): Other "is"
labelPrefix> VALUE: ("is",[])

************************ \ labelPrefix has returned "is"                                              :2_4:GoDeeper:
************************ / term p                                                                     :2_4:GoDeeper:
************************* / term p/1a:label directly above                                           :2_4:GoDeeper:
************************** / $*|                                                                    :2_4:GoDeeper:
*************************** / someSL                                                               :2_4:GoDeeper:
**************************** / pNumAsText                                                         :2_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=8:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=8:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=8:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=8:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

************************* / term p/b:label to the left of line below, with EOL                       :2_4:GoDeeper:
************************** / someSL                                                                 :2_4:GoDeeper:
*************************** / pNumAsText                                                           :2_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=8:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=8:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=8:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

************************* / term p/notLabelTerm                                                      :2_4:GoDeeper:
************************** / term p/2:someIndentation expr p                                        :2_4:GoDeeper:
*************************** / someIndentation                                                      :2_4:GoDeeper:
**************************** / myindented: consuming GoDeeper                                     :2_4:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

**************************** \ myindented: consuming GoDeeper has returned GoDeeper                :2_4:Other "immo:
**************************** / manyIndentation/leaf?                                               :2_4:Other "immo:
***************************** / expression                                                        :2_4:Other "immo:
****************************** / labelPrefix                                                     :2_4:Other "immo:
labelPrefix> IN: Other "immortal" GoDeeper Typically GoDe <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=10:
labelPrefix> unexpected GoDeeper

****************************** / term p                                                          :2_4:Other "immo:
******************************* / term p/1a:label directly above                                :2_4:Other "immo:
******************************** / $*|                                                         :2_4:Other "immo:
********************************* / someSL                                                    :2_4:Other "immo:
********************************** / pNumAsText                                                :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

********************************* \ someSL has returned (["immortal"],0)                       :2_5:GoDeeper:
********************************* / pNumAsText                                                 :2_5:GoDeeper:
pNumAsText> IN: GoDeeper Typically GoDeeper Other "false <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (CERR): Other "immortal"
$*|> ERROR:
$*|> offset=10:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/1a:label directly above> MATCH (CERR): Other "immortal"
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=10:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

******************************* / term p/b:label to the left of line below, with EOL            :2_4:Other "immo:
******************************** / someSL                                                      :2_4:Other "immo:
********************************* / pNumAsText                                                  :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

******************************** \ someSL has returned (["immortal"],0)                         :2_5:GoDeeper:
******************************** / undeepers                                                    :2_5:GoDeeper:
********************************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers :2_5:GoDeeper:
********************************* > sameLine: success!                                         :2_5:GoDeeper:
undeepers> IN: GoDeeper Typically GoDeeper Other "false <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

******************************** \ undeepers has returned ()                                    :2_5:GoDeeper:
******************************** / matching EOL                                                 :2_5:GoDeeper:
matching EOL> IN: GoDeeper Typically GoDeeper Other "false <…>
matching EOL> MATCH (EERR): <EMPTY>
matching EOL> ERROR:
matching EOL> offset=10:
matching EOL> unexpected GoDeeper
matching EOL> expecting EOL

term p/b:label to the left of line below, with EOL> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/b:label to the left of line below, with EOL> MATCH (CERR): Other "immortal"
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=10:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting EOL

******************************* / term p/notLabelTerm                                           :2_4:Other "immo:
******************************** / term p/2:someIndentation expr p                             :2_4:Other "immo:
********************************* / someIndentation                                           :2_4:Other "immo:
********************************** / myindented: consuming GoDeeper                          :2_4:Other "immo:
myindented: consuming GoDeeper> IN: Other "immortal" GoDeeper Typically GoDe <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=9:
myindented: consuming GoDeeper> unexpected Other "immortal"
myindented: consuming GoDeeper> expecting GoDeeper

someIndentation> IN: Other "immortal" GoDeeper Typically GoDe <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=9:
someIndentation> unexpected Other "immortal"
someIndentation> expecting GoDeeper

term p/2:someIndentation expr p> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/2:someIndentation expr p> MATCH (EERR): <EMPTY>
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=9:
term p/2:someIndentation expr p> unexpected Other "immortal"
term p/2:someIndentation expr p> expecting GoDeeper

******************************** / term p/3:plain p                                            :2_4:Other "immo:
********************************* / pRelPred                                                  :2_4:Other "immo:
********************************** / slRelPred                                               :2_4:Other "immo:
*********************************** / nested simpleHorn                                     :2_4:Other "immo:
************************************ > |^|                                                 :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slMultiTerm                                       :2_4:Other "immo:
************************************** / someSL                                          :2_4:Other "immo:
*************************************** / pNumAsText                                      :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

************************************** \ someSL has returned (["immortal"],0)             :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

************************************* \ slMultiTerm has returned (["immortal"],0)          :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************ \ $*| has returned (["immortal"],0)                    :2_5:GoDeeper:
************************************ / |^| deeps                                            :2_5:GoDeeper:
|^| deeps> IN: GoDeeper Typically GoDeeper Other "false <…>
|^| deeps> MATCH (COK): GoDeeper
|^| deeps> VALUE: (([()],1),[])

************************************ \ |^| deeps has returned ([()],1)                       :2_5:Typically:
nested simpleHorn> IN: Other "immortal" GoDeeper Typically GoDe <…>
nested simpleHorn> MATCH (CERR): Other "immortal" GoDeeper
nested simpleHorn> ERROR:
nested simpleHorn> offset=11:
nested simpleHorn> unexpected Typically
nested simpleHorn> expecting GoDeeper or Means

*********************************** / RPConstraint                                          :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slMultiTerm                                       :2_4:Other "immo:
************************************** / someSL                                          :2_4:Other "immo:
*************************************** / pNumAsText                                      :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

************************************** \ someSL has returned (["immortal"],0)             :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

************************************* \ slMultiTerm has returned (["immortal"],0)          :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************ \ $*| has returned (["immortal"],0)                    :2_5:GoDeeper:
************************************ / |>| calling $>>                                      :2_5:GoDeeper:
************************************* / |>>/recurse                                        :2_5:GoDeeper:
************************************** / |>>/recurse                                       :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                          :2_5:Typically:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=11:
|>>/base> unexpected Typically
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>>/recurse> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/recurse> MATCH (CERR): GoDeeper
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

************************************* / |>>/base                                           :2_5:GoDeeper:
|>>/base> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=10:
|>>/base> unexpected GoDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: GoDeeper Typically GoDeeper Other "false <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=11:
|>| calling $>>> unexpected Typically
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPConstraint> IN: Other "immortal" GoDeeper Typically GoDe <…>
RPConstraint> MATCH (CERR): Other "immortal"
RPConstraint> ERROR:
RPConstraint> offset=11:
RPConstraint> unexpected Typically
RPConstraint> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPBoolStructR                                         :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slMultiTerm                                       :2_4:Other "immo:
************************************** / someSL                                          :2_4:Other "immo:
*************************************** / pNumAsText                                      :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

************************************** \ someSL has returned (["immortal"],0)             :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

************************************* \ slMultiTerm has returned (["immortal"],0)          :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************ \ $*| has returned (["immortal"],0)                    :2_5:GoDeeper:
************************************ / |>| calling $>>                                      :2_5:GoDeeper:
************************************* / |>>/recurse                                        :2_5:GoDeeper:
************************************** / |>>/recurse                                       :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                          :2_5:Typically:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=11:
|>>/base> unexpected Typically
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>>/recurse> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/recurse> MATCH (CERR): GoDeeper
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

************************************* / |>>/base                                           :2_5:GoDeeper:
|>>/base> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=10:
|>>/base> unexpected GoDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: GoDeeper Typically GoDeeper Other "false <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=11:
|>| calling $>>> unexpected Typically
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPBoolStructR> IN: Other "immortal" GoDeeper Typically GoDe <…>
RPBoolStructR> MATCH (CERR): Other "immortal"
RPBoolStructR> ERROR:
RPBoolStructR> offset=11:
RPBoolStructR> unexpected Typically
RPBoolStructR> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPMT                                                  :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slAKA                                             :2_4:Other "immo:
************************************** / $*|                                             :2_4:Other "immo:
*************************************** / slAKA base                                    :2_4:Other "immo:
**************************************** / slMultiTerm                                 :2_4:Other "immo:
***************************************** / someSL                                    :2_4:Other "immo:
****************************************** / pNumAsText                                :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

***************************************** \ someSL has returned (["immortal"],0)       :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

**************************************** \ slMultiTerm has returned (["immortal"],0)    :2_5:GoDeeper:
slAKA base> IN: Other "immortal" GoDeeper Typically GoDe <…>
slAKA base> MATCH (COK): Other "immortal"
slAKA base> VALUE: ((["immortal"],0),[])

*************************************** \ slAKA base has returned (["immortal"],0)       :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************** \ $*| has returned (["immortal"],0)                :2_5:GoDeeper:
************************************** / |>>/recurse                                      :2_5:GoDeeper:
*************************************** / |>>/recurse                                     :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

*************************************** / |>>/base                                        :2_5:Typically:
**************************************** / slAKA optional akapart                        :2_5:Typically:
***************************************** / |?| optional something                      :2_5:Typically:
****************************************** / |>>/recurse                               :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

****************************************** / |>>/base                                  :2_5:Typically:
******************************************* / PAKA/akapart                            :2_5:Typically:
******************************************** / $>|                                   :2_5:Typically:
********************************************* / Aka Token                           :2_5:Typically:
Aka Token> IN: Typically GoDeeper Other "false" UnDeepe <…>
Aka Token> MATCH (EERR): <EMPTY>
Aka Token> ERROR:
Aka Token> offset=11:
Aka Token> unexpected Typically
Aka Token> expecting Aka

$>|> IN: Typically GoDeeper Other "false" UnDeepe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=11:
$>|> unexpected Typically
$>|> expecting Aka

PAKA/akapart> IN: Typically GoDeeper Other "false" UnDeepe <…>
PAKA/akapart> MATCH (EERR): <EMPTY>
PAKA/akapart> ERROR:
PAKA/akapart> offset=11:
PAKA/akapart> unexpected Typically
PAKA/akapart> expecting Aka

|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=11:
|>>/base> unexpected Typically
|>>/base> expecting Aka

|?| optional something> IN: Typically GoDeeper Other "false" UnDeepe <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

***************************************** \ |?| optional something has returned (Nothing,0) :2_5:Typically:
slAKA optional akapart> IN: Typically GoDeeper Other "false" UnDeepe <…>
slAKA optional akapart> MATCH (EOK): <EMPTY>
slAKA optional akapart> VALUE: ((Nothing,0),[])

**************************************** \ slAKA optional akapart has returned (Nothing,0) :2_5:Typically:
**************************************** > |>>/base got Nothing                          :2_5:Typically:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

*************************************** \ |>>/base has returned (Nothing,0)               :2_5:Typically:
|>>/recurse> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/recurse> MATCH (COK): GoDeeper
|>>/recurse> VALUE: ((Nothing,1),[])

************************************** \ |>>/recurse has returned (Nothing,1)              :2_5:Typically:
************************************** / |>>/recurse                                       :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                          :2_5:Typically:
*************************************** / slAKA optional typically                        :2_5:Typically:
**************************************** / |?| optional something                        :2_5:Typically:
***************************************** / |>>/recurse                                 :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

***************************************** / |>>/base                                    :2_5:Typically:
****************************************** / typically                                 :2_5:Typically:
******************************************* / $>|                                     :2_5:Typically:
$>|> IN: Typically GoDeeper Other "false" UnDeepe <…>
$>|> MATCH (COK): Typically
$>|> VALUE: (Typically,[])

******************************************* \ $>| has returned Typically               :2_6:GoDeeper:
******************************************* / |>>/recurse                              :2_6:GoDeeper:
******************************************** / |>>/recurse                             :2_6:Other "fals:
|>>/recurse> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=13:
|>>/recurse> unexpected Other "false"
|>>/recurse> expecting GoDeeper

******************************************** / |>>/base                                :2_6:Other "fals:
********************************************* / slMultiTerm                           :2_6:Other "fals:
********************************************** / someSL                              :2_6:Other "fals:
someSL> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
someSL> MATCH (COK): Other "false"
someSL> VALUE: ((["false"],0),[])

********************************************** \ someSL has returned (["false"],0) :3_3:UnDeeper:
slMultiTerm> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
slMultiTerm> MATCH (COK): Other "false"
slMultiTerm> VALUE: ((["false"],0),[])

********************************************* \ slMultiTerm has returned (["false"],0) :3_3:UnDeeper:
********************************************* > |>>/base got ["false"]           :3_3:UnDeeper:
|>>/base> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
|>>/base> MATCH (COK): Other "false"
|>>/base> VALUE: ((["false"],0),[])

******************************************** \ |>>/base has returned (["false"],0) :3_3:UnDeeper:
|>>/recurse> IN: GoDeeper Other "false" UnDeeper UnDeeper <…>
|>>/recurse> MATCH (COK): GoDeeper Other "false"
|>>/recurse> VALUE: ((["false"],1),[])

******************************************* \ |>>/recurse has returned (["false"],1) :3_3:UnDeeper:
typically> IN: Typically GoDeeper Other "false" UnDeepe <…>
typically> MATCH (COK): Typically GoDeeper Other "false"
typically> VALUE: ((["false"],1),[])

****************************************** \ typically has returned (["false"],1)   :3_3:UnDeeper:
****************************************** > |>>/base got ["false"]                 :3_3:UnDeeper:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (COK): Typically GoDeeper Other "false"
|>>/base> VALUE: ((["false"],1),[])

***************************************** \ |>>/base has returned (["false"],1)      :3_3:UnDeeper:
|?| optional something> IN: Typically GoDeeper Other "false" UnDeepe <…>
|?| optional something> MATCH (COK): Typically GoDeeper Other "false"
|?| optional something> VALUE: ((Just ["false"],1),[])

**************************************** \ |?| optional something has returned (Just ["false"],1) :3_3:UnDeeper:
slAKA optional typically> IN: Typically GoDeeper Other "false" UnDeepe <…>
slAKA optional typically> MATCH (COK): Typically GoDeeper Other "false"
slAKA optional typically> VALUE: ((Just ["false"],1),[])

*************************************** \ slAKA optional typically has returned (Just ["false"],1) :3_3:UnDeeper:
*************************************** > |>>/base got Just ["false"]                  :3_3:UnDeeper:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (COK): Typically GoDeeper Other "false"
|>>/base> VALUE: ((Just ["false"],1),[])

************************************** \ |>>/base has returned (Just ["false"],1)       :3_3:UnDeeper:
************************************** > slAKA: proceeding after base and entityalias are retrieved ... :3_3:UnDeeper:
************************************** > pAKA: entityalias = Nothing                    :3_3:UnDeeper:
slAKA> IN: Other "immortal" GoDeeper Typically GoDe <…>
slAKA> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
slAKA> VALUE: ((["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************************* \ slAKA has returned (["immortal"],2)              :3_3:UnDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
$*|> VALUE: ((["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************************ \ $*| has returned (["immortal"],2)                  :3_3:UnDeeper:
RPMT> IN: Other "immortal" GoDeeper Typically GoDe <…>
RPMT> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
RPMT> VALUE: ((RPMT ["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*********************************** \ RPMT has returned (RPMT ["immortal"],2)              :3_3:UnDeeper:
slRelPred> IN: Other "immortal" GoDeeper Typically GoDe <…>
slRelPred> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
slRelPred> VALUE: ((RPMT ["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************************** \ slRelPred has returned (RPMT ["immortal"],2)           :3_3:UnDeeper:
********************************** / undeepers                                              :3_3:UnDeeper:
*********************************** > sameLine/undeepers: reached end of line; now need to clear 2 UnDeepers :3_3:UnDeeper:
*********************************** > sameLine: success!                                       :3_5:UnDeeper:
undeepers> IN: UnDeeper UnDeeper UnDeeper UnDeeper Or G <…>
undeepers> MATCH (COK): UnDeeper UnDeeper
undeepers> VALUE: ((),[])

********************************** \ undeepers has returned ()                                  :3_5:UnDeeper:
pRelPred> IN: Other "immortal" GoDeeper Typically GoDe <…>
pRelPred> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
pRelPred> VALUE: (RPMT ["immortal"],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************************* \ pRelPred has returned RPMT ["immortal"]                      :3_5:UnDeeper:
term p/3:plain p> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/3:plain p> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
term p/3:plain p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************************** \ term p/3:plain p has returned MyLeaf (RPMT ["immortal"])       :3_5:UnDeeper:
term p/notLabelTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/notLabelTerm> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["immortal"])      :3_5:UnDeeper:
term p> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
term p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

****************************** \ term p has returned MyLeaf (RPMT ["immortal"])                     :3_5:UnDeeper:
****************************** / binary(Or)                                                         :3_5:UnDeeper:
binary(Or)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=16:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

****************************** / binary(And)                                                        :3_5:UnDeeper:
binary(And)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=16:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

****************************** / binary(SetLess)                                                    :3_5:UnDeeper:
binary(SetLess)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=16:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

****************************** / binary(SetPlus)                                                    :3_5:UnDeeper:
binary(SetPlus)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=16:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "immortal" GoDeeper Typically GoDe <…>
expression> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
expression> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

***************************** \ expression has returned MyLeaf (RPMT ["immortal"])                   :3_5:UnDeeper:
manyIndentation/leaf?> IN: Other "immortal" GoDeeper Typically GoDe <…>
manyIndentation/leaf?> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
manyIndentation/leaf?> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

**************************** \ manyIndentation/leaf? has returned MyLeaf (RPMT ["immortal"])          :3_5:UnDeeper:
**************************** / myindented: consuming UnDeeper                                         :3_5:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

**************************** \ myindented: consuming UnDeeper has returned UnDeeper                     :3_6:UnDeeper:
someIndentation> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
someIndentation> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
someIndentation> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*************************** \ someIndentation has returned MyLeaf (RPMT ["immortal"])                    :3_6:UnDeeper:
term p/2:someIndentation expr p> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
term p/2:someIndentation expr p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************** \ term p/2:someIndentation expr p has returned MyLeaf (RPMT ["immortal"])      :3_6:UnDeeper:
term p/notLabelTerm> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["immortal"])                    :3_6:UnDeeper:
term p> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
term p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************ \ term p has returned MyLeaf (RPMT ["immortal"])                                   :3_6:UnDeeper:
************************ / binary(Or)                                                                       :3_6:UnDeeper:
binary(Or)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=17:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

************************ / binary(And)                                                                      :3_6:UnDeeper:
binary(And)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=17:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

************************ / binary(SetLess)                                                                  :3_6:UnDeeper:
binary(SetLess)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=17:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

************************ / binary(SetPlus)                                                                  :3_6:UnDeeper:
binary(SetPlus)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=17:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "is" GoDeeper Other "immortal" GoD <…>
expression> MATCH (COK): Other "is" GoDeeper Other "immortal" GoD <…>
expression> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*********************** \ expression has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))                :3_6:UnDeeper:
manyIndentation/leaf?> IN: Other "is" GoDeeper Other "immortal" GoD <…>
manyIndentation/leaf?> MATCH (COK): Other "is" GoDeeper Other "immortal" GoD <…>
manyIndentation/leaf?> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************** \ manyIndentation/leaf? has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))       :3_6:UnDeeper:
********************** / myindented: consuming UnDeeper                                                       :3_6:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

********************** \ myindented: consuming UnDeeper has returned UnDeeper                        :3_2:Or:
someIndentation> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
someIndentation> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
someIndentation> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************* \ someIndentation has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))      :3_2:Or:
term p/2:someIndentation expr p> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
term p/2:someIndentation expr p> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************** \ term p/2:someIndentation expr p has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"])) :3_2:Or:
term p/notLabelTerm> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
term p/notLabelTerm> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************* \ term p/notLabelTerm has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))      :3_2:Or:
term p> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
term p> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

****************** \ term p has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))                     :3_2:Or:
****************** / binary(Or)                                                                          :3_2:Or:
binary(Or)> IN: Or GoDeeper Other "has" GoDeeper Other " <…>
binary(Or)> MATCH (COK): Or
binary(Or)> VALUE: (Or,[])

****************** \ binary(Or) has returned Or                                                           :3_3:GoDeeper:
****************** / term p                                                                               :3_3:GoDeeper:
******************* / term p/1a:label directly above                                                     :3_3:GoDeeper:
******************** / $*|                                                                              :3_3:GoDeeper:
********************* / someSL                                                                         :3_3:GoDeeper:
********************** / pNumAsText                                                                   :3_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=19:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=19:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=19:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=19:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

******************* / term p/b:label to the left of line below, with EOL                                 :3_3:GoDeeper:
******************** / someSL                                                                           :3_3:GoDeeper:
********************* / pNumAsText                                                                     :3_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=19:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=19:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=19:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

******************* / term p/notLabelTerm                                                                :3_3:GoDeeper:
******************** / term p/2:someIndentation expr p                                                  :3_3:GoDeeper:
********************* / someIndentation                                                                :3_3:GoDeeper:
********************** / myindented: consuming GoDeeper                                               :3_3:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

********************** \ myindented: consuming GoDeeper has returned GoDeeper                          :3_3:Other "has":
********************** / manyIndentation/leaf?                                                         :3_3:Other "has":
*********************** / expression                                                                  :3_3:Other "has":
************************ / labelPrefix                                                               :3_3:Other "has":
labelPrefix> IN: Other "has" GoDeeper Other "health insur <…>
labelPrefix> MATCH (COK): Other "has"
labelPrefix> VALUE: ("has",[])

************************ \ labelPrefix has returned "has"                                             :3_4:GoDeeper:
************************ / term p                                                                     :3_4:GoDeeper:
************************* / term p/1a:label directly above                                           :3_4:GoDeeper:
************************** / $*|                                                                    :3_4:GoDeeper:
*************************** / someSL                                                               :3_4:GoDeeper:
**************************** / pNumAsText                                                         :3_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "health insurance" UnDeep <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=21:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "health insurance" UnDeep <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=21:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "health insurance" UnDeep <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=21:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=21:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

************************* / term p/b:label to the left of line below, with EOL                       :3_4:GoDeeper:
************************** / someSL                                                                 :3_4:GoDeeper:
*************************** / pNumAsText                                                           :3_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "health insurance" UnDeep <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=21:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "health insurance" UnDeep <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=21:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=21:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

************************* / term p/notLabelTerm                                                      :3_4:GoDeeper:
************************** / term p/2:someIndentation expr p                                        :3_4:GoDeeper:
*************************** / someIndentation                                                      :3_4:GoDeeper:
**************************** / myindented: consuming GoDeeper                                     :3_4:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "health insurance" UnDeep <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

**************************** \ myindented: consuming GoDeeper has returned GoDeeper                :3_4:Other "heal:
**************************** / manyIndentation/leaf?                                               :3_4:Other "heal:
***************************** / expression                                                        :3_4:Other "heal:
****************************** / labelPrefix                                                     :3_4:Other "heal:
labelPrefix> IN: Other "health insurance" UnDeeper UnDeep <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=23:
labelPrefix> unexpected UnDeeper

****************************** / term p                                                          :3_4:Other "heal:
******************************* / term p/1a:label directly above                                :3_4:Other "heal:
******************************** / $*|                                                         :3_4:Other "heal:
********************************* / someSL                                                    :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

********************************* \ someSL has returned (["health insurance"],0)           :4_2:UnDeeper:
********************************* / pNumAsText                                             :4_2:UnDeeper:
pNumAsText> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=23:
pNumAsText> unexpected UnDeeper
pNumAsText> expecting number

$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (CERR): Other "health insurance"
$*|> ERROR:
$*|> offset=23:
$*|> unexpected UnDeeper
$*|> expecting GoDeeper or other text or number

term p/1a:label directly above> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/1a:label directly above> MATCH (CERR): Other "health insurance"
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=23:
term p/1a:label directly above> unexpected UnDeeper
term p/1a:label directly above> expecting GoDeeper or other text or number

******************************* / term p/b:label to the left of line below, with EOL            :3_4:Other "heal:
******************************** / someSL                                                      :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

******************************** \ someSL has returned (["health insurance"],0)             :4_2:UnDeeper:
******************************** / undeepers                                                :4_2:UnDeeper:
********************************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers :4_2:UnDeeper:
********************************* > sameLine: success!                                     :4_2:UnDeeper:
undeepers> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

******************************** \ undeepers has returned ()                                :4_2:UnDeeper:
******************************** / matching EOL                                             :4_2:UnDeeper:
matching EOL> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
matching EOL> MATCH (EERR): <EMPTY>
matching EOL> ERROR:
matching EOL> offset=23:
matching EOL> unexpected UnDeeper
matching EOL> expecting EOL

term p/b:label to the left of line below, with EOL> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/b:label to the left of line below, with EOL> MATCH (CERR): Other "health insurance"
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=23:
term p/b:label to the left of line below, with EOL> unexpected UnDeeper
term p/b:label to the left of line below, with EOL> expecting EOL or GoDeeper

******************************* / term p/notLabelTerm                                           :3_4:Other "heal:
******************************** / term p/2:someIndentation expr p                             :3_4:Other "heal:
********************************* / someIndentation                                           :3_4:Other "heal:
********************************** / myindented: consuming GoDeeper                          :3_4:Other "heal:
myindented: consuming GoDeeper> IN: Other "health insurance" UnDeeper UnDeep <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=22:
myindented: consuming GoDeeper> unexpected Other "health insurance"
myindented: consuming GoDeeper> expecting GoDeeper

someIndentation> IN: Other "health insurance" UnDeeper UnDeep <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=22:
someIndentation> unexpected Other "health insurance"
someIndentation> expecting GoDeeper

term p/2:someIndentation expr p> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/2:someIndentation expr p> MATCH (EERR): <EMPTY>
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=22:
term p/2:someIndentation expr p> unexpected Other "health insurance"
term p/2:someIndentation expr p> expecting GoDeeper

******************************** / term p/3:plain p                                            :3_4:Other "heal:
********************************* / pRelPred                                                  :3_4:Other "heal:
********************************** / slRelPred                                               :3_4:Other "heal:
*********************************** / nested simpleHorn                                     :3_4:Other "heal:
************************************ > |^|                                                 :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slMultiTerm                                       :3_4:Other "heal:
************************************** / someSL                                          :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

************************************* \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
************************************ / |^| deeps                                        :4_2:UnDeeper:
|^| deeps> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|^| deeps> MATCH (COK): UnDeeper UnDeeper UnDeeper
|^| deeps> VALUE: (([(),(),()],-3),[])

************************************ \ |^| deeps has returned ([(),(),()],-3)        :4_1:May:
nested simpleHorn> IN: Other "health insurance" UnDeeper UnDeep <…>
nested simpleHorn> MATCH (CERR): Other "health insurance" UnDeeper UnDeep <…>
nested simpleHorn> ERROR:
nested simpleHorn> offset=26:
nested simpleHorn> unexpected May
nested simpleHorn> expecting Means or UnDeeper

*********************************** / RPConstraint                                          :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slMultiTerm                                       :3_4:Other "heal:
************************************** / someSL                                          :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

************************************* \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
************************************ / |>| calling $>>                                  :4_2:UnDeeper:
************************************* / |>>/recurse                                    :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************* / |>>/base                                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=23:
|>| calling $>>> unexpected UnDeeper
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPConstraint> IN: Other "health insurance" UnDeeper UnDeep <…>
RPConstraint> MATCH (CERR): Other "health insurance"
RPConstraint> ERROR:
RPConstraint> offset=23:
RPConstraint> unexpected UnDeeper
RPConstraint> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPBoolStructR                                         :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slMultiTerm                                       :3_4:Other "heal:
************************************** / someSL                                          :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

************************************* \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
************************************ / |>| calling $>>                                  :4_2:UnDeeper:
************************************* / |>>/recurse                                    :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************* / |>>/base                                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=23:
|>| calling $>>> unexpected UnDeeper
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPBoolStructR> IN: Other "health insurance" UnDeeper UnDeep <…>
RPBoolStructR> MATCH (CERR): Other "health insurance"
RPBoolStructR> ERROR:
RPBoolStructR> offset=23:
RPBoolStructR> unexpected UnDeeper
RPBoolStructR> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPMT                                                  :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slAKA                                             :3_4:Other "heal:
************************************** / $*|                                             :3_4:Other "heal:
*************************************** / slAKA base                                    :3_4:Other "heal:
**************************************** / slMultiTerm                                 :3_4:Other "heal:
***************************************** / someSL                                    :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

***************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

**************************************** \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
slAKA base> IN: Other "health insurance" UnDeeper UnDeep <…>
slAKA base> MATCH (COK): Other "health insurance"
slAKA base> VALUE: ((["health insurance"],0),[])

*************************************** \ slAKA base has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************** \ $*| has returned (["health insurance"],0)    :4_2:UnDeeper:
************************************** / |>>/recurse                                  :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                     :4_2:UnDeeper:
*************************************** / slAKA optional akapart                     :4_2:UnDeeper:
**************************************** / |?| optional something                   :4_2:UnDeeper:
***************************************** / |>>/recurse                            :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

***************************************** / |>>/base                               :4_2:UnDeeper:
****************************************** / PAKA/akapart                         :4_2:UnDeeper:
******************************************* / $>|                                :4_2:UnDeeper:
******************************************** / Aka Token                        :4_2:UnDeeper:
Aka Token> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
Aka Token> MATCH (EERR): <EMPTY>
Aka Token> ERROR:
Aka Token> offset=23:
Aka Token> unexpected UnDeeper
Aka Token> expecting Aka

$>|> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=23:
$>|> unexpected UnDeeper
$>|> expecting Aka

PAKA/akapart> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
PAKA/akapart> MATCH (EERR): <EMPTY>
PAKA/akapart> ERROR:
PAKA/akapart> offset=23:
PAKA/akapart> unexpected UnDeeper
PAKA/akapart> expecting Aka

|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Aka

|?| optional something> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

**************************************** \ |?| optional something has returned (Nothing,0) :4_2:UnDeeper:
slAKA optional akapart> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
slAKA optional akapart> MATCH (EOK): <EMPTY>
slAKA optional akapart> VALUE: ((Nothing,0),[])

*************************************** \ slAKA optional akapart has returned (Nothing,0) :4_2:UnDeeper:
*************************************** > |>>/base got Nothing                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************************************** \ |>>/base has returned (Nothing,0)            :4_2:UnDeeper:
************************************** / |>>/recurse                                  :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                     :4_2:UnDeeper:
*************************************** / slAKA optional typically                   :4_2:UnDeeper:
**************************************** / |?| optional something                   :4_2:UnDeeper:
***************************************** / |>>/recurse                            :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

***************************************** / |>>/base                               :4_2:UnDeeper:
****************************************** / typically                            :4_2:UnDeeper:
******************************************* / $>|                                :4_2:UnDeeper:
$>|> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=23:
$>|> unexpected UnDeeper
$>|> expecting Typically

typically> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
typically> MATCH (EERR): <EMPTY>
typically> ERROR:
typically> offset=23:
typically> unexpected UnDeeper
typically> expecting Typically

|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Typically

|?| optional something> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

**************************************** \ |?| optional something has returned (Nothing,0) :4_2:UnDeeper:
slAKA optional typically> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
slAKA optional typically> MATCH (EOK): <EMPTY>
slAKA optional typically> VALUE: ((Nothing,0),[])

*************************************** \ slAKA optional typically has returned (Nothing,0) :4_2:UnDeeper:
*************************************** > |>>/base got Nothing                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************************************** \ |>>/base has returned (Nothing,0)            :4_2:UnDeeper:
************************************** > slAKA: proceeding after base and entityalias are retrieved ... :4_2:UnDeeper:
************************************** > pAKA: entityalias = Nothing                  :4_2:UnDeeper:
slAKA> IN: Other "health insurance" UnDeeper UnDeep <…>
slAKA> MATCH (COK): Other "health insurance"
slAKA> VALUE: ((["health insurance"],0),[])

************************************* \ slAKA has returned (["health insurance"],0)    :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
RPMT> IN: Other "health insurance" UnDeeper UnDeep <…>
RPMT> MATCH (COK): Other "health insurance"
RPMT> VALUE: ((RPMT ["health insurance"],0),[])

*********************************** \ RPMT has returned (RPMT ["health insurance"],0)    :4_2:UnDeeper:
slRelPred> IN: Other "health insurance" UnDeeper UnDeep <…>
slRelPred> MATCH (COK): Other "health insurance"
slRelPred> VALUE: ((RPMT ["health insurance"],0),[])

********************************** \ slRelPred has returned (RPMT ["health insurance"],0) :4_2:UnDeeper:
********************************** / undeepers                                            :4_2:UnDeeper:
*********************************** > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers :4_2:UnDeeper:
*********************************** > sameLine: success!                                 :4_2:UnDeeper:
undeepers> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

********************************** \ undeepers has returned ()                            :4_2:UnDeeper:
pRelPred> IN: Other "health insurance" UnDeeper UnDeep <…>
pRelPred> MATCH (COK): Other "health insurance"
pRelPred> VALUE: (RPMT ["health insurance"],[])

********************************* \ pRelPred has returned RPMT ["health insurance"]        :4_2:UnDeeper:
term p/3:plain p> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/3:plain p> MATCH (COK): Other "health insurance"
term p/3:plain p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

******************************** \ term p/3:plain p has returned MyLeaf (RPMT ["health insurance"]) :4_2:UnDeeper:
term p/notLabelTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/notLabelTerm> MATCH (COK): Other "health insurance"
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

******************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["health insurance"]) :4_2:UnDeeper:
term p> IN: Other "health insurance" UnDeeper UnDeep <…>
term p> MATCH (COK): Other "health insurance"
term p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

****************************** \ term p has returned MyLeaf (RPMT ["health insurance"])       :4_2:UnDeeper:
****************************** / binary(Or)                                                   :4_2:UnDeeper:
binary(Or)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=23:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

****************************** / binary(And)                                                  :4_2:UnDeeper:
binary(And)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=23:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

****************************** / binary(SetLess)                                              :4_2:UnDeeper:
binary(SetLess)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=23:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

****************************** / binary(SetPlus)                                              :4_2:UnDeeper:
binary(SetPlus)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=23:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "health insurance" UnDeeper UnDeep <…>
expression> MATCH (COK): Other "health insurance"
expression> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

***************************** \ expression has returned MyLeaf (RPMT ["health insurance"])     :4_2:UnDeeper:
manyIndentation/leaf?> IN: Other "health insurance" UnDeeper UnDeep <…>
manyIndentation/leaf?> MATCH (COK): Other "health insurance"
manyIndentation/leaf?> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

**************************** \ manyIndentation/leaf? has returned MyLeaf (RPMT ["health insurance"]) :4_2:UnDeeper:
**************************** / myindented: consuming UnDeeper                                   :4_2:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

**************************** \ myindented: consuming UnDeeper has returned UnDeeper               :4_3:UnDeeper:
someIndentation> IN: GoDeeper Other "health insurance" UnDeep <…>
someIndentation> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
someIndentation> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

*************************** \ someIndentation has returned MyLeaf (RPMT ["health insurance"])      :4_3:UnDeeper:
term p/2:someIndentation expr p> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
term p/2:someIndentation expr p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

************************** \ term p/2:someIndentation expr p has returned MyLeaf (RPMT ["health insurance"]) :4_3:UnDeeper:
term p/notLabelTerm> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["health insurance"])      :4_3:UnDeeper:
term p> IN: GoDeeper Other "health insurance" UnDeep <…>
term p> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
term p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

************************ \ term p has returned MyLeaf (RPMT ["health insurance"])                     :4_3:UnDeeper:
************************ / binary(Or)                                                                 :4_3:UnDeeper:
binary(Or)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=24:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

************************ / binary(And)                                                                :4_3:UnDeeper:
binary(And)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=24:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

************************ / binary(SetLess)                                                            :4_3:UnDeeper:
binary(SetLess)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=24:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

************************ / binary(SetPlus)                                                            :4_3:UnDeeper:
binary(SetPlus)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=24:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "has" GoDeeper Other "health insur <…>
expression> MATCH (COK): Other "has" GoDeeper Other "health insur <…>
expression> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

*********************** \ expression has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])) :4_3:UnDeeper:
manyIndentation/leaf?> IN: Other "has" GoDeeper Other "health insur <…>
manyIndentation/leaf?> MATCH (COK): Other "has" GoDeeper Other "health insur <…>
manyIndentation/leaf?> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

********************** \ manyIndentation/leaf? has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])) :4_3:UnDeeper:
********************** / myindented: consuming UnDeeper                                                 :4_3:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

********************** \ myindented: consuming UnDeeper has returned UnDeeper                             :4_4:UnDeeper:
someIndentation> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
someIndentation> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
someIndentation> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

********************* \ someIndentation has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))  :4_4:UnDeeper:
term p/2:someIndentation expr p> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
term p/2:someIndentation expr p> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

******************** \ term p/2:someIndentation expr p has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])) :4_4:UnDeeper:
term p/notLabelTerm> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
term p/notLabelTerm> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

******************* \ term p/notLabelTerm has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))  :4_4:UnDeeper:
term p> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
term p> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

****************** \ term p has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))                 :4_4:UnDeeper:
****************** / binary(Or)                                                                               :4_4:UnDeeper:
binary(Or)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=25:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

****************** / binary(And)                                                                              :4_4:UnDeeper:
binary(And)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=25:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

****************** / binary(SetLess)                                                                          :4_4:UnDeeper:
binary(SetLess)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=25:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

****************** / binary(SetPlus)                                                                          :4_4:UnDeeper:
binary(SetPlus)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=25:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
expression> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
expression> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

***************** \ expression has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_4:UnDeeper:
manyIndentation/leaf?> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
manyIndentation/leaf?> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
manyIndentation/leaf?> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

**************** \ manyIndentation/leaf? has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_4:UnDeeper:
**************** / myindented: consuming UnDeeper                                                               :4_4:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

**************** \ myindented: consuming UnDeeper has returned UnDeeper                                  :4_1:May:
someIndentation> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someIndentation> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someIndentation> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*************** \ someIndentation has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
term p/2:someIndentation expr p> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/2:someIndentation expr p> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************** \ term p/2:someIndentation expr p has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
term p/notLabelTerm> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/notLabelTerm> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/notLabelTerm> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************* \ term p/notLabelTerm has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
term p> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************ \ term p has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
************ / binary(Or)                                                                                    :4_1:May:
binary(Or)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=26:
binary(Or)> unexpected May
binary(Or)> expecting Or

************ / binary(And)                                                                                   :4_1:May:
binary(And)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=26:
binary(And)> unexpected May
binary(And)> expecting And

************ / binary(SetLess)                                                                               :4_1:May:
binary(SetLess)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=26:
binary(SetLess)> unexpected May
binary(SetLess)> expecting SetLess

************ / binary(SetPlus)                                                                               :4_1:May:
binary(SetPlus)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=26:
binary(SetPlus)> unexpected May
binary(SetPlus)> expecting SetPlus

expression> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
expression> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
expression> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*********** \ expression has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
ppp inner> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
ppp inner> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
ppp inner> VALUE: (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********** \ ppp inner has returned Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])] :4_1:May:
pBSR> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pBSR> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pBSR> VALUE: (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********* \ pBSR has returned Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])] :4_1:May:
preambleBoolStructR [Who,Which,Whose]> IN: Who GoDeeper GoDeeper Other "is" GoDeepe <…>
preambleBoolStructR [Who,Which,Whose]> MATCH (COK): Who GoDeeper GoDeeper Other "is" GoDeepe <…>
preambleBoolStructR [Who,Which,Whose]> VALUE: ((Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******** \ preambleBoolStructR [Who,Which,Whose] has returned (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]) :4_1:May:
manyIndentation/leaf?> IN: Who GoDeeper GoDeeper Other "is" GoDeepe <…>
manyIndentation/leaf?> MATCH (COK): Who GoDeeper GoDeeper Other "is" GoDeepe <…>
manyIndentation/leaf?> VALUE: ((Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******* \ manyIndentation/leaf? has returned (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]) :4_1:May:
******* / WHERE                                                                                                   :4_1:May:
WHERE> IN: May GoDeeper Other "sharpen knives" UnDe <…>
WHERE> MATCH (EERR): <EMPTY>
WHERE> ERROR:
WHERE> offset=26:
WHERE> unexpected May
WHERE> expecting Where

******* / preambleParamText:[Having]                                                                              :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=26:
$>|> unexpected May
$>|> expecting Having

preambleParamText:[Having]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleParamText:[Having]> MATCH (EERR): <EMPTY>
preambleParamText:[Having]> ERROR:
preambleParamText:[Having]> offset=26:
preambleParamText:[Having]> unexpected May
preambleParamText:[Having]> expecting Having

******* / preambleParamText:[Given]                                                                               :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=26:
$>|> unexpected May
$>|> expecting Given

preambleParamText:[Given]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=26:
preambleParamText:[Given]> unexpected May
preambleParamText:[Given]> expecting Given

******* / preambleParamText:[Upon]                                                                                :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=26:
$>|> unexpected May
$>|> expecting Upon

preambleParamText:[Upon]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=26:
preambleParamText:[Upon]> unexpected May
preambleParamText:[Upon]> expecting Upon

******* / preambleBoolStructR [Unless]                                                                            :4_1:May:
preambleBoolStructR [Unless]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleBoolStructR [Unless]> MATCH (EERR): <EMPTY>
preambleBoolStructR [Unless]> ERROR:
preambleBoolStructR [Unless]> offset=26:
preambleBoolStructR [Unless]> unexpected May
preambleBoolStructR [Unless]> expecting Unless

******* / preambleBoolStructR [When,If]                                                                           :4_1:May:
preambleBoolStructR [When,If]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleBoolStructR [When,If]> MATCH (EERR): <EMPTY>
preambleBoolStructR [When,If]> ERROR:
preambleBoolStructR [When,If]> offset=26:
preambleBoolStructR [When,If]> unexpected May
preambleBoolStructR [When,If]> expecting If or When

******* / pTemporal/eventually                                                                                    :4_1:May:
pTemporal/eventually> IN: May GoDeeper Other "sharpen knives" UnDe <…>
pTemporal/eventually> MATCH (EERR): <EMPTY>
pTemporal/eventually> ERROR:
pTemporal/eventually> offset=26:
pTemporal/eventually> unexpected May
pTemporal/eventually> expecting Eventually

******* / pTemporal/specifically                                                                                  :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=26:
$>|> unexpected May
$>|> expecting After, Before, By, or On

pTemporal/specifically> IN: May GoDeeper Other "sharpen knives" UnDe <…>
pTemporal/specifically> MATCH (EERR): <EMPTY>
pTemporal/specifically> ERROR:
pTemporal/specifically> offset=26:
pTemporal/specifically> unexpected May
pTemporal/specifically> expecting After, Before, By, or On

******* / pTemporal/vaguely                                                                                       :4_1:May:
pTemporal/vaguely> IN: May GoDeeper Other "sharpen knives" UnDe <…>
pTemporal/vaguely> MATCH (EERR): <EMPTY>
pTemporal/vaguely> ERROR:
pTemporal/vaguely> offset=26:
pTemporal/vaguely> unexpected May
pTemporal/vaguely> expecting Other text

******* / pDA                                                                                                     :4_1:May:
******** / pAction calling dBoolStructP                                                                           :4_2:GoDeeper:
********* / dBoolStructP calling exprP                                                                           :4_2:GoDeeper:
********** / expr pParamText                                                                                    :4_2:GoDeeper:
*********** / expression                                                                                       :4_2:GoDeeper:
************ / labelPrefix                                                                                    :4_2:GoDeeper:
labelPrefix> IN: GoDeeper Other "sharpen knives" UnDeeper
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=27:
labelPrefix> unexpected GoDeeper
labelPrefix> expecting Other text

************ / term p                                                                                         :4_2:GoDeeper:
************* / term p/1a:label directly above                                                               :4_2:GoDeeper:
************** / $*|                                                                                        :4_2:GoDeeper:
*************** / someSL                                                                                   :4_2:GoDeeper:
**************** / pNumAsText                                                                             :4_2:GoDeeper:
pNumAsText> IN: GoDeeper Other "sharpen knives" UnDeeper
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=27:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "sharpen knives" UnDeeper
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=27:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "sharpen knives" UnDeeper
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=27:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "sharpen knives" UnDeeper
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=27:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

************* / term p/b:label to the left of line below, with EOL                                           :4_2:GoDeeper:
************** / someSL                                                                                     :4_2:GoDeeper:
*************** / pNumAsText                                                                               :4_2:GoDeeper:
pNumAsText> IN: GoDeeper Other "sharpen knives" UnDeeper
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=27:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "sharpen knives" UnDeeper
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=27:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "sharpen knives" UnDeeper
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=27:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

************* / term p/notLabelTerm                                                                          :4_2:GoDeeper:
************** / term p/2:someIndentation expr p                                                            :4_2:GoDeeper:
*************** / someIndentation                                                                          :4_2:GoDeeper:
**************** / myindented: consuming GoDeeper                                                         :4_2:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "sharpen knives" UnDeeper
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

**************** \ myindented: consuming GoDeeper has returned GoDeeper                                    :4_2:Other "shar:
**************** / manyIndentation/leaf?                                                                   :4_2:Other "shar:
***************** / expression                                                                            :4_2:Other "shar:
****************** / labelPrefix                                                                         :4_2:Other "shar:
labelPrefix> IN: Other "sharpen knives" UnDeeper
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=29:
labelPrefix> unexpected UnDeeper

****************** / term p                                                                              :4_2:Other "shar:
******************* / term p/1a:label directly above                                                    :4_2:Other "shar:
******************** / $*|                                                                             :4_2:Other "shar:
********************* / someSL                                                                        :4_2:Other "shar:
someSL> IN: Other "sharpen knives" UnDeeper
someSL> MATCH (COK): Other "sharpen knives"
someSL> VALUE: ((["sharpen knives"],0),[])

********************* \ someSL has returned (["sharpen knives"],0)                                     :1_2:UnDeeper:
********************* / pNumAsText                                                                     :1_2:UnDeeper:
pNumAsText> IN: UnDeeper
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=29:
pNumAsText> unexpected UnDeeper
pNumAsText> expecting number

$*|> IN: Other "sharpen knives" UnDeeper
$*|> MATCH (CERR): Other "sharpen knives"
$*|> ERROR:
$*|> offset=29:
$*|> unexpected UnDeeper
$*|> expecting GoDeeper or other text or number

term p/1a:label directly above> IN: Other "sharpen knives" UnDeeper
term p/1a:label directly above> MATCH (CERR): Other "sharpen knives"
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=29:
term p/1a:label directly above> unexpected UnDeeper
term p/1a:label directly above> expecting GoDeeper or other text or number

******************* / term p/b:label to the left of line below, with EOL                                :4_2:Other "shar:
******************** / someSL                                                                          :4_2:Other "shar:
someSL> IN: Other "sharpen knives" UnDeeper
someSL> MATCH (COK): Other "sharpen knives"
someSL> VALUE: ((["sharpen knives"],0),[])

******************** \ someSL has returned (["sharpen knives"],0)                                       :1_2:UnDeeper:
******************** / undeepers                                                                        :1_2:UnDeeper:
********************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers         :1_2:UnDeeper:
********************* > sameLine: success!                                                             :1_2:UnDeeper:
undeepers> IN: UnDeeper
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

******************** \ undeepers has returned ()                                                        :1_2:UnDeeper:
******************** / matching EOL                                                                     :1_2:UnDeeper:
matching EOL> IN: UnDeeper
matching EOL> MATCH (EERR): <EMPTY>
matching EOL> ERROR:
matching EOL> offset=29:
matching EOL> unexpected UnDeeper
matching EOL> expecting EOL

term p/b:label to the left of line below, with EOL> IN: Other "sharpen knives" UnDeeper
term p/b:label to the left of line below, with EOL> MATCH (CERR): Other "sharpen knives"
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=29:
term p/b:label to the left of line below, with EOL> unexpected UnDeeper
term p/b:label to the left of line below, with EOL> expecting EOL or GoDeeper

******************* / term p/notLabelTerm                                                               :4_2:Other "shar:
******************** / term p/2:someIndentation expr p                                                 :4_2:Other "shar:
********************* / someIndentation                                                               :4_2:Other "shar:
********************** / myindented: consuming GoDeeper                                              :4_2:Other "shar:
myindented: consuming GoDeeper> IN: Other "sharpen knives" UnDeeper
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=28:
myindented: consuming GoDeeper> unexpected Other "sharpen knives"
myindented: consuming GoDeeper> expecting GoDeeper

someIndentation> IN: Other "sharpen knives" UnDeeper
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=28:
someIndentation> unexpected Other "sharpen knives"
someIndentation> expecting GoDeeper

term p/2:someIndentation expr p> IN: Other "sharpen knives" UnDeeper
term p/2:someIndentation expr p> MATCH (EERR): <EMPTY>
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=28:
term p/2:someIndentation expr p> unexpected Other "sharpen knives"
term p/2:someIndentation expr p> expecting GoDeeper

******************** / term p/3:plain p                                                                :4_2:Other "shar:
********************* / pParamText                                                                    :4_2:Other "shar:
********************** / pParamText(flat) first line: pKeyValues                                     :4_2:Other "shar:
*********************** / pKeyValuesAka                                                             :4_2:Other "shar:
************************ / slAKA                                                                   :4_2:Other "shar:
************************* / $*|                                                                   :4_2:Other "shar:
************************** / slAKA base                                                          :4_2:Other "shar:
*************************** / slKeyValues                                                       :4_2:Other "shar:
**************************** / $*|                                                             :4_2:Other "shar:
***************************** / someSL                                                        :4_2:Other "shar:
someSL> IN: Other "sharpen knives" UnDeeper
someSL> MATCH (COK): Other "sharpen knives"
someSL> VALUE: ((["sharpen knives"],0),[])

***************************** \ someSL has returned (["sharpen knives"],0)                     :1_2:UnDeeper:
$*|> IN: Other "sharpen knives" UnDeeper
$*|> MATCH (COK): Other "sharpen knives"
$*|> VALUE: ((["sharpen knives"],0),[])

**************************** \ $*| has returned (["sharpen knives"],0)                          :1_2:UnDeeper:
**************************** / |>>/recurse                                                      :1_2:UnDeeper:
|>>/recurse> IN: UnDeeper
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=29:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

**************************** / |>>/base                                                         :1_2:UnDeeper:
***************************** / |?| optional something                                         :1_2:UnDeeper:
****************************** / |>>/recurse                                                  :1_2:UnDeeper:
|>>/recurse> IN: UnDeeper
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=29:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

****************************** / |>>/base                                                     :1_2:UnDeeper:
******************************* / slTypeSig                                                  :1_2:UnDeeper:
******************************** / $>|                                                      :1_2:UnDeeper:
$>|> IN: UnDeeper
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=29:
$>|> unexpected UnDeeper
$>|> expecting Is or TypeSeparator

slTypeSig> IN: UnDeeper
slTypeSig> MATCH (EERR): <EMPTY>
slTypeSig> ERROR:
slTypeSig> offset=29:
slTypeSig> unexpected UnDeeper
slTypeSig> expecting Is or TypeSeparator

|>>/base> IN: UnDeeper
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=29:
|>>/base> unexpected UnDeeper
|>>/base> expecting Is or TypeSeparator

|?| optional something> IN: UnDeeper
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

***************************** \ |?| optional something has returned (Nothing,0)                :1_2:UnDeeper:
***************************** > |>>/base got Nothing                                           :1_2:UnDeeper:
|>>/base> IN: UnDeeper
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

**************************** \ |>>/base has returned (Nothing,0)                                :1_2:UnDeeper:
slKeyValues> IN: Other "sharpen knives" UnDeeper
slKeyValues> MATCH (COK): Other "sharpen knives"
slKeyValues> VALUE: ((("sharpen knives" :| [],Nothing),0),[])

*************************** \ slKeyValues has returned (("sharpen knives" :| [],Nothing),0)      :1_2:UnDeeper:
slAKA base> IN: Other "sharpen knives" UnDeeper
slAKA base> MATCH (COK): Other "sharpen knives"
slAKA base> VALUE: ((("sharpen knives" :| [],Nothing),0),[])

************************** \ slAKA base has returned (("sharpen knives" :| [],Nothing),0)         :1_2:UnDeeper:
$*|> IN: Other "sharpen knives" UnDeeper
$*|> MATCH (COK): Other "sharpen knives"
$*|> VALUE: ((("sharpen knives" :| [],Nothing),0),[])

************************* \ $*| has returned (("sharpen knives" :| [],Nothing),0)                  :1_2:UnDeeper:
************************* / |>>/recurse                                                            :1_2:UnDeeper:
|>>/recurse> IN: UnDeeper
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=29:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************* / |>>/base                                                               :1_2:UnDeeper:
************************** / slAKA optional akapart                                               :1_2:UnDeeper:
*************************** / |?| optional something                                             :1_2:UnDeeper:
**************************** / |>>/recurse                                                      :1_2:UnDeeper:
|>>/recurse> IN: UnDeeper
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=29:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

**************************** / |>>/base                                                         :1_2:UnDeeper:
***************************** / PAKA/akapart                                                   :1_2:UnDeeper:
****************************** / $>|                                                          :1_2:UnDeeper:
******************************* / Aka Token                                                  :1_2:UnDeeper:
Aka Token> IN: UnDeeper
Aka Token> MATCH (EERR): <EMPTY>
Aka Token> ERROR:
Aka Token> offset=29:
Aka Token> unexpected UnDeeper
Aka Token> expecting Aka

$>|> IN: UnDeeper
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=29:
$>|> unexpected UnDeeper
$>|> expecting Aka

PAKA/akapart> IN: UnDeeper
PAKA/akapart> MATCH (EERR): <EMPTY>
PAKA/akapart> ERROR:
PAKA/akapart> offset=29:
PAKA/akapart> unexpected UnDeeper
PAKA/akapart> expecting Aka

|>>/base> IN: UnDeeper
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=29:
|>>/base> unexpected UnDeeper
|>>/base> expecting Aka

|?| optional something> IN: UnDeeper
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

*************************** \ |?| optional something has returned (Nothing,0)                    :1_2:UnDeeper:
slAKA optional akapart> IN: UnDeeper
slAKA optional akapart> MATCH (EOK): <EMPTY>
slAKA optional akapart> VALUE: ((Nothing,0),[])

************************** \ slAKA optional akapart has returned (Nothing,0)                      :1_2:UnDeeper:
************************** > |>>/base got Nothing                                                 :1_2:UnDeeper:
|>>/base> IN: UnDeeper
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************************* \ |>>/base has returned (Nothing,0)                                      :1_2:UnDeeper:
************************* / |>>/recurse                                                            :1_2:UnDeeper:
|>>/recurse> IN: UnDeeper
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=29:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************* / |>>/base                                                               :1_2:UnDeeper:
************************** / slAKA optional typically                                             :1_2:UnDeeper:
*************************** / |?| optional something                                             :1_2:UnDeeper:
**************************** / |>>/recurse                                                      :1_2:UnDeeper:
|>>/recurse> IN: UnDeeper
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=29:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

**************************** / |>>/base                                                         :1_2:UnDeeper:
***************************** / typically                                                      :1_2:UnDeeper:
****************************** / $>|                                                          :1_2:UnDeeper:
$>|> IN: UnDeeper
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=29:
$>|> unexpected UnDeeper
$>|> expecting Typically

typically> IN: UnDeeper
typically> MATCH (EERR): <EMPTY>
typically> ERROR:
typically> offset=29:
typically> unexpected UnDeeper
typically> expecting Typically

|>>/base> IN: UnDeeper
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=29:
|>>/base> unexpected UnDeeper
|>>/base> expecting Typically

|?| optional something> IN: UnDeeper
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

*************************** \ |?| optional something has returned (Nothing,0)                    :1_2:UnDeeper:
slAKA optional typically> IN: UnDeeper
slAKA optional typically> MATCH (EOK): <EMPTY>
slAKA optional typically> VALUE: ((Nothing,0),[])

************************** \ slAKA optional typically has returned (Nothing,0)                    :1_2:UnDeeper:
************************** > |>>/base got Nothing                                                 :1_2:UnDeeper:
|>>/base> IN: UnDeeper
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************************* \ |>>/base has returned (Nothing,0)                                      :1_2:UnDeeper:
************************* > slAKA: proceeding after base and entityalias are retrieved ...         :1_2:UnDeeper:
************************* > pAKA: entityalias = Nothing                                            :1_2:UnDeeper:
slAKA> IN: Other "sharpen knives" UnDeeper
slAKA> MATCH (COK): Other "sharpen knives"
slAKA> VALUE: ((("sharpen knives" :| [],Nothing),0),[])

************************ \ slAKA has returned (("sharpen knives" :| [],Nothing),0)                  :1_2:UnDeeper:
************************ / undeepers                                                                :1_2:UnDeeper:
************************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers :1_2:UnDeeper:
************************* > sameLine: success!                                                     :1_2:UnDeeper:
undeepers> IN: UnDeeper
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

************************ \ undeepers has returned ()                                                :1_2:UnDeeper:
pKeyValuesAka> IN: Other "sharpen knives" UnDeeper
pKeyValuesAka> MATCH (COK): Other "sharpen knives"
pKeyValuesAka> VALUE: (("sharpen knives" :| [],Nothing),[])

*********************** \ pKeyValuesAka has returned ("sharpen knives" :| [],Nothing)                :1_2:UnDeeper:
pParamText(flat) first line: pKeyValues> IN: Other "sharpen knives" UnDeeper
pParamText(flat) first line: pKeyValues> MATCH (COK): Other "sharpen knives"
pParamText(flat) first line: pKeyValues> VALUE: (("sharpen knives" :| [],Nothing),[])

********************** \ pParamText(flat) first line: pKeyValues has returned ("sharpen knives" :| [],Nothing) :1_2:UnDeeper:
********************** / pParamText(flat) subsequent lines: sameMany pKeyValues                       :1_2:UnDeeper:
*********************** / manyIndentation/leaf?                                                      :1_2:UnDeeper:
************************ / sameMany                                                                 :1_2:UnDeeper:
************************* / pKeyValuesAka                                                          :1_2:UnDeeper:
************************** / slAKA                                                                :1_2:UnDeeper:
*************************** / $*|                                                                :1_2:UnDeeper:
**************************** / slAKA base                                                       :1_2:UnDeeper:
***************************** / slKeyValues                                                    :1_2:UnDeeper:
****************************** / $*|                                                          :1_2:UnDeeper:
******************************* / someSL                                                     :1_2:UnDeeper:
******************************** / pNumAsText                                               :1_2:UnDeeper:
pNumAsText> IN: UnDeeper
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=29:
pNumAsText> unexpected UnDeeper
pNumAsText> expecting number

someSL> IN: UnDeeper
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=29:
someSL> unexpected UnDeeper
someSL> expecting other text or number

$*|> IN: UnDeeper
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=29:
$*|> unexpected UnDeeper
$*|> expecting other text or number

slKeyValues> IN: UnDeeper
slKeyValues> MATCH (EERR): <EMPTY>
slKeyValues> ERROR:
slKeyValues> offset=29:
slKeyValues> unexpected UnDeeper
slKeyValues> expecting other text or number

slAKA base> IN: UnDeeper
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=29:
slAKA base> unexpected UnDeeper
slAKA base> expecting other text or number

$*|> IN: UnDeeper
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=29:
$*|> unexpected UnDeeper
$*|> expecting other text or number

slAKA> IN: UnDeeper
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=29:
slAKA> unexpected UnDeeper
slAKA> expecting other text or number

pKeyValuesAka> IN: UnDeeper
pKeyValuesAka> MATCH (EERR): <EMPTY>
pKeyValuesAka> ERROR:
pKeyValuesAka> offset=29:
pKeyValuesAka> unexpected UnDeeper
pKeyValuesAka> expecting other text or number

sameMany> IN: UnDeeper
sameMany> MATCH (EOK): <EMPTY>
sameMany> VALUE: ([],[])

************************ \ sameMany has returned []                                                 :1_2:UnDeeper:
manyIndentation/leaf?> IN: UnDeeper
manyIndentation/leaf?> MATCH (EOK): <EMPTY>
manyIndentation/leaf?> VALUE: ([],[])

*********************** \ manyIndentation/leaf? has returned []                                      :1_2:UnDeeper:
pParamText(flat) subsequent lines: sameMany pKeyValues> IN: UnDeeper
pParamText(flat) subsequent lines: sameMany pKeyValues> MATCH (EOK): <EMPTY>
pParamText(flat) subsequent lines: sameMany pKeyValues> VALUE: ([],[])

********************** \ pParamText(flat) subsequent lines: sameMany pKeyValues has returned []       :1_2:UnDeeper:
pParamText> IN: Other "sharpen knives" UnDeeper
pParamText> MATCH (COK): Other "sharpen knives"
pParamText> VALUE: (("sharpen knives" :| [],Nothing) :| [],[])

********************* \ pParamText has returned ("sharpen knives" :| [],Nothing) :| []                 :1_2:UnDeeper:
term p/3:plain p> IN: Other "sharpen knives" UnDeeper
term p/3:plain p> MATCH (COK): Other "sharpen knives"
term p/3:plain p> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

******************** \ term p/3:plain p has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])    :1_2:UnDeeper:
term p/notLabelTerm> IN: Other "sharpen knives" UnDeeper
term p/notLabelTerm> MATCH (COK): Other "sharpen knives"
term p/notLabelTerm> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

******************* \ term p/notLabelTerm has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])   :1_2:UnDeeper:
term p> IN: Other "sharpen knives" UnDeeper
term p> MATCH (COK): Other "sharpen knives"
term p> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

****************** \ term p has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])                  :1_2:UnDeeper:
****************** / binary(Or)                                                                           :1_2:UnDeeper:
binary(Or)> IN: UnDeeper
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=29:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

****************** / binary(And)                                                                          :1_2:UnDeeper:
binary(And)> IN: UnDeeper
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=29:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

****************** / binary(SetLess)                                                                      :1_2:UnDeeper:
binary(SetLess)> IN: UnDeeper
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=29:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

****************** / binary(SetPlus)                                                                      :1_2:UnDeeper:
binary(SetPlus)> IN: UnDeeper
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=29:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "sharpen knives" UnDeeper
expression> MATCH (COK): Other "sharpen knives"
expression> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

***************** \ expression has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])                :1_2:UnDeeper:
manyIndentation/leaf?> IN: Other "sharpen knives" UnDeeper
manyIndentation/leaf?> MATCH (COK): Other "sharpen knives"
manyIndentation/leaf?> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

**************** \ manyIndentation/leaf? has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])       :1_2:UnDeeper:
**************** / myindented: consuming UnDeeper                                                           :1_2:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

**************** \ myindented: consuming UnDeeper has returned UnDeeper                                :EOF:
someIndentation> IN: GoDeeper Other "sharpen knives" UnDeeper
someIndentation> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
someIndentation> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

*************** \ someIndentation has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])          :EOF:
term p/2:someIndentation expr p> IN: GoDeeper Other "sharpen knives" UnDeeper
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
term p/2:someIndentation expr p> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

************** \ term p/2:someIndentation expr p has returned MyLeaf (("sharpen knives" :| [],Nothing) :| []) :EOF:
term p/notLabelTerm> IN: GoDeeper Other "sharpen knives" UnDeeper
term p/notLabelTerm> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
term p/notLabelTerm> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

************* \ term p/notLabelTerm has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])          :EOF:
term p> IN: GoDeeper Other "sharpen knives" UnDeeper
term p> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
term p> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

************ \ term p has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])                         :EOF:
************ / binary(Or)                                                                                  :EOF:
binary(Or)> IN: <EMPTY>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=30:
binary(Or)> unexpected end of input
binary(Or)> expecting Or

************ / binary(And)                                                                                 :EOF:
binary(And)> IN: <EMPTY>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=30:
binary(And)> unexpected end of input
binary(And)> expecting And

************ / binary(SetLess)                                                                             :EOF:
binary(SetLess)> IN: <EMPTY>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=30:
binary(SetLess)> unexpected end of input
binary(SetLess)> expecting SetLess

************ / binary(SetPlus)                                                                             :EOF:
binary(SetPlus)> IN: <EMPTY>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=30:
binary(SetPlus)> unexpected end of input
binary(SetPlus)> expecting SetPlus

expression> IN: GoDeeper Other "sharpen knives" UnDeeper
expression> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
expression> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

*********** \ expression has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])                       :EOF:
expr pParamText> IN: GoDeeper Other "sharpen knives" UnDeeper
expr pParamText> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
expr pParamText> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

********** \ expr pParamText has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])                    :EOF:
dBoolStructP calling exprP> IN: GoDeeper Other "sharpen knives" UnDeeper
dBoolStructP calling exprP> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
dBoolStructP calling exprP> VALUE: (Leaf (("sharpen knives" :| [],Nothing) :| []),[])

********* \ dBoolStructP calling exprP has returned Leaf (("sharpen knives" :| [],Nothing) :| [])             :EOF:
pAction calling dBoolStructP> IN: GoDeeper Other "sharpen knives" UnDeeper
pAction calling dBoolStructP> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
pAction calling dBoolStructP> VALUE: (Leaf (("sharpen knives" :| [],Nothing) :| []),[])

******** \ pAction calling dBoolStructP has returned Leaf (("sharpen knives" :| [],Nothing) :| [])             :EOF:
pDA> IN: May GoDeeper Other "sharpen knives" UnDe <…>
pDA> MATCH (COK): May GoDeeper Other "sharpen knives" UnDe <…>
pDA> VALUE: ((DMay,Leaf (("sharpen knives" :| [],Nothing) :| [])),[])

******* \ pDA has returned (DMay,Leaf (("sharpen knives" :| [],Nothing) :| []))                                 :EOF:
******* / WHERE                                                                                                 :EOF:
WHERE> IN: <EMPTY>
WHERE> MATCH (EERR): <EMPTY>
WHERE> ERROR:
WHERE> offset=30:
WHERE> unexpected end of input
WHERE> expecting Where

******* / preambleParamText:[Having]                                                                            :EOF:
******** / $>|                                                                                                 :EOF:
$>|> IN: <EMPTY>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=30:
$>|> unexpected end of input
$>|> expecting Having

preambleParamText:[Having]> IN: <EMPTY>
preambleParamText:[Having]> MATCH (EERR): <EMPTY>
preambleParamText:[Having]> ERROR:
preambleParamText:[Having]> offset=30:
preambleParamText:[Having]> unexpected end of input
preambleParamText:[Having]> expecting Having or any token

******* / preambleParamText:[Given]                                                                             :EOF:
******** / $>|                                                                                                 :EOF:
$>|> IN: <EMPTY>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=30:
$>|> unexpected end of input
$>|> expecting Given

preambleParamText:[Given]> IN: <EMPTY>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=30:
preambleParamText:[Given]> unexpected end of input
preambleParamText:[Given]> expecting Given or any token

******* / preambleParamText:[Upon]                                                                              :EOF:
******** / $>|                                                                                                 :EOF:
$>|> IN: <EMPTY>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=30:
$>|> unexpected end of input
$>|> expecting Upon

preambleParamText:[Upon]> IN: <EMPTY>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=30:
preambleParamText:[Upon]> unexpected end of input
preambleParamText:[Upon]> expecting Upon or any token

******* / preambleBoolStructR [Unless]                                                                          :EOF:
preambleBoolStructR [Unless]> IN: <EMPTY>
preambleBoolStructR [Unless]> MATCH (EERR): <EMPTY>
preambleBoolStructR [Unless]> ERROR:
preambleBoolStructR [Unless]> offset=30:
preambleBoolStructR [Unless]> unexpected end of input
preambleBoolStructR [Unless]> expecting Unless

******* / preambleBoolStructR [When,If]                                                                         :EOF:
preambleBoolStructR [When,If]> IN: <EMPTY>
preambleBoolStructR [When,If]> MATCH (EERR): <EMPTY>
preambleBoolStructR [When,If]> ERROR:
preambleBoolStructR [When,If]> offset=30:
preambleBoolStructR [When,If]> unexpected end of input
preambleBoolStructR [When,If]> expecting If or When

******* / pTemporal/eventually                                                                                  :EOF:
pTemporal/eventually> IN: <EMPTY>
pTemporal/eventually> MATCH (EERR): <EMPTY>
pTemporal/eventually> ERROR:
pTemporal/eventually> offset=30:
pTemporal/eventually> unexpected end of input
pTemporal/eventually> expecting Eventually

******* / pTemporal/specifically                                                                                :EOF:
******** / $>|                                                                                                 :EOF:
$>|> IN: <EMPTY>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=30:
$>|> unexpected end of input
$>|> expecting After, Before, By, or On

pTemporal/specifically> IN: <EMPTY>
pTemporal/specifically> MATCH (EERR): <EMPTY>
pTemporal/specifically> ERROR:
pTemporal/specifically> offset=30:
pTemporal/specifically> unexpected end of input
pTemporal/specifically> expecting After, Before, By, On, or any token

******* / pTemporal/vaguely                                                                                     :EOF:
pTemporal/vaguely> IN: <EMPTY>
pTemporal/vaguely> MATCH (EERR): <EMPTY>
pTemporal/vaguely> ERROR:
pTemporal/vaguely> offset=30:
pTemporal/vaguely> unexpected end of input
pTemporal/vaguely> expecting Other text

regulative permutation with deontic-action> IN: Every GoDeeper Other "person" UnDeeper W <…>
regulative permutation with deontic-action> MATCH (COK): Every GoDeeper Other "person" UnDeeper W <…>
regulative permutation with deontic-action> VALUE: (RuleBody {rbaction = Leaf (("sharpen knives" :| [],Nothing) :| []), rbpbrs = [], rbpbrneg = [], rbdeon = DMay, rbtemporal = Nothing, rbupon = [], rbgiven = [], rbhaving = Nothing, rbkeyname = (Every,Leaf (("person" :| [],Nothing) :| [])), rbwho = Just (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), rbwhere = []},[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

****** \ regulative permutation with deontic-action has returned RuleBody {rbaction = Leaf (("sharpen knives" :| [],Nothing) :| []), rbpbrs = [], rbpbrneg = [], rbdeon = DMay, rbtemporal = Nothing, rbupon = [], rbgiven = [], rbhaving = Nothing, rbkeyname = (Every,Leaf (("person" :| [],Nothing) :| [])), rbwho = Just (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), rbwhere = []} :EOF:
permutationsReg> IN: Every GoDeeper Other "person" UnDeeper W <…>
permutationsReg> MATCH (COK): Every GoDeeper Other "person" UnDeeper W <…>
permutationsReg> VALUE: (RuleBody {rbaction = Leaf (("sharpen knives" :| [],Nothing) :| []), rbpbrs = [], rbpbrneg = [], rbdeon = DMay, rbtemporal = Nothing, rbupon = [], rbgiven = [], rbhaving = Nothing, rbkeyname = (Every,Leaf (("person" :| [],Nothing) :| [])), rbwho = Just (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), rbwhere = []},[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

***** \ permutationsReg has returned RuleBody {rbaction = Leaf (("sharpen knives" :| [],Nothing) :| []), rbpbrs = [], rbpbrneg = [], rbdeon = DMay, rbtemporal = Nothing, rbupon = [], rbgiven = [], rbhaving = Nothing, rbkeyname = (Every,Leaf (("person" :| [],Nothing) :| [])), rbwho = Just (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), rbwhere = []} :EOF:
***** / pHenceLest-Hence                                                                                          :EOF:
pHenceLest-Hence> IN: <EMPTY>
pHenceLest-Hence> MATCH (EERR): <EMPTY>
pHenceLest-Hence> ERROR:
pHenceLest-Hence> offset=30:
pHenceLest-Hence> unexpected end of input
pHenceLest-Hence> expecting Hence

***** / pHenceLest-Lest                                                                                           :EOF:
pHenceLest-Lest> IN: <EMPTY>
pHenceLest-Lest> MATCH (EERR): <EMPTY>
pHenceLest-Lest> ERROR:
pHenceLest-Lest> offset=30:
pHenceLest-Lest> unexpected end of input
pHenceLest-Lest> expecting Lest

****   pRegRuleNormal: permutations returned rulebody RuleBody {rbaction = Leaf (("sharpen knives" :| [],Nothing) :| []), rbpbrs = [], rbpbrneg = [], rbdeon = DMay, rbtemporal = Nothing, rbupon = [], rbgiven = [], rbhaving = Nothing, rbkeyname = (Every,Leaf (("person" :| [],Nothing) :| [])), rbwho = Just (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), rbwhere = []} :EOF:
****   pRegRuleNormal: the positive preamble is Nothing                                                           :EOF:
****   pRegRuleNormal: the negative preamble is Nothing                                                           :EOF:
****   pRegRuleNormal: returning Regulative {subj = Leaf (("person" :| [],Nothing) :| []), keyword = Every, who = Just (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), cond = Nothing, deontic = DMay, action = Leaf (("sharpen knives" :| [],Nothing) :| []), temporal = Nothing, hence = Nothing, lest = Nothing, rlabel = Nothing, lsource = Nothing, srcref = Nothing, upon = Nothing, given = Nothing, having = Nothing, wwhere = [], defaults = [], symtab = []} :EOF:
pRegRuleNormal> IN: Every GoDeeper Other "person" UnDeeper W <…>
pRegRuleNormal> MATCH (COK): Every GoDeeper Other "person" UnDeeper W <…>
pRegRuleNormal> VALUE: (Regulative {subj = Leaf (("person" :| [],Nothing) :| []), keyword = Every, who = Just (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), cond = Nothing, deontic = DMay, action = Leaf (("sharpen knives" :| [],Nothing) :| []), temporal = Nothing, hence = Nothing, lest = Nothing, rlabel = Nothing, lsource = Nothing, srcref = Nothing, upon = Nothing, given = Nothing, having = Nothing, wwhere = [], defaults = [], symtab = []},[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

**** \ pRegRuleNormal has returned Regulative {subj = Leaf (("person" :| [],Nothing) :| []), keyword = Every, who = Just (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), cond = Nothing, deontic = DMay, action = Leaf (("sharpen knives" :| [],Nothing) :| []), temporal = Nothing, hence = Nothing, lest = Nothing, rlabel = Nothing, lsource = Nothing, srcref = Nothing, upon = Nothing, given = Nothing, having = Nothing, wwhere = [], defaults = [], symtab = []} :EOF:
pRegRule> IN: Every GoDeeper Other "person" UnDeeper W <…>
pRegRule> MATCH (COK): Every GoDeeper Other "person" UnDeeper W <…>
pRegRule> VALUE: (Regulative {subj = Leaf (("person" :| [],Nothing) :| []), keyword = Every, who = Just (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), cond = Nothing, deontic = DMay, action = Leaf (("sharpen knives" :| [],Nothing) :| []), temporal = Nothing, hence = Nothing, lest = Nothing, rlabel = Nothing, lsource = Nothing, srcref = Nothing, upon = Nothing, given = Nothing, having = Nothing, wwhere = [], defaults = [], symtab = []},[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*** \ pRegRule has returned Regulative {subj = Leaf (("person" :| [],Nothing) :| []), keyword = Every, who = Just (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), cond = Nothing, deontic = DMay, action = Leaf (("sharpen knives" :| [],Nothing) :| []), temporal = Nothing, hence = Nothing, lest = Nothing, rlabel = Nothing, lsource = Nothing, srcref = Nothing, upon = Nothing, given = Nothing, having = Nothing, wwhere = [], defaults = [], symtab = []} :EOF:
pRule> IN: Every GoDeeper Other "person" UnDeeper W <…>
pRule> MATCH (COK): Every GoDeeper Other "person" UnDeeper W <…>
pRule> VALUE: (Regulative {subj = Leaf (("person" :| [],Nothing) :| []), keyword = Every, who = Just (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), cond = Nothing, deontic = DMay, action = Leaf (("sharpen knives" :| [],Nothing) :| []), temporal = Nothing, hence = Nothing, lest = Nothing, rlabel = Nothing, lsource = Nothing, srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 1, srccol = 1, version = Nothing}), upon = Nothing, given = Nothing, having = Nothing, wwhere = [], defaults = [], symtab = []},[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

** \ pRule has returned Regulative {subj = Leaf (("person" :| [],Nothing) :| []), keyword = Every, who = Just (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), cond = Nothing, deontic = DMay, action = Leaf (("sharpen knives" :| [],Nothing) :| []), temporal = Nothing, hence = Nothing, lest = Nothing, rlabel = Nothing, lsource = Nothing, srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 1, srccol = 1, version = Nothing}), upon = Nothing, given = Nothing, having = Nothing, wwhere = [], defaults = [], symtab = []} :EOF:
[Every,GoDeeper,Other "person",UnDeeper,Who,GoDeeper,GoDeeper,Other "is",GoDeeper,Other "immortal",GoDeeper,Typically,GoDeeper,Other "false",UnDeeper,UnDeeper,UnDeeper,UnDeeper,Or,GoDeeper,Other "has",GoDeeper,Other "health insurance",UnDeeper,UnDeeper,UnDeeper,May,GoDeeper,Other "sharpen knives",UnDeeper]
** / pRule                                                                                                             :1_1:Every:
*** / pRegRule                                                                                                        :1_1:Every:
**** / pRuleLabel                                                                                                    :1_1:Every:
***** / $>|                                                                                                         :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting RuleMarker 1 "\167"

pRuleLabel> IN: Every GoDeeper Other "person" UnDeeper W <…>
pRuleLabel> MATCH (EERR): <EMPTY>
pRuleLabel> ERROR:
pRuleLabel> offset=0:
pRuleLabel> unexpected Every
pRuleLabel> expecting RuleMarker 1 "\167"

**** / pRegRuleSugary                                                                                                :1_1:Every:
***** / someDeep                                                                                                    :1_1:Every:
****** / someDeep first part calls base directly                                                                   :1_1:Every:
someDeep first part calls base directly> IN: Every GoDeeper Other "person" UnDeeper W <…>
someDeep first part calls base directly> MATCH (EERR): <EMPTY>
someDeep first part calls base directly> ERROR:
someDeep first part calls base directly> offset=0:
someDeep first part calls base directly> unexpected Every
someDeep first part calls base directly> expecting Other text

someDeep> IN: Every GoDeeper Other "person" UnDeeper W <…>
someDeep> MATCH (EERR): <EMPTY>
someDeep> ERROR:
someDeep> offset=0:
someDeep> unexpected Every
someDeep> expecting Other text

pRegRuleSugary> IN: Every GoDeeper Other "person" UnDeeper W <…>
pRegRuleSugary> MATCH (EERR): <EMPTY>
pRegRuleSugary> ERROR:
pRegRuleSugary> offset=0:
pRegRuleSugary> unexpected Every
pRegRuleSugary> expecting Other text

**** / pRegRuleNormal                                                                                                :1_1:Every:
***** / permutationsReg                                                                                             :1_1:Every:
****** / regulative permutation with deontic-temporal                                                              :1_1:Every:
******* / WHERE                                                                                                   :1_1:Every:
WHERE> IN: Every GoDeeper Other "person" UnDeeper W <…>
WHERE> MATCH (EERR): <EMPTY>
WHERE> ERROR:
WHERE> offset=0:
WHERE> unexpected Every
WHERE> expecting Where

******* / preambleParamText:[Having]                                                                              :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting Having

preambleParamText:[Having]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleParamText:[Having]> MATCH (EERR): <EMPTY>
preambleParamText:[Having]> ERROR:
preambleParamText:[Having]> offset=0:
preambleParamText:[Having]> unexpected Every
preambleParamText:[Having]> expecting Having

******* / preambleParamText:[Given]                                                                               :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting Given

preambleParamText:[Given]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=0:
preambleParamText:[Given]> unexpected Every
preambleParamText:[Given]> expecting Given

******* / preambleParamText:[Upon]                                                                                :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting Upon

preambleParamText:[Upon]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=0:
preambleParamText:[Upon]> unexpected Every
preambleParamText:[Upon]> expecting Upon

******* / preambleBoolStructR [Unless]                                                                            :1_1:Every:
preambleBoolStructR [Unless]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleBoolStructR [Unless]> MATCH (EERR): <EMPTY>
preambleBoolStructR [Unless]> ERROR:
preambleBoolStructR [Unless]> offset=0:
preambleBoolStructR [Unless]> unexpected Every
preambleBoolStructR [Unless]> expecting Unless

******* / preambleBoolStructR [When,If]                                                                           :1_1:Every:
preambleBoolStructR [When,If]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleBoolStructR [When,If]> MATCH (EERR): <EMPTY>
preambleBoolStructR [When,If]> ERROR:
preambleBoolStructR [When,If]> offset=0:
preambleBoolStructR [When,If]> unexpected Every
preambleBoolStructR [When,If]> expecting If or When

******* / pDT                                                                                                     :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting May, Must, or Shant

pDT> IN: Every GoDeeper Other "person" UnDeeper W <…>
pDT> MATCH (EERR): <EMPTY>
pDT> ERROR:
pDT> offset=0:
pDT> unexpected Every
pDT> expecting May, Must, or Shant

******* / pActor [Every,Party,TokAll]                                                                             :1_1:Every:
******** / someIndentation                                                                                        :1_2:GoDeeper:
********* / myindented: consuming GoDeeper                                                                       :1_2:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "person" UnDeeper Who GoD <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

********* \ myindented: consuming GoDeeper has returned GoDeeper                                                  :1_2:Other "pers:
********* / manyIndentation/leaf?                                                                                 :1_2:Other "pers:
********** / pMultiTermAka                                                                                       :1_2:Other "pers:
*********** / pAKA                                                                                              :1_2:Other "pers:
************ / slAKA                                                                                           :1_2:Other "pers:
************* / $*|                                                                                           :1_2:Other "pers:
************** / slAKA base                                                                                  :1_2:Other "pers:
*************** / slMultiTerm                                                                               :1_2:Other "pers:
**************** / someSL                                                                                  :1_2:Other "pers:
someSL> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
someSL> MATCH (COK): Other "person"
someSL> VALUE: ((["person"],0),[])

**************** \ someSL has returned (["person"],0)                                                       :2_2:UnDeeper:
slMultiTerm> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
slMultiTerm> MATCH (COK): Other "person"
slMultiTerm> VALUE: ((["person"],0),[])

*************** \ slMultiTerm has returned (["person"],0)                                                    :2_2:UnDeeper:
slAKA base> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
slAKA base> MATCH (COK): Other "person"
slAKA base> VALUE: ((["person"],0),[])

************** \ slAKA base has returned (["person"],0)                                                       :2_2:UnDeeper:
$*|> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
$*|> MATCH (COK): Other "person"
$*|> VALUE: ((["person"],0),[])

************* \ $*| has returned (["person"],0)                                                                :2_2:UnDeeper:
************* / |>>/recurse                                                                                    :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************* / |>>/base                                                                                       :2_2:UnDeeper:
************** / slAKA optional akapart                                                                       :2_2:UnDeeper:
*************** / |?| optional something                                                                     :2_2:UnDeeper:
**************** / |>>/recurse                                                                              :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

**************** / |>>/base                                                                                 :2_2:UnDeeper:
***************** / PAKA/akapart                                                                           :2_2:UnDeeper:
****************** / $>|                                                                                  :2_2:UnDeeper:
******************* / Aka Token                                                                          :2_2:UnDeeper:
Aka Token> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
Aka Token> MATCH (EERR): <EMPTY>
Aka Token> ERROR:
Aka Token> offset=3:
Aka Token> unexpected UnDeeper
Aka Token> expecting Aka

$>|> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=3:
$>|> unexpected UnDeeper
$>|> expecting Aka

PAKA/akapart> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
PAKA/akapart> MATCH (EERR): <EMPTY>
PAKA/akapart> ERROR:
PAKA/akapart> offset=3:
PAKA/akapart> unexpected UnDeeper
PAKA/akapart> expecting Aka

|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=3:
|>>/base> unexpected UnDeeper
|>>/base> expecting Aka

|?| optional something> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

*************** \ |?| optional something has returned (Nothing,0)                                            :2_2:UnDeeper:
slAKA optional akapart> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
slAKA optional akapart> MATCH (EOK): <EMPTY>
slAKA optional akapart> VALUE: ((Nothing,0),[])

************** \ slAKA optional akapart has returned (Nothing,0)                                              :2_2:UnDeeper:
************** > |>>/base got Nothing                                                                         :2_2:UnDeeper:
|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************* \ |>>/base has returned (Nothing,0)                                                              :2_2:UnDeeper:
************* / |>>/recurse                                                                                    :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************* / |>>/base                                                                                       :2_2:UnDeeper:
************** / slAKA optional typically                                                                     :2_2:UnDeeper:
*************** / |?| optional something                                                                     :2_2:UnDeeper:
**************** / |>>/recurse                                                                              :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

**************** / |>>/base                                                                                 :2_2:UnDeeper:
***************** / typically                                                                              :2_2:UnDeeper:
****************** / $>|                                                                                  :2_2:UnDeeper:
$>|> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=3:
$>|> unexpected UnDeeper
$>|> expecting Typically

typically> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
typically> MATCH (EERR): <EMPTY>
typically> ERROR:
typically> offset=3:
typically> unexpected UnDeeper
typically> expecting Typically

|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=3:
|>>/base> unexpected UnDeeper
|>>/base> expecting Typically

|?| optional something> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

*************** \ |?| optional something has returned (Nothing,0)                                            :2_2:UnDeeper:
slAKA optional typically> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
slAKA optional typically> MATCH (EOK): <EMPTY>
slAKA optional typically> VALUE: ((Nothing,0),[])

************** \ slAKA optional typically has returned (Nothing,0)                                            :2_2:UnDeeper:
************** > |>>/base got Nothing                                                                         :2_2:UnDeeper:
|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************* \ |>>/base has returned (Nothing,0)                                                              :2_2:UnDeeper:
************* > slAKA: proceeding after base and entityalias are retrieved ...                                 :2_2:UnDeeper:
************* > pAKA: entityalias = Nothing                                                                    :2_2:UnDeeper:
slAKA> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
slAKA> MATCH (COK): Other "person"
slAKA> VALUE: ((["person"],0),[])

************ \ slAKA has returned (["person"],0)                                                                :2_2:UnDeeper:
************ / undeepers                                                                                        :2_2:UnDeeper:
************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers                         :2_2:UnDeeper:
************* > sameLine: success!                                                                             :2_2:UnDeeper:
undeepers> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

************ \ undeepers has returned ()                                                                        :2_2:UnDeeper:
pAKA> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
pAKA> MATCH (COK): Other "person"
pAKA> VALUE: (["person"],[])

*********** \ pAKA has returned ["person"]                                                                       :2_2:UnDeeper:
pMultiTermAka> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
pMultiTermAka> MATCH (COK): Other "person"
pMultiTermAka> VALUE: (["person"],[])

********** \ pMultiTermAka has returned ["person"]                                                                :2_2:UnDeeper:
manyIndentation/leaf?> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
manyIndentation/leaf?> MATCH (COK): Other "person"
manyIndentation/leaf?> VALUE: (["person"],[])

********* \ manyIndentation/leaf? has returned ["person"]                                                          :2_2:UnDeeper:
********* / myindented: consuming UnDeeper                                                                         :2_2:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

********* \ myindented: consuming UnDeeper has returned UnDeeper                                                :2_1:Who:
someIndentation> IN: GoDeeper Other "person" UnDeeper Who GoD <…>
someIndentation> MATCH (COK): GoDeeper Other "person" UnDeeper
someIndentation> VALUE: (["person"],[])

******** \ someIndentation has returned ["person"]                                                               :2_1:Who:
pActor [Every,Party,TokAll]> IN: Every GoDeeper Other "person" UnDeeper W <…>
pActor [Every,Party,TokAll]> MATCH (COK): Every GoDeeper Other "person" UnDeeper
pActor [Every,Party,TokAll]> VALUE: ((Every,Leaf (("person" :| [],Nothing) :| [])),[])

******* \ pActor [Every,Party,TokAll] has returned (Every,Leaf (("person" :| [],Nothing) :| []))                  :2_1:Who:
******* / manyIndentation/leaf?                                                                                   :2_1:Who:
******** / preambleBoolStructR [Who,Which,Whose]                                                                 :2_1:Who:
********* / pBSR                                                                                                 :2_2:GoDeeper:
********** / ppp inner                                                                                          :2_2:GoDeeper:
*********** / expression                                                                                       :2_2:GoDeeper:
************ / labelPrefix                                                                                    :2_2:GoDeeper:
labelPrefix> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=5:
labelPrefix> unexpected GoDeeper
labelPrefix> expecting Other text

************ / term p                                                                                         :2_2:GoDeeper:
************* / term p/1a:label directly above                                                               :2_2:GoDeeper:
************** / $*|                                                                                        :2_2:GoDeeper:
*************** / someSL                                                                                   :2_2:GoDeeper:
**************** / pNumAsText                                                                             :2_2:GoDeeper:
pNumAsText> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=5:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=5:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=5:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=5:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

************* / term p/b:label to the left of line below, with EOL                                           :2_2:GoDeeper:
************** / someSL                                                                                     :2_2:GoDeeper:
*************** / pNumAsText                                                                               :2_2:GoDeeper:
pNumAsText> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=5:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=5:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=5:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

************* / term p/notLabelTerm                                                                          :2_2:GoDeeper:
************** / term p/2:someIndentation expr p                                                            :2_2:GoDeeper:
*************** / someIndentation                                                                          :2_2:GoDeeper:
**************** / myindented: consuming GoDeeper                                                         :2_2:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

**************** \ myindented: consuming GoDeeper has returned GoDeeper                                     :2_3:GoDeeper:
**************** / manyIndentation/leaf?                                                                    :2_3:GoDeeper:
***************** / expression                                                                             :2_3:GoDeeper:
****************** / labelPrefix                                                                          :2_3:GoDeeper:
labelPrefix> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=6:
labelPrefix> unexpected GoDeeper
labelPrefix> expecting Other text

****************** / term p                                                                               :2_3:GoDeeper:
******************* / term p/1a:label directly above                                                     :2_3:GoDeeper:
******************** / $*|                                                                              :2_3:GoDeeper:
********************* / someSL                                                                         :2_3:GoDeeper:
********************** / pNumAsText                                                                   :2_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=6:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=6:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=6:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=6:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

******************* / term p/b:label to the left of line below, with EOL                                 :2_3:GoDeeper:
******************** / someSL                                                                           :2_3:GoDeeper:
********************* / pNumAsText                                                                     :2_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=6:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=6:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=6:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

******************* / term p/notLabelTerm                                                                :2_3:GoDeeper:
******************** / term p/2:someIndentation expr p                                                  :2_3:GoDeeper:
********************* / someIndentation                                                                :2_3:GoDeeper:
********************** / myindented: consuming GoDeeper                                               :2_3:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

********************** \ myindented: consuming GoDeeper has returned GoDeeper                          :2_3:Other "is":
********************** / manyIndentation/leaf?                                                         :2_3:Other "is":
*********************** / expression                                                                  :2_3:Other "is":
************************ / labelPrefix                                                               :2_3:Other "is":
labelPrefix> IN: Other "is" GoDeeper Other "immortal" GoD <…>
labelPrefix> MATCH (COK): Other "is"
labelPrefix> VALUE: ("is",[])

************************ \ labelPrefix has returned "is"                                              :2_4:GoDeeper:
************************ / term p                                                                     :2_4:GoDeeper:
************************* / term p/1a:label directly above                                           :2_4:GoDeeper:
************************** / $*|                                                                    :2_4:GoDeeper:
*************************** / someSL                                                               :2_4:GoDeeper:
**************************** / pNumAsText                                                         :2_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=8:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=8:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=8:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=8:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

************************* / term p/b:label to the left of line below, with EOL                       :2_4:GoDeeper:
************************** / someSL                                                                 :2_4:GoDeeper:
*************************** / pNumAsText                                                           :2_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=8:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=8:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=8:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

************************* / term p/notLabelTerm                                                      :2_4:GoDeeper:
************************** / term p/2:someIndentation expr p                                        :2_4:GoDeeper:
*************************** / someIndentation                                                      :2_4:GoDeeper:
**************************** / myindented: consuming GoDeeper                                     :2_4:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

**************************** \ myindented: consuming GoDeeper has returned GoDeeper                :2_4:Other "immo:
**************************** / manyIndentation/leaf?                                               :2_4:Other "immo:
***************************** / expression                                                        :2_4:Other "immo:
****************************** / labelPrefix                                                     :2_4:Other "immo:
labelPrefix> IN: Other "immortal" GoDeeper Typically GoDe <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=10:
labelPrefix> unexpected GoDeeper

****************************** / term p                                                          :2_4:Other "immo:
******************************* / term p/1a:label directly above                                :2_4:Other "immo:
******************************** / $*|                                                         :2_4:Other "immo:
********************************* / someSL                                                    :2_4:Other "immo:
********************************** / pNumAsText                                                :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

********************************* \ someSL has returned (["immortal"],0)                       :2_5:GoDeeper:
********************************* / pNumAsText                                                 :2_5:GoDeeper:
pNumAsText> IN: GoDeeper Typically GoDeeper Other "false <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (CERR): Other "immortal"
$*|> ERROR:
$*|> offset=10:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/1a:label directly above> MATCH (CERR): Other "immortal"
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=10:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

******************************* / term p/b:label to the left of line below, with EOL            :2_4:Other "immo:
******************************** / someSL                                                      :2_4:Other "immo:
********************************* / pNumAsText                                                  :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

******************************** \ someSL has returned (["immortal"],0)                         :2_5:GoDeeper:
******************************** / undeepers                                                    :2_5:GoDeeper:
********************************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers :2_5:GoDeeper:
********************************* > sameLine: success!                                         :2_5:GoDeeper:
undeepers> IN: GoDeeper Typically GoDeeper Other "false <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

******************************** \ undeepers has returned ()                                    :2_5:GoDeeper:
******************************** / matching EOL                                                 :2_5:GoDeeper:
matching EOL> IN: GoDeeper Typically GoDeeper Other "false <…>
matching EOL> MATCH (EERR): <EMPTY>
matching EOL> ERROR:
matching EOL> offset=10:
matching EOL> unexpected GoDeeper
matching EOL> expecting EOL

term p/b:label to the left of line below, with EOL> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/b:label to the left of line below, with EOL> MATCH (CERR): Other "immortal"
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=10:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting EOL

******************************* / term p/notLabelTerm                                           :2_4:Other "immo:
******************************** / term p/2:someIndentation expr p                             :2_4:Other "immo:
********************************* / someIndentation                                           :2_4:Other "immo:
********************************** / myindented: consuming GoDeeper                          :2_4:Other "immo:
myindented: consuming GoDeeper> IN: Other "immortal" GoDeeper Typically GoDe <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=9:
myindented: consuming GoDeeper> unexpected Other "immortal"
myindented: consuming GoDeeper> expecting GoDeeper

someIndentation> IN: Other "immortal" GoDeeper Typically GoDe <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=9:
someIndentation> unexpected Other "immortal"
someIndentation> expecting GoDeeper

term p/2:someIndentation expr p> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/2:someIndentation expr p> MATCH (EERR): <EMPTY>
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=9:
term p/2:someIndentation expr p> unexpected Other "immortal"
term p/2:someIndentation expr p> expecting GoDeeper

******************************** / term p/3:plain p                                            :2_4:Other "immo:
********************************* / pRelPred                                                  :2_4:Other "immo:
********************************** / slRelPred                                               :2_4:Other "immo:
*********************************** / nested simpleHorn                                     :2_4:Other "immo:
************************************ > |^|                                                 :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slMultiTerm                                       :2_4:Other "immo:
************************************** / someSL                                          :2_4:Other "immo:
*************************************** / pNumAsText                                      :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

************************************** \ someSL has returned (["immortal"],0)             :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

************************************* \ slMultiTerm has returned (["immortal"],0)          :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************ \ $*| has returned (["immortal"],0)                    :2_5:GoDeeper:
************************************ / |^| deeps                                            :2_5:GoDeeper:
|^| deeps> IN: GoDeeper Typically GoDeeper Other "false <…>
|^| deeps> MATCH (COK): GoDeeper
|^| deeps> VALUE: (([()],1),[])

************************************ \ |^| deeps has returned ([()],1)                       :2_5:Typically:
nested simpleHorn> IN: Other "immortal" GoDeeper Typically GoDe <…>
nested simpleHorn> MATCH (CERR): Other "immortal" GoDeeper
nested simpleHorn> ERROR:
nested simpleHorn> offset=11:
nested simpleHorn> unexpected Typically
nested simpleHorn> expecting GoDeeper or Means

*********************************** / RPConstraint                                          :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slMultiTerm                                       :2_4:Other "immo:
************************************** / someSL                                          :2_4:Other "immo:
*************************************** / pNumAsText                                      :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

************************************** \ someSL has returned (["immortal"],0)             :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

************************************* \ slMultiTerm has returned (["immortal"],0)          :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************ \ $*| has returned (["immortal"],0)                    :2_5:GoDeeper:
************************************ / |>| calling $>>                                      :2_5:GoDeeper:
************************************* / |>>/recurse                                        :2_5:GoDeeper:
************************************** / |>>/recurse                                       :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                          :2_5:Typically:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=11:
|>>/base> unexpected Typically
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>>/recurse> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/recurse> MATCH (CERR): GoDeeper
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

************************************* / |>>/base                                           :2_5:GoDeeper:
|>>/base> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=10:
|>>/base> unexpected GoDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: GoDeeper Typically GoDeeper Other "false <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=11:
|>| calling $>>> unexpected Typically
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPConstraint> IN: Other "immortal" GoDeeper Typically GoDe <…>
RPConstraint> MATCH (CERR): Other "immortal"
RPConstraint> ERROR:
RPConstraint> offset=11:
RPConstraint> unexpected Typically
RPConstraint> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPBoolStructR                                         :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slMultiTerm                                       :2_4:Other "immo:
************************************** / someSL                                          :2_4:Other "immo:
*************************************** / pNumAsText                                      :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

************************************** \ someSL has returned (["immortal"],0)             :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

************************************* \ slMultiTerm has returned (["immortal"],0)          :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************ \ $*| has returned (["immortal"],0)                    :2_5:GoDeeper:
************************************ / |>| calling $>>                                      :2_5:GoDeeper:
************************************* / |>>/recurse                                        :2_5:GoDeeper:
************************************** / |>>/recurse                                       :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                          :2_5:Typically:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=11:
|>>/base> unexpected Typically
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>>/recurse> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/recurse> MATCH (CERR): GoDeeper
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

************************************* / |>>/base                                           :2_5:GoDeeper:
|>>/base> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=10:
|>>/base> unexpected GoDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: GoDeeper Typically GoDeeper Other "false <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=11:
|>| calling $>>> unexpected Typically
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPBoolStructR> IN: Other "immortal" GoDeeper Typically GoDe <…>
RPBoolStructR> MATCH (CERR): Other "immortal"
RPBoolStructR> ERROR:
RPBoolStructR> offset=11:
RPBoolStructR> unexpected Typically
RPBoolStructR> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPMT                                                  :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slAKA                                             :2_4:Other "immo:
************************************** / $*|                                             :2_4:Other "immo:
*************************************** / slAKA base                                    :2_4:Other "immo:
**************************************** / slMultiTerm                                 :2_4:Other "immo:
***************************************** / someSL                                    :2_4:Other "immo:
****************************************** / pNumAsText                                :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

***************************************** \ someSL has returned (["immortal"],0)       :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

**************************************** \ slMultiTerm has returned (["immortal"],0)    :2_5:GoDeeper:
slAKA base> IN: Other "immortal" GoDeeper Typically GoDe <…>
slAKA base> MATCH (COK): Other "immortal"
slAKA base> VALUE: ((["immortal"],0),[])

*************************************** \ slAKA base has returned (["immortal"],0)       :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************** \ $*| has returned (["immortal"],0)                :2_5:GoDeeper:
************************************** / |>>/recurse                                      :2_5:GoDeeper:
*************************************** / |>>/recurse                                     :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

*************************************** / |>>/base                                        :2_5:Typically:
**************************************** / slAKA optional akapart                        :2_5:Typically:
***************************************** / |?| optional something                      :2_5:Typically:
****************************************** / |>>/recurse                               :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

****************************************** / |>>/base                                  :2_5:Typically:
******************************************* / PAKA/akapart                            :2_5:Typically:
******************************************** / $>|                                   :2_5:Typically:
********************************************* / Aka Token                           :2_5:Typically:
Aka Token> IN: Typically GoDeeper Other "false" UnDeepe <…>
Aka Token> MATCH (EERR): <EMPTY>
Aka Token> ERROR:
Aka Token> offset=11:
Aka Token> unexpected Typically
Aka Token> expecting Aka

$>|> IN: Typically GoDeeper Other "false" UnDeepe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=11:
$>|> unexpected Typically
$>|> expecting Aka

PAKA/akapart> IN: Typically GoDeeper Other "false" UnDeepe <…>
PAKA/akapart> MATCH (EERR): <EMPTY>
PAKA/akapart> ERROR:
PAKA/akapart> offset=11:
PAKA/akapart> unexpected Typically
PAKA/akapart> expecting Aka

|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=11:
|>>/base> unexpected Typically
|>>/base> expecting Aka

|?| optional something> IN: Typically GoDeeper Other "false" UnDeepe <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

***************************************** \ |?| optional something has returned (Nothing,0) :2_5:Typically:
slAKA optional akapart> IN: Typically GoDeeper Other "false" UnDeepe <…>
slAKA optional akapart> MATCH (EOK): <EMPTY>
slAKA optional akapart> VALUE: ((Nothing,0),[])

**************************************** \ slAKA optional akapart has returned (Nothing,0) :2_5:Typically:
**************************************** > |>>/base got Nothing                          :2_5:Typically:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

*************************************** \ |>>/base has returned (Nothing,0)               :2_5:Typically:
|>>/recurse> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/recurse> MATCH (COK): GoDeeper
|>>/recurse> VALUE: ((Nothing,1),[])

************************************** \ |>>/recurse has returned (Nothing,1)              :2_5:Typically:
************************************** / |>>/recurse                                       :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                          :2_5:Typically:
*************************************** / slAKA optional typically                        :2_5:Typically:
**************************************** / |?| optional something                        :2_5:Typically:
***************************************** / |>>/recurse                                 :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

***************************************** / |>>/base                                    :2_5:Typically:
****************************************** / typically                                 :2_5:Typically:
******************************************* / $>|                                     :2_5:Typically:
$>|> IN: Typically GoDeeper Other "false" UnDeepe <…>
$>|> MATCH (COK): Typically
$>|> VALUE: (Typically,[])

******************************************* \ $>| has returned Typically               :2_6:GoDeeper:
******************************************* / |>>/recurse                              :2_6:GoDeeper:
******************************************** / |>>/recurse                             :2_6:Other "fals:
|>>/recurse> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=13:
|>>/recurse> unexpected Other "false"
|>>/recurse> expecting GoDeeper

******************************************** / |>>/base                                :2_6:Other "fals:
********************************************* / slMultiTerm                           :2_6:Other "fals:
********************************************** / someSL                              :2_6:Other "fals:
someSL> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
someSL> MATCH (COK): Other "false"
someSL> VALUE: ((["false"],0),[])

********************************************** \ someSL has returned (["false"],0) :3_3:UnDeeper:
slMultiTerm> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
slMultiTerm> MATCH (COK): Other "false"
slMultiTerm> VALUE: ((["false"],0),[])

********************************************* \ slMultiTerm has returned (["false"],0) :3_3:UnDeeper:
********************************************* > |>>/base got ["false"]           :3_3:UnDeeper:
|>>/base> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
|>>/base> MATCH (COK): Other "false"
|>>/base> VALUE: ((["false"],0),[])

******************************************** \ |>>/base has returned (["false"],0) :3_3:UnDeeper:
|>>/recurse> IN: GoDeeper Other "false" UnDeeper UnDeeper <…>
|>>/recurse> MATCH (COK): GoDeeper Other "false"
|>>/recurse> VALUE: ((["false"],1),[])

******************************************* \ |>>/recurse has returned (["false"],1) :3_3:UnDeeper:
typically> IN: Typically GoDeeper Other "false" UnDeepe <…>
typically> MATCH (COK): Typically GoDeeper Other "false"
typically> VALUE: ((["false"],1),[])

****************************************** \ typically has returned (["false"],1)   :3_3:UnDeeper:
****************************************** > |>>/base got ["false"]                 :3_3:UnDeeper:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (COK): Typically GoDeeper Other "false"
|>>/base> VALUE: ((["false"],1),[])

***************************************** \ |>>/base has returned (["false"],1)      :3_3:UnDeeper:
|?| optional something> IN: Typically GoDeeper Other "false" UnDeepe <…>
|?| optional something> MATCH (COK): Typically GoDeeper Other "false"
|?| optional something> VALUE: ((Just ["false"],1),[])

**************************************** \ |?| optional something has returned (Just ["false"],1) :3_3:UnDeeper:
slAKA optional typically> IN: Typically GoDeeper Other "false" UnDeepe <…>
slAKA optional typically> MATCH (COK): Typically GoDeeper Other "false"
slAKA optional typically> VALUE: ((Just ["false"],1),[])

*************************************** \ slAKA optional typically has returned (Just ["false"],1) :3_3:UnDeeper:
*************************************** > |>>/base got Just ["false"]                  :3_3:UnDeeper:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (COK): Typically GoDeeper Other "false"
|>>/base> VALUE: ((Just ["false"],1),[])

************************************** \ |>>/base has returned (Just ["false"],1)       :3_3:UnDeeper:
************************************** > slAKA: proceeding after base and entityalias are retrieved ... :3_3:UnDeeper:
************************************** > pAKA: entityalias = Nothing                    :3_3:UnDeeper:
slAKA> IN: Other "immortal" GoDeeper Typically GoDe <…>
slAKA> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
slAKA> VALUE: ((["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************************* \ slAKA has returned (["immortal"],2)              :3_3:UnDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
$*|> VALUE: ((["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************************ \ $*| has returned (["immortal"],2)                  :3_3:UnDeeper:
RPMT> IN: Other "immortal" GoDeeper Typically GoDe <…>
RPMT> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
RPMT> VALUE: ((RPMT ["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*********************************** \ RPMT has returned (RPMT ["immortal"],2)              :3_3:UnDeeper:
slRelPred> IN: Other "immortal" GoDeeper Typically GoDe <…>
slRelPred> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
slRelPred> VALUE: ((RPMT ["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************************** \ slRelPred has returned (RPMT ["immortal"],2)           :3_3:UnDeeper:
********************************** / undeepers                                              :3_3:UnDeeper:
*********************************** > sameLine/undeepers: reached end of line; now need to clear 2 UnDeepers :3_3:UnDeeper:
*********************************** > sameLine: success!                                       :3_5:UnDeeper:
undeepers> IN: UnDeeper UnDeeper UnDeeper UnDeeper Or G <…>
undeepers> MATCH (COK): UnDeeper UnDeeper
undeepers> VALUE: ((),[])

********************************** \ undeepers has returned ()                                  :3_5:UnDeeper:
pRelPred> IN: Other "immortal" GoDeeper Typically GoDe <…>
pRelPred> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
pRelPred> VALUE: (RPMT ["immortal"],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************************* \ pRelPred has returned RPMT ["immortal"]                      :3_5:UnDeeper:
term p/3:plain p> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/3:plain p> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
term p/3:plain p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************************** \ term p/3:plain p has returned MyLeaf (RPMT ["immortal"])       :3_5:UnDeeper:
term p/notLabelTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/notLabelTerm> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["immortal"])      :3_5:UnDeeper:
term p> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
term p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

****************************** \ term p has returned MyLeaf (RPMT ["immortal"])                     :3_5:UnDeeper:
****************************** / binary(Or)                                                         :3_5:UnDeeper:
binary(Or)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=16:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

****************************** / binary(And)                                                        :3_5:UnDeeper:
binary(And)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=16:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

****************************** / binary(SetLess)                                                    :3_5:UnDeeper:
binary(SetLess)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=16:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

****************************** / binary(SetPlus)                                                    :3_5:UnDeeper:
binary(SetPlus)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=16:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "immortal" GoDeeper Typically GoDe <…>
expression> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
expression> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

***************************** \ expression has returned MyLeaf (RPMT ["immortal"])                   :3_5:UnDeeper:
manyIndentation/leaf?> IN: Other "immortal" GoDeeper Typically GoDe <…>
manyIndentation/leaf?> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
manyIndentation/leaf?> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

**************************** \ manyIndentation/leaf? has returned MyLeaf (RPMT ["immortal"])          :3_5:UnDeeper:
**************************** / myindented: consuming UnDeeper                                         :3_5:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

**************************** \ myindented: consuming UnDeeper has returned UnDeeper                     :3_6:UnDeeper:
someIndentation> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
someIndentation> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
someIndentation> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*************************** \ someIndentation has returned MyLeaf (RPMT ["immortal"])                    :3_6:UnDeeper:
term p/2:someIndentation expr p> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
term p/2:someIndentation expr p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************** \ term p/2:someIndentation expr p has returned MyLeaf (RPMT ["immortal"])      :3_6:UnDeeper:
term p/notLabelTerm> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["immortal"])                    :3_6:UnDeeper:
term p> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
term p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************ \ term p has returned MyLeaf (RPMT ["immortal"])                                   :3_6:UnDeeper:
************************ / binary(Or)                                                                       :3_6:UnDeeper:
binary(Or)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=17:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

************************ / binary(And)                                                                      :3_6:UnDeeper:
binary(And)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=17:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

************************ / binary(SetLess)                                                                  :3_6:UnDeeper:
binary(SetLess)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=17:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

************************ / binary(SetPlus)                                                                  :3_6:UnDeeper:
binary(SetPlus)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=17:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "is" GoDeeper Other "immortal" GoD <…>
expression> MATCH (COK): Other "is" GoDeeper Other "immortal" GoD <…>
expression> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*********************** \ expression has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))                :3_6:UnDeeper:
manyIndentation/leaf?> IN: Other "is" GoDeeper Other "immortal" GoD <…>
manyIndentation/leaf?> MATCH (COK): Other "is" GoDeeper Other "immortal" GoD <…>
manyIndentation/leaf?> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************** \ manyIndentation/leaf? has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))       :3_6:UnDeeper:
********************** / myindented: consuming UnDeeper                                                       :3_6:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

********************** \ myindented: consuming UnDeeper has returned UnDeeper                        :3_2:Or:
someIndentation> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
someIndentation> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
someIndentation> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************* \ someIndentation has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))      :3_2:Or:
term p/2:someIndentation expr p> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
term p/2:someIndentation expr p> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************** \ term p/2:someIndentation expr p has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"])) :3_2:Or:
term p/notLabelTerm> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
term p/notLabelTerm> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************* \ term p/notLabelTerm has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))      :3_2:Or:
term p> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
term p> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

****************** \ term p has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))                     :3_2:Or:
****************** / binary(Or)                                                                          :3_2:Or:
binary(Or)> IN: Or GoDeeper Other "has" GoDeeper Other " <…>
binary(Or)> MATCH (COK): Or
binary(Or)> VALUE: (Or,[])

****************** \ binary(Or) has returned Or                                                           :3_3:GoDeeper:
****************** / term p                                                                               :3_3:GoDeeper:
******************* / term p/1a:label directly above                                                     :3_3:GoDeeper:
******************** / $*|                                                                              :3_3:GoDeeper:
********************* / someSL                                                                         :3_3:GoDeeper:
********************** / pNumAsText                                                                   :3_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=19:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=19:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=19:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=19:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

******************* / term p/b:label to the left of line below, with EOL                                 :3_3:GoDeeper:
******************** / someSL                                                                           :3_3:GoDeeper:
********************* / pNumAsText                                                                     :3_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=19:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=19:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=19:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

******************* / term p/notLabelTerm                                                                :3_3:GoDeeper:
******************** / term p/2:someIndentation expr p                                                  :3_3:GoDeeper:
********************* / someIndentation                                                                :3_3:GoDeeper:
********************** / myindented: consuming GoDeeper                                               :3_3:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

********************** \ myindented: consuming GoDeeper has returned GoDeeper                          :3_3:Other "has":
********************** / manyIndentation/leaf?                                                         :3_3:Other "has":
*********************** / expression                                                                  :3_3:Other "has":
************************ / labelPrefix                                                               :3_3:Other "has":
labelPrefix> IN: Other "has" GoDeeper Other "health insur <…>
labelPrefix> MATCH (COK): Other "has"
labelPrefix> VALUE: ("has",[])

************************ \ labelPrefix has returned "has"                                             :3_4:GoDeeper:
************************ / term p                                                                     :3_4:GoDeeper:
************************* / term p/1a:label directly above                                           :3_4:GoDeeper:
************************** / $*|                                                                    :3_4:GoDeeper:
*************************** / someSL                                                               :3_4:GoDeeper:
**************************** / pNumAsText                                                         :3_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "health insurance" UnDeep <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=21:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "health insurance" UnDeep <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=21:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "health insurance" UnDeep <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=21:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=21:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

************************* / term p/b:label to the left of line below, with EOL                       :3_4:GoDeeper:
************************** / someSL                                                                 :3_4:GoDeeper:
*************************** / pNumAsText                                                           :3_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "health insurance" UnDeep <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=21:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "health insurance" UnDeep <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=21:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=21:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

************************* / term p/notLabelTerm                                                      :3_4:GoDeeper:
************************** / term p/2:someIndentation expr p                                        :3_4:GoDeeper:
*************************** / someIndentation                                                      :3_4:GoDeeper:
**************************** / myindented: consuming GoDeeper                                     :3_4:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "health insurance" UnDeep <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

**************************** \ myindented: consuming GoDeeper has returned GoDeeper                :3_4:Other "heal:
**************************** / manyIndentation/leaf?                                               :3_4:Other "heal:
***************************** / expression                                                        :3_4:Other "heal:
****************************** / labelPrefix                                                     :3_4:Other "heal:
labelPrefix> IN: Other "health insurance" UnDeeper UnDeep <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=23:
labelPrefix> unexpected UnDeeper

****************************** / term p                                                          :3_4:Other "heal:
******************************* / term p/1a:label directly above                                :3_4:Other "heal:
******************************** / $*|                                                         :3_4:Other "heal:
********************************* / someSL                                                    :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

********************************* \ someSL has returned (["health insurance"],0)           :4_2:UnDeeper:
********************************* / pNumAsText                                             :4_2:UnDeeper:
pNumAsText> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=23:
pNumAsText> unexpected UnDeeper
pNumAsText> expecting number

$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (CERR): Other "health insurance"
$*|> ERROR:
$*|> offset=23:
$*|> unexpected UnDeeper
$*|> expecting GoDeeper or other text or number

term p/1a:label directly above> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/1a:label directly above> MATCH (CERR): Other "health insurance"
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=23:
term p/1a:label directly above> unexpected UnDeeper
term p/1a:label directly above> expecting GoDeeper or other text or number

******************************* / term p/b:label to the left of line below, with EOL            :3_4:Other "heal:
******************************** / someSL                                                      :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

******************************** \ someSL has returned (["health insurance"],0)             :4_2:UnDeeper:
******************************** / undeepers                                                :4_2:UnDeeper:
********************************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers :4_2:UnDeeper:
********************************* > sameLine: success!                                     :4_2:UnDeeper:
undeepers> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

******************************** \ undeepers has returned ()                                :4_2:UnDeeper:
******************************** / matching EOL                                             :4_2:UnDeeper:
matching EOL> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
matching EOL> MATCH (EERR): <EMPTY>
matching EOL> ERROR:
matching EOL> offset=23:
matching EOL> unexpected UnDeeper
matching EOL> expecting EOL

term p/b:label to the left of line below, with EOL> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/b:label to the left of line below, with EOL> MATCH (CERR): Other "health insurance"
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=23:
term p/b:label to the left of line below, with EOL> unexpected UnDeeper
term p/b:label to the left of line below, with EOL> expecting EOL or GoDeeper

******************************* / term p/notLabelTerm                                           :3_4:Other "heal:
******************************** / term p/2:someIndentation expr p                             :3_4:Other "heal:
********************************* / someIndentation                                           :3_4:Other "heal:
********************************** / myindented: consuming GoDeeper                          :3_4:Other "heal:
myindented: consuming GoDeeper> IN: Other "health insurance" UnDeeper UnDeep <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=22:
myindented: consuming GoDeeper> unexpected Other "health insurance"
myindented: consuming GoDeeper> expecting GoDeeper

someIndentation> IN: Other "health insurance" UnDeeper UnDeep <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=22:
someIndentation> unexpected Other "health insurance"
someIndentation> expecting GoDeeper

term p/2:someIndentation expr p> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/2:someIndentation expr p> MATCH (EERR): <EMPTY>
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=22:
term p/2:someIndentation expr p> unexpected Other "health insurance"
term p/2:someIndentation expr p> expecting GoDeeper

******************************** / term p/3:plain p                                            :3_4:Other "heal:
********************************* / pRelPred                                                  :3_4:Other "heal:
********************************** / slRelPred                                               :3_4:Other "heal:
*********************************** / nested simpleHorn                                     :3_4:Other "heal:
************************************ > |^|                                                 :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slMultiTerm                                       :3_4:Other "heal:
************************************** / someSL                                          :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

************************************* \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
************************************ / |^| deeps                                        :4_2:UnDeeper:
|^| deeps> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|^| deeps> MATCH (COK): UnDeeper UnDeeper UnDeeper
|^| deeps> VALUE: (([(),(),()],-3),[])

************************************ \ |^| deeps has returned ([(),(),()],-3)        :4_1:May:
nested simpleHorn> IN: Other "health insurance" UnDeeper UnDeep <…>
nested simpleHorn> MATCH (CERR): Other "health insurance" UnDeeper UnDeep <…>
nested simpleHorn> ERROR:
nested simpleHorn> offset=26:
nested simpleHorn> unexpected May
nested simpleHorn> expecting Means or UnDeeper

*********************************** / RPConstraint                                          :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slMultiTerm                                       :3_4:Other "heal:
************************************** / someSL                                          :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

************************************* \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
************************************ / |>| calling $>>                                  :4_2:UnDeeper:
************************************* / |>>/recurse                                    :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************* / |>>/base                                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=23:
|>| calling $>>> unexpected UnDeeper
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPConstraint> IN: Other "health insurance" UnDeeper UnDeep <…>
RPConstraint> MATCH (CERR): Other "health insurance"
RPConstraint> ERROR:
RPConstraint> offset=23:
RPConstraint> unexpected UnDeeper
RPConstraint> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPBoolStructR                                         :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slMultiTerm                                       :3_4:Other "heal:
************************************** / someSL                                          :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

************************************* \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
************************************ / |>| calling $>>                                  :4_2:UnDeeper:
************************************* / |>>/recurse                                    :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************* / |>>/base                                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=23:
|>| calling $>>> unexpected UnDeeper
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPBoolStructR> IN: Other "health insurance" UnDeeper UnDeep <…>
RPBoolStructR> MATCH (CERR): Other "health insurance"
RPBoolStructR> ERROR:
RPBoolStructR> offset=23:
RPBoolStructR> unexpected UnDeeper
RPBoolStructR> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPMT                                                  :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slAKA                                             :3_4:Other "heal:
************************************** / $*|                                             :3_4:Other "heal:
*************************************** / slAKA base                                    :3_4:Other "heal:
**************************************** / slMultiTerm                                 :3_4:Other "heal:
***************************************** / someSL                                    :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

***************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

**************************************** \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
slAKA base> IN: Other "health insurance" UnDeeper UnDeep <…>
slAKA base> MATCH (COK): Other "health insurance"
slAKA base> VALUE: ((["health insurance"],0),[])

*************************************** \ slAKA base has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************** \ $*| has returned (["health insurance"],0)    :4_2:UnDeeper:
************************************** / |>>/recurse                                  :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                     :4_2:UnDeeper:
*************************************** / slAKA optional akapart                     :4_2:UnDeeper:
**************************************** / |?| optional something                   :4_2:UnDeeper:
***************************************** / |>>/recurse                            :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

***************************************** / |>>/base                               :4_2:UnDeeper:
****************************************** / PAKA/akapart                         :4_2:UnDeeper:
******************************************* / $>|                                :4_2:UnDeeper:
******************************************** / Aka Token                        :4_2:UnDeeper:
Aka Token> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
Aka Token> MATCH (EERR): <EMPTY>
Aka Token> ERROR:
Aka Token> offset=23:
Aka Token> unexpected UnDeeper
Aka Token> expecting Aka

$>|> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=23:
$>|> unexpected UnDeeper
$>|> expecting Aka

PAKA/akapart> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
PAKA/akapart> MATCH (EERR): <EMPTY>
PAKA/akapart> ERROR:
PAKA/akapart> offset=23:
PAKA/akapart> unexpected UnDeeper
PAKA/akapart> expecting Aka

|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Aka

|?| optional something> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

**************************************** \ |?| optional something has returned (Nothing,0) :4_2:UnDeeper:
slAKA optional akapart> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
slAKA optional akapart> MATCH (EOK): <EMPTY>
slAKA optional akapart> VALUE: ((Nothing,0),[])

*************************************** \ slAKA optional akapart has returned (Nothing,0) :4_2:UnDeeper:
*************************************** > |>>/base got Nothing                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************************************** \ |>>/base has returned (Nothing,0)            :4_2:UnDeeper:
************************************** / |>>/recurse                                  :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                     :4_2:UnDeeper:
*************************************** / slAKA optional typically                   :4_2:UnDeeper:
**************************************** / |?| optional something                   :4_2:UnDeeper:
***************************************** / |>>/recurse                            :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

***************************************** / |>>/base                               :4_2:UnDeeper:
****************************************** / typically                            :4_2:UnDeeper:
******************************************* / $>|                                :4_2:UnDeeper:
$>|> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=23:
$>|> unexpected UnDeeper
$>|> expecting Typically

typically> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
typically> MATCH (EERR): <EMPTY>
typically> ERROR:
typically> offset=23:
typically> unexpected UnDeeper
typically> expecting Typically

|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Typically

|?| optional something> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

**************************************** \ |?| optional something has returned (Nothing,0) :4_2:UnDeeper:
slAKA optional typically> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
slAKA optional typically> MATCH (EOK): <EMPTY>
slAKA optional typically> VALUE: ((Nothing,0),[])

*************************************** \ slAKA optional typically has returned (Nothing,0) :4_2:UnDeeper:
*************************************** > |>>/base got Nothing                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************************************** \ |>>/base has returned (Nothing,0)            :4_2:UnDeeper:
************************************** > slAKA: proceeding after base and entityalias are retrieved ... :4_2:UnDeeper:
************************************** > pAKA: entityalias = Nothing                  :4_2:UnDeeper:
slAKA> IN: Other "health insurance" UnDeeper UnDeep <…>
slAKA> MATCH (COK): Other "health insurance"
slAKA> VALUE: ((["health insurance"],0),[])

************************************* \ slAKA has returned (["health insurance"],0)    :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
RPMT> IN: Other "health insurance" UnDeeper UnDeep <…>
RPMT> MATCH (COK): Other "health insurance"
RPMT> VALUE: ((RPMT ["health insurance"],0),[])

*********************************** \ RPMT has returned (RPMT ["health insurance"],0)    :4_2:UnDeeper:
slRelPred> IN: Other "health insurance" UnDeeper UnDeep <…>
slRelPred> MATCH (COK): Other "health insurance"
slRelPred> VALUE: ((RPMT ["health insurance"],0),[])

********************************** \ slRelPred has returned (RPMT ["health insurance"],0) :4_2:UnDeeper:
********************************** / undeepers                                            :4_2:UnDeeper:
*********************************** > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers :4_2:UnDeeper:
*********************************** > sameLine: success!                                 :4_2:UnDeeper:
undeepers> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

********************************** \ undeepers has returned ()                            :4_2:UnDeeper:
pRelPred> IN: Other "health insurance" UnDeeper UnDeep <…>
pRelPred> MATCH (COK): Other "health insurance"
pRelPred> VALUE: (RPMT ["health insurance"],[])

********************************* \ pRelPred has returned RPMT ["health insurance"]        :4_2:UnDeeper:
term p/3:plain p> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/3:plain p> MATCH (COK): Other "health insurance"
term p/3:plain p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

******************************** \ term p/3:plain p has returned MyLeaf (RPMT ["health insurance"]) :4_2:UnDeeper:
term p/notLabelTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/notLabelTerm> MATCH (COK): Other "health insurance"
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

******************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["health insurance"]) :4_2:UnDeeper:
term p> IN: Other "health insurance" UnDeeper UnDeep <…>
term p> MATCH (COK): Other "health insurance"
term p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

****************************** \ term p has returned MyLeaf (RPMT ["health insurance"])       :4_2:UnDeeper:
****************************** / binary(Or)                                                   :4_2:UnDeeper:
binary(Or)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=23:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

****************************** / binary(And)                                                  :4_2:UnDeeper:
binary(And)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=23:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

****************************** / binary(SetLess)                                              :4_2:UnDeeper:
binary(SetLess)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=23:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

****************************** / binary(SetPlus)                                              :4_2:UnDeeper:
binary(SetPlus)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=23:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "health insurance" UnDeeper UnDeep <…>
expression> MATCH (COK): Other "health insurance"
expression> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

***************************** \ expression has returned MyLeaf (RPMT ["health insurance"])     :4_2:UnDeeper:
manyIndentation/leaf?> IN: Other "health insurance" UnDeeper UnDeep <…>
manyIndentation/leaf?> MATCH (COK): Other "health insurance"
manyIndentation/leaf?> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

**************************** \ manyIndentation/leaf? has returned MyLeaf (RPMT ["health insurance"]) :4_2:UnDeeper:
**************************** / myindented: consuming UnDeeper                                   :4_2:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

**************************** \ myindented: consuming UnDeeper has returned UnDeeper               :4_3:UnDeeper:
someIndentation> IN: GoDeeper Other "health insurance" UnDeep <…>
someIndentation> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
someIndentation> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

*************************** \ someIndentation has returned MyLeaf (RPMT ["health insurance"])      :4_3:UnDeeper:
term p/2:someIndentation expr p> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
term p/2:someIndentation expr p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

************************** \ term p/2:someIndentation expr p has returned MyLeaf (RPMT ["health insurance"]) :4_3:UnDeeper:
term p/notLabelTerm> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["health insurance"])      :4_3:UnDeeper:
term p> IN: GoDeeper Other "health insurance" UnDeep <…>
term p> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
term p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

************************ \ term p has returned MyLeaf (RPMT ["health insurance"])                     :4_3:UnDeeper:
************************ / binary(Or)                                                                 :4_3:UnDeeper:
binary(Or)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=24:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

************************ / binary(And)                                                                :4_3:UnDeeper:
binary(And)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=24:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

************************ / binary(SetLess)                                                            :4_3:UnDeeper:
binary(SetLess)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=24:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

************************ / binary(SetPlus)                                                            :4_3:UnDeeper:
binary(SetPlus)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=24:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "has" GoDeeper Other "health insur <…>
expression> MATCH (COK): Other "has" GoDeeper Other "health insur <…>
expression> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

*********************** \ expression has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])) :4_3:UnDeeper:
manyIndentation/leaf?> IN: Other "has" GoDeeper Other "health insur <…>
manyIndentation/leaf?> MATCH (COK): Other "has" GoDeeper Other "health insur <…>
manyIndentation/leaf?> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

********************** \ manyIndentation/leaf? has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])) :4_3:UnDeeper:
********************** / myindented: consuming UnDeeper                                                 :4_3:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

********************** \ myindented: consuming UnDeeper has returned UnDeeper                             :4_4:UnDeeper:
someIndentation> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
someIndentation> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
someIndentation> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

********************* \ someIndentation has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))  :4_4:UnDeeper:
term p/2:someIndentation expr p> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
term p/2:someIndentation expr p> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

******************** \ term p/2:someIndentation expr p has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])) :4_4:UnDeeper:
term p/notLabelTerm> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
term p/notLabelTerm> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

******************* \ term p/notLabelTerm has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))  :4_4:UnDeeper:
term p> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
term p> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

****************** \ term p has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))                 :4_4:UnDeeper:
****************** / binary(Or)                                                                               :4_4:UnDeeper:
binary(Or)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=25:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

****************** / binary(And)                                                                              :4_4:UnDeeper:
binary(And)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=25:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

****************** / binary(SetLess)                                                                          :4_4:UnDeeper:
binary(SetLess)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=25:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

****************** / binary(SetPlus)                                                                          :4_4:UnDeeper:
binary(SetPlus)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=25:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
expression> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
expression> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

***************** \ expression has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_4:UnDeeper:
manyIndentation/leaf?> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
manyIndentation/leaf?> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
manyIndentation/leaf?> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

**************** \ manyIndentation/leaf? has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_4:UnDeeper:
**************** / myindented: consuming UnDeeper                                                               :4_4:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

**************** \ myindented: consuming UnDeeper has returned UnDeeper                                  :4_1:May:
someIndentation> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someIndentation> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someIndentation> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*************** \ someIndentation has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
term p/2:someIndentation expr p> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/2:someIndentation expr p> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************** \ term p/2:someIndentation expr p has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
term p/notLabelTerm> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/notLabelTerm> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/notLabelTerm> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************* \ term p/notLabelTerm has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
term p> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************ \ term p has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
************ / binary(Or)                                                                                    :4_1:May:
binary(Or)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=26:
binary(Or)> unexpected May
binary(Or)> expecting Or

************ / binary(And)                                                                                   :4_1:May:
binary(And)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=26:
binary(And)> unexpected May
binary(And)> expecting And

************ / binary(SetLess)                                                                               :4_1:May:
binary(SetLess)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=26:
binary(SetLess)> unexpected May
binary(SetLess)> expecting SetLess

************ / binary(SetPlus)                                                                               :4_1:May:
binary(SetPlus)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=26:
binary(SetPlus)> unexpected May
binary(SetPlus)> expecting SetPlus

expression> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
expression> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
expression> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*********** \ expression has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
ppp inner> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
ppp inner> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
ppp inner> VALUE: (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********** \ ppp inner has returned Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])] :4_1:May:
pBSR> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pBSR> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pBSR> VALUE: (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********* \ pBSR has returned Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])] :4_1:May:
preambleBoolStructR [Who,Which,Whose]> IN: Who GoDeeper GoDeeper Other "is" GoDeepe <…>
preambleBoolStructR [Who,Which,Whose]> MATCH (COK): Who GoDeeper GoDeeper Other "is" GoDeepe <…>
preambleBoolStructR [Who,Which,Whose]> VALUE: ((Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******** \ preambleBoolStructR [Who,Which,Whose] has returned (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]) :4_1:May:
manyIndentation/leaf?> IN: Who GoDeeper GoDeeper Other "is" GoDeepe <…>
manyIndentation/leaf?> MATCH (COK): Who GoDeeper GoDeeper Other "is" GoDeepe <…>
manyIndentation/leaf?> VALUE: ((Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******* \ manyIndentation/leaf? has returned (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]) :4_1:May:
******* / WHERE                                                                                                   :4_1:May:
WHERE> IN: May GoDeeper Other "sharpen knives" UnDe <…>
WHERE> MATCH (EERR): <EMPTY>
WHERE> ERROR:
WHERE> offset=26:
WHERE> unexpected May
WHERE> expecting Where

******* / preambleParamText:[Having]                                                                              :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=26:
$>|> unexpected May
$>|> expecting Having

preambleParamText:[Having]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleParamText:[Having]> MATCH (EERR): <EMPTY>
preambleParamText:[Having]> ERROR:
preambleParamText:[Having]> offset=26:
preambleParamText:[Having]> unexpected May
preambleParamText:[Having]> expecting Having

******* / preambleParamText:[Given]                                                                               :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=26:
$>|> unexpected May
$>|> expecting Given

preambleParamText:[Given]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=26:
preambleParamText:[Given]> unexpected May
preambleParamText:[Given]> expecting Given

******* / preambleParamText:[Upon]                                                                                :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=26:
$>|> unexpected May
$>|> expecting Upon

preambleParamText:[Upon]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=26:
preambleParamText:[Upon]> unexpected May
preambleParamText:[Upon]> expecting Upon

******* / preambleBoolStructR [Unless]                                                                            :4_1:May:
preambleBoolStructR [Unless]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleBoolStructR [Unless]> MATCH (EERR): <EMPTY>
preambleBoolStructR [Unless]> ERROR:
preambleBoolStructR [Unless]> offset=26:
preambleBoolStructR [Unless]> unexpected May
preambleBoolStructR [Unless]> expecting Unless

******* / preambleBoolStructR [When,If]                                                                           :4_1:May:
preambleBoolStructR [When,If]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleBoolStructR [When,If]> MATCH (EERR): <EMPTY>
preambleBoolStructR [When,If]> ERROR:
preambleBoolStructR [When,If]> offset=26:
preambleBoolStructR [When,If]> unexpected May
preambleBoolStructR [When,If]> expecting If or When

******* / pDT                                                                                                     :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (COK): May
$>|> VALUE: (DMay,[])

******** \ $>| has returned DMay                                                                                  :4_2:GoDeeper:
******** / |>| calling $>>                                                                                        :4_2:GoDeeper:
********* / |>>/recurse                                                                                          :4_2:GoDeeper:
********** / |>>/recurse                                                                                         :4_2:Other "shar:
|>>/recurse> IN: Other "sharpen knives" UnDeeper
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=28:
|>>/recurse> unexpected Other "sharpen knives"
|>>/recurse> expecting GoDeeper

********** / |>>/base                                                                                            :4_2:Other "shar:
*********** / pTemporal/eventually                                                                              :4_2:Other "shar:
pTemporal/eventually> IN: Other "sharpen knives" UnDeeper
pTemporal/eventually> MATCH (EERR): <EMPTY>
pTemporal/eventually> ERROR:
pTemporal/eventually> offset=28:
pTemporal/eventually> unexpected Other "sharpen knives"
pTemporal/eventually> expecting Eventually

*********** / pTemporal/specifically                                                                            :4_2:Other "shar:
************ / $>|                                                                                             :4_2:Other "shar:
$>|> IN: Other "sharpen knives" UnDeeper
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=28:
$>|> unexpected Other "sharpen knives"
$>|> expecting After, Before, By, or On

pTemporal/specifically> IN: Other "sharpen knives" UnDeeper
pTemporal/specifically> MATCH (EERR): <EMPTY>
pTemporal/specifically> ERROR:
pTemporal/specifically> offset=28:
pTemporal/specifically> unexpected Other "sharpen knives"
pTemporal/specifically> expecting After, Before, By, or On

*********** / pTemporal/vaguely                                                                                 :4_2:Other "shar:
pTemporal/vaguely> IN: Other "sharpen knives" UnDeeper
pTemporal/vaguely> MATCH (COK): Other "sharpen knives"
pTemporal/vaguely> VALUE: (Just (TemporalConstraint TVague (Just 0) "sharpen knives"),[])

*********** \ pTemporal/vaguely has returned Just (TemporalConstraint TVague (Just 0) "sharpen knives")          :1_2:UnDeeper:
*********** > |>>/base got Just (Just (TemporalConstraint TVague (Just 0) "sharpen knives"))                     :1_2:UnDeeper:
|>>/base> IN: Other "sharpen knives" UnDeeper
|>>/base> MATCH (COK): Other "sharpen knives"
|>>/base> VALUE: ((Just (Just (TemporalConstraint TVague (Just 0) "sharpen knives")),0),[])

********** \ |>>/base has returned (Just (Just (TemporalConstraint TVague (Just 0) "sharpen knives")),0)          :1_2:UnDeeper:
|>>/recurse> IN: GoDeeper Other "sharpen knives" UnDeeper
|>>/recurse> MATCH (COK): GoDeeper Other "sharpen knives"
|>>/recurse> VALUE: ((Just (Just (TemporalConstraint TVague (Just 0) "sharpen knives")),1),[])

********* \ |>>/recurse has returned (Just (Just (TemporalConstraint TVague (Just 0) "sharpen knives")),1)         :1_2:UnDeeper:
|>| calling $>>> IN: GoDeeper Other "sharpen knives" UnDeeper
|>| calling $>>> MATCH (COK): GoDeeper Other "sharpen knives"
|>| calling $>>> VALUE: ((Just (Just (TemporalConstraint TVague (Just 0) "sharpen knives")),1),[])

******** \ |>| calling $>> has returned (Just (Just (TemporalConstraint TVague (Just 0) "sharpen knives")),1)       :1_2:UnDeeper:
******** / undeepers                                                                                                :1_2:UnDeeper:
********* > sameLine/undeepers: reached end of line; now need to clear 1 UnDeepers                                 :1_2:UnDeeper:
********* > sameLine: success!                                                                                :EOF:
undeepers> IN: UnDeeper
undeepers> MATCH (COK): UnDeeper
undeepers> VALUE: ((),[])

******** \ undeepers has returned ()                                                                           :EOF:
pDT> IN: May GoDeeper Other "sharpen knives" UnDe <…>
pDT> MATCH (COK): May GoDeeper Other "sharpen knives" UnDe <…>
pDT> VALUE: ((DMay,Just (TemporalConstraint TVague (Just 0) "sharpen knives")),[])

******* \ pDT has returned (DMay,Just (TemporalConstraint TVague (Just 0) "sharpen knives"))                    :EOF:
******* / WHERE                                                                                                 :EOF:
WHERE> IN: <EMPTY>
WHERE> MATCH (EERR): <EMPTY>
WHERE> ERROR:
WHERE> offset=30:
WHERE> unexpected end of input
WHERE> expecting Where

******* / preambleParamText:[Having]                                                                            :EOF:
******** / $>|                                                                                                 :EOF:
$>|> IN: <EMPTY>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=30:
$>|> unexpected end of input
$>|> expecting Having

preambleParamText:[Having]> IN: <EMPTY>
preambleParamText:[Having]> MATCH (EERR): <EMPTY>
preambleParamText:[Having]> ERROR:
preambleParamText:[Having]> offset=30:
preambleParamText:[Having]> unexpected end of input
preambleParamText:[Having]> expecting Having or any token

******* / preambleParamText:[Given]                                                                             :EOF:
******** / $>|                                                                                                 :EOF:
$>|> IN: <EMPTY>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=30:
$>|> unexpected end of input
$>|> expecting Given

preambleParamText:[Given]> IN: <EMPTY>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=30:
preambleParamText:[Given]> unexpected end of input
preambleParamText:[Given]> expecting Given or any token

******* / preambleParamText:[Upon]                                                                              :EOF:
******** / $>|                                                                                                 :EOF:
$>|> IN: <EMPTY>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=30:
$>|> unexpected end of input
$>|> expecting Upon

preambleParamText:[Upon]> IN: <EMPTY>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=30:
preambleParamText:[Upon]> unexpected end of input
preambleParamText:[Upon]> expecting Upon or any token

******* / preambleBoolStructR [Unless]                                                                          :EOF:
preambleBoolStructR [Unless]> IN: <EMPTY>
preambleBoolStructR [Unless]> MATCH (EERR): <EMPTY>
preambleBoolStructR [Unless]> ERROR:
preambleBoolStructR [Unless]> offset=30:
preambleBoolStructR [Unless]> unexpected end of input
preambleBoolStructR [Unless]> expecting Unless

******* / preambleBoolStructR [When,If]                                                                         :EOF:
preambleBoolStructR [When,If]> IN: <EMPTY>
preambleBoolStructR [When,If]> MATCH (EERR): <EMPTY>
preambleBoolStructR [When,If]> ERROR:
preambleBoolStructR [When,If]> offset=30:
preambleBoolStructR [When,If]> unexpected end of input
preambleBoolStructR [When,If]> expecting If or When

******* / pDoAction/Do                                                                                          :EOF:
pDoAction/Do> IN: <EMPTY>
pDoAction/Do> MATCH (EERR): <EMPTY>
pDoAction/Do> ERROR:
pDoAction/Do> offset=30:
pDoAction/Do> unexpected end of input
pDoAction/Do> expecting Do

regulative permutation with deontic-temporal> IN: Every GoDeeper Other "person" UnDeeper W <…>
regulative permutation with deontic-temporal> MATCH (CERR): Every GoDeeper Other "person" UnDeeper W <…>
regulative permutation with deontic-temporal> ERROR:
regulative permutation with deontic-temporal> offset=30:
regulative permutation with deontic-temporal> unexpected end of input
regulative permutation with deontic-temporal> expecting Do, Given, Having, If, Unless, Upon, When, Where, or any token

****** / regulative permutation with deontic-action                                                                :1_1:Every:
******* / WHERE                                                                                                   :1_1:Every:
WHERE> IN: Every GoDeeper Other "person" UnDeeper W <…>
WHERE> MATCH (EERR): <EMPTY>
WHERE> ERROR:
WHERE> offset=0:
WHERE> unexpected Every
WHERE> expecting Where

******* / preambleParamText:[Having]                                                                              :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting Having

preambleParamText:[Having]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleParamText:[Having]> MATCH (EERR): <EMPTY>
preambleParamText:[Having]> ERROR:
preambleParamText:[Having]> offset=0:
preambleParamText:[Having]> unexpected Every
preambleParamText:[Having]> expecting Having

******* / preambleParamText:[Given]                                                                               :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting Given

preambleParamText:[Given]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=0:
preambleParamText:[Given]> unexpected Every
preambleParamText:[Given]> expecting Given

******* / preambleParamText:[Upon]                                                                                :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting Upon

preambleParamText:[Upon]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=0:
preambleParamText:[Upon]> unexpected Every
preambleParamText:[Upon]> expecting Upon

******* / preambleBoolStructR [Unless]                                                                            :1_1:Every:
preambleBoolStructR [Unless]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleBoolStructR [Unless]> MATCH (EERR): <EMPTY>
preambleBoolStructR [Unless]> ERROR:
preambleBoolStructR [Unless]> offset=0:
preambleBoolStructR [Unless]> unexpected Every
preambleBoolStructR [Unless]> expecting Unless

******* / preambleBoolStructR [When,If]                                                                           :1_1:Every:
preambleBoolStructR [When,If]> IN: Every GoDeeper Other "person" UnDeeper W <…>
preambleBoolStructR [When,If]> MATCH (EERR): <EMPTY>
preambleBoolStructR [When,If]> ERROR:
preambleBoolStructR [When,If]> offset=0:
preambleBoolStructR [When,If]> unexpected Every
preambleBoolStructR [When,If]> expecting If or When

******* / pTemporal/eventually                                                                                    :1_1:Every:
pTemporal/eventually> IN: Every GoDeeper Other "person" UnDeeper W <…>
pTemporal/eventually> MATCH (EERR): <EMPTY>
pTemporal/eventually> ERROR:
pTemporal/eventually> offset=0:
pTemporal/eventually> unexpected Every
pTemporal/eventually> expecting Eventually

******* / pTemporal/specifically                                                                                  :1_1:Every:
******** / $>|                                                                                                   :1_1:Every:
$>|> IN: Every GoDeeper Other "person" UnDeeper W <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected Every
$>|> expecting After, Before, By, or On

pTemporal/specifically> IN: Every GoDeeper Other "person" UnDeeper W <…>
pTemporal/specifically> MATCH (EERR): <EMPTY>
pTemporal/specifically> ERROR:
pTemporal/specifically> offset=0:
pTemporal/specifically> unexpected Every
pTemporal/specifically> expecting After, Before, By, or On

******* / pTemporal/vaguely                                                                                       :1_1:Every:
pTemporal/vaguely> IN: Every GoDeeper Other "person" UnDeeper W <…>
pTemporal/vaguely> MATCH (EERR): <EMPTY>
pTemporal/vaguely> ERROR:
pTemporal/vaguely> offset=0:
pTemporal/vaguely> unexpected Every
pTemporal/vaguely> expecting Other text

******* / pActor [Every,Party,TokAll]                                                                             :1_1:Every:
******** / someIndentation                                                                                        :1_2:GoDeeper:
********* / myindented: consuming GoDeeper                                                                       :1_2:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "person" UnDeeper Who GoD <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

********* \ myindented: consuming GoDeeper has returned GoDeeper                                                  :1_2:Other "pers:
********* / manyIndentation/leaf?                                                                                 :1_2:Other "pers:
********** / pMultiTermAka                                                                                       :1_2:Other "pers:
*********** / pAKA                                                                                              :1_2:Other "pers:
************ / slAKA                                                                                           :1_2:Other "pers:
************* / $*|                                                                                           :1_2:Other "pers:
************** / slAKA base                                                                                  :1_2:Other "pers:
*************** / slMultiTerm                                                                               :1_2:Other "pers:
**************** / someSL                                                                                  :1_2:Other "pers:
someSL> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
someSL> MATCH (COK): Other "person"
someSL> VALUE: ((["person"],0),[])

**************** \ someSL has returned (["person"],0)                                                       :2_2:UnDeeper:
slMultiTerm> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
slMultiTerm> MATCH (COK): Other "person"
slMultiTerm> VALUE: ((["person"],0),[])

*************** \ slMultiTerm has returned (["person"],0)                                                    :2_2:UnDeeper:
slAKA base> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
slAKA base> MATCH (COK): Other "person"
slAKA base> VALUE: ((["person"],0),[])

************** \ slAKA base has returned (["person"],0)                                                       :2_2:UnDeeper:
$*|> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
$*|> MATCH (COK): Other "person"
$*|> VALUE: ((["person"],0),[])

************* \ $*| has returned (["person"],0)                                                                :2_2:UnDeeper:
************* / |>>/recurse                                                                                    :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************* / |>>/base                                                                                       :2_2:UnDeeper:
************** / slAKA optional akapart                                                                       :2_2:UnDeeper:
*************** / |?| optional something                                                                     :2_2:UnDeeper:
**************** / |>>/recurse                                                                              :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

**************** / |>>/base                                                                                 :2_2:UnDeeper:
***************** / PAKA/akapart                                                                           :2_2:UnDeeper:
****************** / $>|                                                                                  :2_2:UnDeeper:
******************* / Aka Token                                                                          :2_2:UnDeeper:
Aka Token> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
Aka Token> MATCH (EERR): <EMPTY>
Aka Token> ERROR:
Aka Token> offset=3:
Aka Token> unexpected UnDeeper
Aka Token> expecting Aka

$>|> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=3:
$>|> unexpected UnDeeper
$>|> expecting Aka

PAKA/akapart> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
PAKA/akapart> MATCH (EERR): <EMPTY>
PAKA/akapart> ERROR:
PAKA/akapart> offset=3:
PAKA/akapart> unexpected UnDeeper
PAKA/akapart> expecting Aka

|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=3:
|>>/base> unexpected UnDeeper
|>>/base> expecting Aka

|?| optional something> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

*************** \ |?| optional something has returned (Nothing,0)                                            :2_2:UnDeeper:
slAKA optional akapart> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
slAKA optional akapart> MATCH (EOK): <EMPTY>
slAKA optional akapart> VALUE: ((Nothing,0),[])

************** \ slAKA optional akapart has returned (Nothing,0)                                              :2_2:UnDeeper:
************** > |>>/base got Nothing                                                                         :2_2:UnDeeper:
|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************* \ |>>/base has returned (Nothing,0)                                                              :2_2:UnDeeper:
************* / |>>/recurse                                                                                    :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************* / |>>/base                                                                                       :2_2:UnDeeper:
************** / slAKA optional typically                                                                     :2_2:UnDeeper:
*************** / |?| optional something                                                                     :2_2:UnDeeper:
**************** / |>>/recurse                                                                              :2_2:UnDeeper:
|>>/recurse> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=3:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

**************** / |>>/base                                                                                 :2_2:UnDeeper:
***************** / typically                                                                              :2_2:UnDeeper:
****************** / $>|                                                                                  :2_2:UnDeeper:
$>|> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=3:
$>|> unexpected UnDeeper
$>|> expecting Typically

typically> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
typically> MATCH (EERR): <EMPTY>
typically> ERROR:
typically> offset=3:
typically> unexpected UnDeeper
typically> expecting Typically

|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=3:
|>>/base> unexpected UnDeeper
|>>/base> expecting Typically

|?| optional something> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

*************** \ |?| optional something has returned (Nothing,0)                                            :2_2:UnDeeper:
slAKA optional typically> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
slAKA optional typically> MATCH (EOK): <EMPTY>
slAKA optional typically> VALUE: ((Nothing,0),[])

************** \ slAKA optional typically has returned (Nothing,0)                                            :2_2:UnDeeper:
************** > |>>/base got Nothing                                                                         :2_2:UnDeeper:
|>>/base> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************* \ |>>/base has returned (Nothing,0)                                                              :2_2:UnDeeper:
************* > slAKA: proceeding after base and entityalias are retrieved ...                                 :2_2:UnDeeper:
************* > pAKA: entityalias = Nothing                                                                    :2_2:UnDeeper:
slAKA> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
slAKA> MATCH (COK): Other "person"
slAKA> VALUE: ((["person"],0),[])

************ \ slAKA has returned (["person"],0)                                                                :2_2:UnDeeper:
************ / undeepers                                                                                        :2_2:UnDeeper:
************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers                         :2_2:UnDeeper:
************* > sameLine: success!                                                                             :2_2:UnDeeper:
undeepers> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

************ \ undeepers has returned ()                                                                        :2_2:UnDeeper:
pAKA> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
pAKA> MATCH (COK): Other "person"
pAKA> VALUE: (["person"],[])

*********** \ pAKA has returned ["person"]                                                                       :2_2:UnDeeper:
pMultiTermAka> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
pMultiTermAka> MATCH (COK): Other "person"
pMultiTermAka> VALUE: (["person"],[])

********** \ pMultiTermAka has returned ["person"]                                                                :2_2:UnDeeper:
manyIndentation/leaf?> IN: Other "person" UnDeeper Who GoDeeper GoD <…>
manyIndentation/leaf?> MATCH (COK): Other "person"
manyIndentation/leaf?> VALUE: (["person"],[])

********* \ manyIndentation/leaf? has returned ["person"]                                                          :2_2:UnDeeper:
********* / myindented: consuming UnDeeper                                                                         :2_2:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper Who GoDeeper GoDeeper Other "is <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

********* \ myindented: consuming UnDeeper has returned UnDeeper                                                :2_1:Who:
someIndentation> IN: GoDeeper Other "person" UnDeeper Who GoD <…>
someIndentation> MATCH (COK): GoDeeper Other "person" UnDeeper
someIndentation> VALUE: (["person"],[])

******** \ someIndentation has returned ["person"]                                                               :2_1:Who:
pActor [Every,Party,TokAll]> IN: Every GoDeeper Other "person" UnDeeper W <…>
pActor [Every,Party,TokAll]> MATCH (COK): Every GoDeeper Other "person" UnDeeper
pActor [Every,Party,TokAll]> VALUE: ((Every,Leaf (("person" :| [],Nothing) :| [])),[])

******* \ pActor [Every,Party,TokAll] has returned (Every,Leaf (("person" :| [],Nothing) :| []))                  :2_1:Who:
******* / manyIndentation/leaf?                                                                                   :2_1:Who:
******** / preambleBoolStructR [Who,Which,Whose]                                                                 :2_1:Who:
********* / pBSR                                                                                                 :2_2:GoDeeper:
********** / ppp inner                                                                                          :2_2:GoDeeper:
*********** / expression                                                                                       :2_2:GoDeeper:
************ / labelPrefix                                                                                    :2_2:GoDeeper:
labelPrefix> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=5:
labelPrefix> unexpected GoDeeper
labelPrefix> expecting Other text

************ / term p                                                                                         :2_2:GoDeeper:
************* / term p/1a:label directly above                                                               :2_2:GoDeeper:
************** / $*|                                                                                        :2_2:GoDeeper:
*************** / someSL                                                                                   :2_2:GoDeeper:
**************** / pNumAsText                                                                             :2_2:GoDeeper:
pNumAsText> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=5:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=5:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=5:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=5:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

************* / term p/b:label to the left of line below, with EOL                                           :2_2:GoDeeper:
************** / someSL                                                                                     :2_2:GoDeeper:
*************** / pNumAsText                                                                               :2_2:GoDeeper:
pNumAsText> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=5:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=5:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=5:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

************* / term p/notLabelTerm                                                                          :2_2:GoDeeper:
************** / term p/2:someIndentation expr p                                                            :2_2:GoDeeper:
*************** / someIndentation                                                                          :2_2:GoDeeper:
**************** / myindented: consuming GoDeeper                                                         :2_2:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

**************** \ myindented: consuming GoDeeper has returned GoDeeper                                     :2_3:GoDeeper:
**************** / manyIndentation/leaf?                                                                    :2_3:GoDeeper:
***************** / expression                                                                             :2_3:GoDeeper:
****************** / labelPrefix                                                                          :2_3:GoDeeper:
labelPrefix> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=6:
labelPrefix> unexpected GoDeeper
labelPrefix> expecting Other text

****************** / term p                                                                               :2_3:GoDeeper:
******************* / term p/1a:label directly above                                                     :2_3:GoDeeper:
******************** / $*|                                                                              :2_3:GoDeeper:
********************* / someSL                                                                         :2_3:GoDeeper:
********************** / pNumAsText                                                                   :2_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=6:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=6:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=6:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=6:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

******************* / term p/b:label to the left of line below, with EOL                                 :2_3:GoDeeper:
******************** / someSL                                                                           :2_3:GoDeeper:
********************* / pNumAsText                                                                     :2_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=6:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=6:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=6:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

******************* / term p/notLabelTerm                                                                :2_3:GoDeeper:
******************** / term p/2:someIndentation expr p                                                  :2_3:GoDeeper:
********************* / someIndentation                                                                :2_3:GoDeeper:
********************** / myindented: consuming GoDeeper                                               :2_3:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

********************** \ myindented: consuming GoDeeper has returned GoDeeper                          :2_3:Other "is":
********************** / manyIndentation/leaf?                                                         :2_3:Other "is":
*********************** / expression                                                                  :2_3:Other "is":
************************ / labelPrefix                                                               :2_3:Other "is":
labelPrefix> IN: Other "is" GoDeeper Other "immortal" GoD <…>
labelPrefix> MATCH (COK): Other "is"
labelPrefix> VALUE: ("is",[])

************************ \ labelPrefix has returned "is"                                              :2_4:GoDeeper:
************************ / term p                                                                     :2_4:GoDeeper:
************************* / term p/1a:label directly above                                           :2_4:GoDeeper:
************************** / $*|                                                                    :2_4:GoDeeper:
*************************** / someSL                                                               :2_4:GoDeeper:
**************************** / pNumAsText                                                         :2_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=8:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=8:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=8:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=8:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

************************* / term p/b:label to the left of line below, with EOL                       :2_4:GoDeeper:
************************** / someSL                                                                 :2_4:GoDeeper:
*************************** / pNumAsText                                                           :2_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=8:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=8:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=8:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

************************* / term p/notLabelTerm                                                      :2_4:GoDeeper:
************************** / term p/2:someIndentation expr p                                        :2_4:GoDeeper:
*************************** / someIndentation                                                      :2_4:GoDeeper:
**************************** / myindented: consuming GoDeeper                                     :2_4:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

**************************** \ myindented: consuming GoDeeper has returned GoDeeper                :2_4:Other "immo:
**************************** / manyIndentation/leaf?                                               :2_4:Other "immo:
***************************** / expression                                                        :2_4:Other "immo:
****************************** / labelPrefix                                                     :2_4:Other "immo:
labelPrefix> IN: Other "immortal" GoDeeper Typically GoDe <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=10:
labelPrefix> unexpected GoDeeper

****************************** / term p                                                          :2_4:Other "immo:
******************************* / term p/1a:label directly above                                :2_4:Other "immo:
******************************** / $*|                                                         :2_4:Other "immo:
********************************* / someSL                                                    :2_4:Other "immo:
********************************** / pNumAsText                                                :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

********************************* \ someSL has returned (["immortal"],0)                       :2_5:GoDeeper:
********************************* / pNumAsText                                                 :2_5:GoDeeper:
pNumAsText> IN: GoDeeper Typically GoDeeper Other "false <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (CERR): Other "immortal"
$*|> ERROR:
$*|> offset=10:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/1a:label directly above> MATCH (CERR): Other "immortal"
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=10:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

******************************* / term p/b:label to the left of line below, with EOL            :2_4:Other "immo:
******************************** / someSL                                                      :2_4:Other "immo:
********************************* / pNumAsText                                                  :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

******************************** \ someSL has returned (["immortal"],0)                         :2_5:GoDeeper:
******************************** / undeepers                                                    :2_5:GoDeeper:
********************************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers :2_5:GoDeeper:
********************************* > sameLine: success!                                         :2_5:GoDeeper:
undeepers> IN: GoDeeper Typically GoDeeper Other "false <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

******************************** \ undeepers has returned ()                                    :2_5:GoDeeper:
******************************** / matching EOL                                                 :2_5:GoDeeper:
matching EOL> IN: GoDeeper Typically GoDeeper Other "false <…>
matching EOL> MATCH (EERR): <EMPTY>
matching EOL> ERROR:
matching EOL> offset=10:
matching EOL> unexpected GoDeeper
matching EOL> expecting EOL

term p/b:label to the left of line below, with EOL> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/b:label to the left of line below, with EOL> MATCH (CERR): Other "immortal"
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=10:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting EOL

******************************* / term p/notLabelTerm                                           :2_4:Other "immo:
******************************** / term p/2:someIndentation expr p                             :2_4:Other "immo:
********************************* / someIndentation                                           :2_4:Other "immo:
********************************** / myindented: consuming GoDeeper                          :2_4:Other "immo:
myindented: consuming GoDeeper> IN: Other "immortal" GoDeeper Typically GoDe <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=9:
myindented: consuming GoDeeper> unexpected Other "immortal"
myindented: consuming GoDeeper> expecting GoDeeper

someIndentation> IN: Other "immortal" GoDeeper Typically GoDe <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=9:
someIndentation> unexpected Other "immortal"
someIndentation> expecting GoDeeper

term p/2:someIndentation expr p> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/2:someIndentation expr p> MATCH (EERR): <EMPTY>
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=9:
term p/2:someIndentation expr p> unexpected Other "immortal"
term p/2:someIndentation expr p> expecting GoDeeper

******************************** / term p/3:plain p                                            :2_4:Other "immo:
********************************* / pRelPred                                                  :2_4:Other "immo:
********************************** / slRelPred                                               :2_4:Other "immo:
*********************************** / nested simpleHorn                                     :2_4:Other "immo:
************************************ > |^|                                                 :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slMultiTerm                                       :2_4:Other "immo:
************************************** / someSL                                          :2_4:Other "immo:
*************************************** / pNumAsText                                      :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

************************************** \ someSL has returned (["immortal"],0)             :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

************************************* \ slMultiTerm has returned (["immortal"],0)          :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************ \ $*| has returned (["immortal"],0)                    :2_5:GoDeeper:
************************************ / |^| deeps                                            :2_5:GoDeeper:
|^| deeps> IN: GoDeeper Typically GoDeeper Other "false <…>
|^| deeps> MATCH (COK): GoDeeper
|^| deeps> VALUE: (([()],1),[])

************************************ \ |^| deeps has returned ([()],1)                       :2_5:Typically:
nested simpleHorn> IN: Other "immortal" GoDeeper Typically GoDe <…>
nested simpleHorn> MATCH (CERR): Other "immortal" GoDeeper
nested simpleHorn> ERROR:
nested simpleHorn> offset=11:
nested simpleHorn> unexpected Typically
nested simpleHorn> expecting GoDeeper or Means

*********************************** / RPConstraint                                          :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slMultiTerm                                       :2_4:Other "immo:
************************************** / someSL                                          :2_4:Other "immo:
*************************************** / pNumAsText                                      :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

************************************** \ someSL has returned (["immortal"],0)             :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

************************************* \ slMultiTerm has returned (["immortal"],0)          :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************ \ $*| has returned (["immortal"],0)                    :2_5:GoDeeper:
************************************ / |>| calling $>>                                      :2_5:GoDeeper:
************************************* / |>>/recurse                                        :2_5:GoDeeper:
************************************** / |>>/recurse                                       :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                          :2_5:Typically:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=11:
|>>/base> unexpected Typically
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>>/recurse> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/recurse> MATCH (CERR): GoDeeper
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

************************************* / |>>/base                                           :2_5:GoDeeper:
|>>/base> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=10:
|>>/base> unexpected GoDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: GoDeeper Typically GoDeeper Other "false <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=11:
|>| calling $>>> unexpected Typically
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPConstraint> IN: Other "immortal" GoDeeper Typically GoDe <…>
RPConstraint> MATCH (CERR): Other "immortal"
RPConstraint> ERROR:
RPConstraint> offset=11:
RPConstraint> unexpected Typically
RPConstraint> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPBoolStructR                                         :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slMultiTerm                                       :2_4:Other "immo:
************************************** / someSL                                          :2_4:Other "immo:
*************************************** / pNumAsText                                      :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

************************************** \ someSL has returned (["immortal"],0)             :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

************************************* \ slMultiTerm has returned (["immortal"],0)          :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************ \ $*| has returned (["immortal"],0)                    :2_5:GoDeeper:
************************************ / |>| calling $>>                                      :2_5:GoDeeper:
************************************* / |>>/recurse                                        :2_5:GoDeeper:
************************************** / |>>/recurse                                       :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                          :2_5:Typically:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=11:
|>>/base> unexpected Typically
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>>/recurse> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/recurse> MATCH (CERR): GoDeeper
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

************************************* / |>>/base                                           :2_5:GoDeeper:
|>>/base> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=10:
|>>/base> unexpected GoDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: GoDeeper Typically GoDeeper Other "false <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=11:
|>| calling $>>> unexpected Typically
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPBoolStructR> IN: Other "immortal" GoDeeper Typically GoDe <…>
RPBoolStructR> MATCH (CERR): Other "immortal"
RPBoolStructR> ERROR:
RPBoolStructR> offset=11:
RPBoolStructR> unexpected Typically
RPBoolStructR> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPMT                                                  :2_4:Other "immo:
************************************ / $*|                                                 :2_4:Other "immo:
************************************* / slAKA                                             :2_4:Other "immo:
************************************** / $*|                                             :2_4:Other "immo:
*************************************** / slAKA base                                    :2_4:Other "immo:
**************************************** / slMultiTerm                                 :2_4:Other "immo:
***************************************** / someSL                                    :2_4:Other "immo:
****************************************** / pNumAsText                                :2_5:Typically:
pNumAsText> IN: Typically GoDeeper Other "false" UnDeepe <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected Typically
pNumAsText> expecting number

someSL> IN: Other "immortal" GoDeeper Typically GoDe <…>
someSL> MATCH (COK): Other "immortal"
someSL> VALUE: ((["immortal"],0),[])

***************************************** \ someSL has returned (["immortal"],0)       :2_5:GoDeeper:
slMultiTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
slMultiTerm> MATCH (COK): Other "immortal"
slMultiTerm> VALUE: ((["immortal"],0),[])

**************************************** \ slMultiTerm has returned (["immortal"],0)    :2_5:GoDeeper:
slAKA base> IN: Other "immortal" GoDeeper Typically GoDe <…>
slAKA base> MATCH (COK): Other "immortal"
slAKA base> VALUE: ((["immortal"],0),[])

*************************************** \ slAKA base has returned (["immortal"],0)       :2_5:GoDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal"
$*|> VALUE: ((["immortal"],0),[])

************************************** \ $*| has returned (["immortal"],0)                :2_5:GoDeeper:
************************************** / |>>/recurse                                      :2_5:GoDeeper:
*************************************** / |>>/recurse                                     :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

*************************************** / |>>/base                                        :2_5:Typically:
**************************************** / slAKA optional akapart                        :2_5:Typically:
***************************************** / |?| optional something                      :2_5:Typically:
****************************************** / |>>/recurse                               :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

****************************************** / |>>/base                                  :2_5:Typically:
******************************************* / PAKA/akapart                            :2_5:Typically:
******************************************** / $>|                                   :2_5:Typically:
********************************************* / Aka Token                           :2_5:Typically:
Aka Token> IN: Typically GoDeeper Other "false" UnDeepe <…>
Aka Token> MATCH (EERR): <EMPTY>
Aka Token> ERROR:
Aka Token> offset=11:
Aka Token> unexpected Typically
Aka Token> expecting Aka

$>|> IN: Typically GoDeeper Other "false" UnDeepe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=11:
$>|> unexpected Typically
$>|> expecting Aka

PAKA/akapart> IN: Typically GoDeeper Other "false" UnDeepe <…>
PAKA/akapart> MATCH (EERR): <EMPTY>
PAKA/akapart> ERROR:
PAKA/akapart> offset=11:
PAKA/akapart> unexpected Typically
PAKA/akapart> expecting Aka

|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=11:
|>>/base> unexpected Typically
|>>/base> expecting Aka

|?| optional something> IN: Typically GoDeeper Other "false" UnDeepe <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

***************************************** \ |?| optional something has returned (Nothing,0) :2_5:Typically:
slAKA optional akapart> IN: Typically GoDeeper Other "false" UnDeepe <…>
slAKA optional akapart> MATCH (EOK): <EMPTY>
slAKA optional akapart> VALUE: ((Nothing,0),[])

**************************************** \ slAKA optional akapart has returned (Nothing,0) :2_5:Typically:
**************************************** > |>>/base got Nothing                          :2_5:Typically:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

*************************************** \ |>>/base has returned (Nothing,0)               :2_5:Typically:
|>>/recurse> IN: GoDeeper Typically GoDeeper Other "false <…>
|>>/recurse> MATCH (COK): GoDeeper
|>>/recurse> VALUE: ((Nothing,1),[])

************************************** \ |>>/recurse has returned (Nothing,1)              :2_5:Typically:
************************************** / |>>/recurse                                       :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                          :2_5:Typically:
*************************************** / slAKA optional typically                        :2_5:Typically:
**************************************** / |?| optional something                        :2_5:Typically:
***************************************** / |>>/recurse                                 :2_5:Typically:
|>>/recurse> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=11:
|>>/recurse> unexpected Typically
|>>/recurse> expecting GoDeeper

***************************************** / |>>/base                                    :2_5:Typically:
****************************************** / typically                                 :2_5:Typically:
******************************************* / $>|                                     :2_5:Typically:
$>|> IN: Typically GoDeeper Other "false" UnDeepe <…>
$>|> MATCH (COK): Typically
$>|> VALUE: (Typically,[])

******************************************* \ $>| has returned Typically               :2_6:GoDeeper:
******************************************* / |>>/recurse                              :2_6:GoDeeper:
******************************************** / |>>/recurse                             :2_6:Other "fals:
|>>/recurse> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=13:
|>>/recurse> unexpected Other "false"
|>>/recurse> expecting GoDeeper

******************************************** / |>>/base                                :2_6:Other "fals:
********************************************* / slMultiTerm                           :2_6:Other "fals:
********************************************** / someSL                              :2_6:Other "fals:
someSL> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
someSL> MATCH (COK): Other "false"
someSL> VALUE: ((["false"],0),[])

********************************************** \ someSL has returned (["false"],0) :3_3:UnDeeper:
slMultiTerm> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
slMultiTerm> MATCH (COK): Other "false"
slMultiTerm> VALUE: ((["false"],0),[])

********************************************* \ slMultiTerm has returned (["false"],0) :3_3:UnDeeper:
********************************************* > |>>/base got ["false"]           :3_3:UnDeeper:
|>>/base> IN: Other "false" UnDeeper UnDeeper UnDeeper <…>
|>>/base> MATCH (COK): Other "false"
|>>/base> VALUE: ((["false"],0),[])

******************************************** \ |>>/base has returned (["false"],0) :3_3:UnDeeper:
|>>/recurse> IN: GoDeeper Other "false" UnDeeper UnDeeper <…>
|>>/recurse> MATCH (COK): GoDeeper Other "false"
|>>/recurse> VALUE: ((["false"],1),[])

******************************************* \ |>>/recurse has returned (["false"],1) :3_3:UnDeeper:
typically> IN: Typically GoDeeper Other "false" UnDeepe <…>
typically> MATCH (COK): Typically GoDeeper Other "false"
typically> VALUE: ((["false"],1),[])

****************************************** \ typically has returned (["false"],1)   :3_3:UnDeeper:
****************************************** > |>>/base got ["false"]                 :3_3:UnDeeper:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (COK): Typically GoDeeper Other "false"
|>>/base> VALUE: ((["false"],1),[])

***************************************** \ |>>/base has returned (["false"],1)      :3_3:UnDeeper:
|?| optional something> IN: Typically GoDeeper Other "false" UnDeepe <…>
|?| optional something> MATCH (COK): Typically GoDeeper Other "false"
|?| optional something> VALUE: ((Just ["false"],1),[])

**************************************** \ |?| optional something has returned (Just ["false"],1) :3_3:UnDeeper:
slAKA optional typically> IN: Typically GoDeeper Other "false" UnDeepe <…>
slAKA optional typically> MATCH (COK): Typically GoDeeper Other "false"
slAKA optional typically> VALUE: ((Just ["false"],1),[])

*************************************** \ slAKA optional typically has returned (Just ["false"],1) :3_3:UnDeeper:
*************************************** > |>>/base got Just ["false"]                  :3_3:UnDeeper:
|>>/base> IN: Typically GoDeeper Other "false" UnDeepe <…>
|>>/base> MATCH (COK): Typically GoDeeper Other "false"
|>>/base> VALUE: ((Just ["false"],1),[])

************************************** \ |>>/base has returned (Just ["false"],1)       :3_3:UnDeeper:
************************************** > slAKA: proceeding after base and entityalias are retrieved ... :3_3:UnDeeper:
************************************** > pAKA: entityalias = Nothing                    :3_3:UnDeeper:
slAKA> IN: Other "immortal" GoDeeper Typically GoDe <…>
slAKA> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
slAKA> VALUE: ((["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************************* \ slAKA has returned (["immortal"],2)              :3_3:UnDeeper:
$*|> IN: Other "immortal" GoDeeper Typically GoDe <…>
$*|> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
$*|> VALUE: ((["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************************ \ $*| has returned (["immortal"],2)                  :3_3:UnDeeper:
RPMT> IN: Other "immortal" GoDeeper Typically GoDe <…>
RPMT> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
RPMT> VALUE: ((RPMT ["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*********************************** \ RPMT has returned (RPMT ["immortal"],2)              :3_3:UnDeeper:
slRelPred> IN: Other "immortal" GoDeeper Typically GoDe <…>
slRelPred> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
slRelPred> VALUE: ((RPMT ["immortal"],2),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************************** \ slRelPred has returned (RPMT ["immortal"],2)           :3_3:UnDeeper:
********************************** / undeepers                                              :3_3:UnDeeper:
*********************************** > sameLine/undeepers: reached end of line; now need to clear 2 UnDeepers :3_3:UnDeeper:
*********************************** > sameLine: success!                                       :3_5:UnDeeper:
undeepers> IN: UnDeeper UnDeeper UnDeeper UnDeeper Or G <…>
undeepers> MATCH (COK): UnDeeper UnDeeper
undeepers> VALUE: ((),[])

********************************** \ undeepers has returned ()                                  :3_5:UnDeeper:
pRelPred> IN: Other "immortal" GoDeeper Typically GoDe <…>
pRelPred> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
pRelPred> VALUE: (RPMT ["immortal"],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************************* \ pRelPred has returned RPMT ["immortal"]                      :3_5:UnDeeper:
term p/3:plain p> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/3:plain p> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
term p/3:plain p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************************** \ term p/3:plain p has returned MyLeaf (RPMT ["immortal"])       :3_5:UnDeeper:
term p/notLabelTerm> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p/notLabelTerm> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["immortal"])      :3_5:UnDeeper:
term p> IN: Other "immortal" GoDeeper Typically GoDe <…>
term p> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
term p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

****************************** \ term p has returned MyLeaf (RPMT ["immortal"])                     :3_5:UnDeeper:
****************************** / binary(Or)                                                         :3_5:UnDeeper:
binary(Or)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=16:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

****************************** / binary(And)                                                        :3_5:UnDeeper:
binary(And)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=16:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

****************************** / binary(SetLess)                                                    :3_5:UnDeeper:
binary(SetLess)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=16:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

****************************** / binary(SetPlus)                                                    :3_5:UnDeeper:
binary(SetPlus)> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=16:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "immortal" GoDeeper Typically GoDe <…>
expression> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
expression> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

***************************** \ expression has returned MyLeaf (RPMT ["immortal"])                   :3_5:UnDeeper:
manyIndentation/leaf?> IN: Other "immortal" GoDeeper Typically GoDe <…>
manyIndentation/leaf?> MATCH (COK): Other "immortal" GoDeeper Typically GoDe <…>
manyIndentation/leaf?> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

**************************** \ manyIndentation/leaf? has returned MyLeaf (RPMT ["immortal"])          :3_5:UnDeeper:
**************************** / myindented: consuming UnDeeper                                         :3_5:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper UnDeeper Or GoDeeper Other "has <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

**************************** \ myindented: consuming UnDeeper has returned UnDeeper                     :3_6:UnDeeper:
someIndentation> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
someIndentation> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
someIndentation> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*************************** \ someIndentation has returned MyLeaf (RPMT ["immortal"])                    :3_6:UnDeeper:
term p/2:someIndentation expr p> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
term p/2:someIndentation expr p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************** \ term p/2:someIndentation expr p has returned MyLeaf (RPMT ["immortal"])      :3_6:UnDeeper:
term p/notLabelTerm> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["immortal"])                    :3_6:UnDeeper:
term p> IN: GoDeeper Other "immortal" GoDeeper Typic <…>
term p> MATCH (COK): GoDeeper Other "immortal" GoDeeper Typic <…>
term p> VALUE: (MyLeaf (RPMT ["immortal"]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************************ \ term p has returned MyLeaf (RPMT ["immortal"])                                   :3_6:UnDeeper:
************************ / binary(Or)                                                                       :3_6:UnDeeper:
binary(Or)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=17:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

************************ / binary(And)                                                                      :3_6:UnDeeper:
binary(And)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=17:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

************************ / binary(SetLess)                                                                  :3_6:UnDeeper:
binary(SetLess)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=17:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

************************ / binary(SetPlus)                                                                  :3_6:UnDeeper:
binary(SetPlus)> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=17:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "is" GoDeeper Other "immortal" GoD <…>
expression> MATCH (COK): Other "is" GoDeeper Other "immortal" GoD <…>
expression> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*********************** \ expression has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))                :3_6:UnDeeper:
manyIndentation/leaf?> IN: Other "is" GoDeeper Other "immortal" GoD <…>
manyIndentation/leaf?> MATCH (COK): Other "is" GoDeeper Other "immortal" GoD <…>
manyIndentation/leaf?> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************** \ manyIndentation/leaf? has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))       :3_6:UnDeeper:
********************** / myindented: consuming UnDeeper                                                       :3_6:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper Or GoDeeper Other "has" GoDeepe <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

********************** \ myindented: consuming UnDeeper has returned UnDeeper                        :3_2:Or:
someIndentation> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
someIndentation> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
someIndentation> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********************* \ someIndentation has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))      :3_2:Or:
term p/2:someIndentation expr p> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
term p/2:someIndentation expr p> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************** \ term p/2:someIndentation expr p has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"])) :3_2:Or:
term p/notLabelTerm> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
term p/notLabelTerm> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******************* \ term p/notLabelTerm has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))      :3_2:Or:
term p> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
term p> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
term p> VALUE: (MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

****************** \ term p has returned MyLabel ["is"] (MyLeaf (RPMT ["immortal"]))                     :3_2:Or:
****************** / binary(Or)                                                                          :3_2:Or:
binary(Or)> IN: Or GoDeeper Other "has" GoDeeper Other " <…>
binary(Or)> MATCH (COK): Or
binary(Or)> VALUE: (Or,[])

****************** \ binary(Or) has returned Or                                                           :3_3:GoDeeper:
****************** / term p                                                                               :3_3:GoDeeper:
******************* / term p/1a:label directly above                                                     :3_3:GoDeeper:
******************** / $*|                                                                              :3_3:GoDeeper:
********************* / someSL                                                                         :3_3:GoDeeper:
********************** / pNumAsText                                                                   :3_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=19:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=19:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=19:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=19:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

******************* / term p/b:label to the left of line below, with EOL                                 :3_3:GoDeeper:
******************** / someSL                                                                           :3_3:GoDeeper:
********************* / pNumAsText                                                                     :3_3:GoDeeper:
pNumAsText> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=19:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=19:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=19:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

******************* / term p/notLabelTerm                                                                :3_3:GoDeeper:
******************** / term p/2:someIndentation expr p                                                  :3_3:GoDeeper:
********************* / someIndentation                                                                :3_3:GoDeeper:
********************** / myindented: consuming GoDeeper                                               :3_3:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

********************** \ myindented: consuming GoDeeper has returned GoDeeper                          :3_3:Other "has":
********************** / manyIndentation/leaf?                                                         :3_3:Other "has":
*********************** / expression                                                                  :3_3:Other "has":
************************ / labelPrefix                                                               :3_3:Other "has":
labelPrefix> IN: Other "has" GoDeeper Other "health insur <…>
labelPrefix> MATCH (COK): Other "has"
labelPrefix> VALUE: ("has",[])

************************ \ labelPrefix has returned "has"                                             :3_4:GoDeeper:
************************ / term p                                                                     :3_4:GoDeeper:
************************* / term p/1a:label directly above                                           :3_4:GoDeeper:
************************** / $*|                                                                    :3_4:GoDeeper:
*************************** / someSL                                                               :3_4:GoDeeper:
**************************** / pNumAsText                                                         :3_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "health insurance" UnDeep <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=21:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "health insurance" UnDeep <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=21:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "health insurance" UnDeep <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=21:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=21:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

************************* / term p/b:label to the left of line below, with EOL                       :3_4:GoDeeper:
************************** / someSL                                                                 :3_4:GoDeeper:
*************************** / pNumAsText                                                           :3_4:GoDeeper:
pNumAsText> IN: GoDeeper Other "health insurance" UnDeep <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=21:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "health insurance" UnDeep <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=21:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=21:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

************************* / term p/notLabelTerm                                                      :3_4:GoDeeper:
************************** / term p/2:someIndentation expr p                                        :3_4:GoDeeper:
*************************** / someIndentation                                                      :3_4:GoDeeper:
**************************** / myindented: consuming GoDeeper                                     :3_4:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "health insurance" UnDeep <…>
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

**************************** \ myindented: consuming GoDeeper has returned GoDeeper                :3_4:Other "heal:
**************************** / manyIndentation/leaf?                                               :3_4:Other "heal:
***************************** / expression                                                        :3_4:Other "heal:
****************************** / labelPrefix                                                     :3_4:Other "heal:
labelPrefix> IN: Other "health insurance" UnDeeper UnDeep <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=23:
labelPrefix> unexpected UnDeeper

****************************** / term p                                                          :3_4:Other "heal:
******************************* / term p/1a:label directly above                                :3_4:Other "heal:
******************************** / $*|                                                         :3_4:Other "heal:
********************************* / someSL                                                    :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

********************************* \ someSL has returned (["health insurance"],0)           :4_2:UnDeeper:
********************************* / pNumAsText                                             :4_2:UnDeeper:
pNumAsText> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=23:
pNumAsText> unexpected UnDeeper
pNumAsText> expecting number

$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (CERR): Other "health insurance"
$*|> ERROR:
$*|> offset=23:
$*|> unexpected UnDeeper
$*|> expecting GoDeeper or other text or number

term p/1a:label directly above> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/1a:label directly above> MATCH (CERR): Other "health insurance"
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=23:
term p/1a:label directly above> unexpected UnDeeper
term p/1a:label directly above> expecting GoDeeper or other text or number

******************************* / term p/b:label to the left of line below, with EOL            :3_4:Other "heal:
******************************** / someSL                                                      :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

******************************** \ someSL has returned (["health insurance"],0)             :4_2:UnDeeper:
******************************** / undeepers                                                :4_2:UnDeeper:
********************************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers :4_2:UnDeeper:
********************************* > sameLine: success!                                     :4_2:UnDeeper:
undeepers> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

******************************** \ undeepers has returned ()                                :4_2:UnDeeper:
******************************** / matching EOL                                             :4_2:UnDeeper:
matching EOL> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
matching EOL> MATCH (EERR): <EMPTY>
matching EOL> ERROR:
matching EOL> offset=23:
matching EOL> unexpected UnDeeper
matching EOL> expecting EOL

term p/b:label to the left of line below, with EOL> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/b:label to the left of line below, with EOL> MATCH (CERR): Other "health insurance"
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=23:
term p/b:label to the left of line below, with EOL> unexpected UnDeeper
term p/b:label to the left of line below, with EOL> expecting EOL or GoDeeper

******************************* / term p/notLabelTerm                                           :3_4:Other "heal:
******************************** / term p/2:someIndentation expr p                             :3_4:Other "heal:
********************************* / someIndentation                                           :3_4:Other "heal:
********************************** / myindented: consuming GoDeeper                          :3_4:Other "heal:
myindented: consuming GoDeeper> IN: Other "health insurance" UnDeeper UnDeep <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=22:
myindented: consuming GoDeeper> unexpected Other "health insurance"
myindented: consuming GoDeeper> expecting GoDeeper

someIndentation> IN: Other "health insurance" UnDeeper UnDeep <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=22:
someIndentation> unexpected Other "health insurance"
someIndentation> expecting GoDeeper

term p/2:someIndentation expr p> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/2:someIndentation expr p> MATCH (EERR): <EMPTY>
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=22:
term p/2:someIndentation expr p> unexpected Other "health insurance"
term p/2:someIndentation expr p> expecting GoDeeper

******************************** / term p/3:plain p                                            :3_4:Other "heal:
********************************* / pRelPred                                                  :3_4:Other "heal:
********************************** / slRelPred                                               :3_4:Other "heal:
*********************************** / nested simpleHorn                                     :3_4:Other "heal:
************************************ > |^|                                                 :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slMultiTerm                                       :3_4:Other "heal:
************************************** / someSL                                          :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

************************************* \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
************************************ / |^| deeps                                        :4_2:UnDeeper:
|^| deeps> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|^| deeps> MATCH (COK): UnDeeper UnDeeper UnDeeper
|^| deeps> VALUE: (([(),(),()],-3),[])

************************************ \ |^| deeps has returned ([(),(),()],-3)        :4_1:May:
nested simpleHorn> IN: Other "health insurance" UnDeeper UnDeep <…>
nested simpleHorn> MATCH (CERR): Other "health insurance" UnDeeper UnDeep <…>
nested simpleHorn> ERROR:
nested simpleHorn> offset=26:
nested simpleHorn> unexpected May
nested simpleHorn> expecting Means or UnDeeper

*********************************** / RPConstraint                                          :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slMultiTerm                                       :3_4:Other "heal:
************************************** / someSL                                          :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

************************************* \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
************************************ / |>| calling $>>                                  :4_2:UnDeeper:
************************************* / |>>/recurse                                    :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************* / |>>/base                                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=23:
|>| calling $>>> unexpected UnDeeper
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPConstraint> IN: Other "health insurance" UnDeeper UnDeep <…>
RPConstraint> MATCH (CERR): Other "health insurance"
RPConstraint> ERROR:
RPConstraint> offset=23:
RPConstraint> unexpected UnDeeper
RPConstraint> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPBoolStructR                                         :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slMultiTerm                                       :3_4:Other "heal:
************************************** / someSL                                          :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

************************************* \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
************************************ / |>| calling $>>                                  :4_2:UnDeeper:
************************************* / |>>/recurse                                    :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************* / |>>/base                                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

|>| calling $>>> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>| calling $>>> MATCH (EERR): <EMPTY>
|>| calling $>>> ERROR:
|>| calling $>>> offset=23:
|>| calling $>>> unexpected UnDeeper
|>| calling $>>> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

RPBoolStructR> IN: Other "health insurance" UnDeeper UnDeep <…>
RPBoolStructR> MATCH (CERR): Other "health insurance"
RPBoolStructR> ERROR:
RPBoolStructR> offset=23:
RPBoolStructR> unexpected UnDeeper
RPBoolStructR> expecting GoDeeper, Is, TokEQ, TokGT, TokGTE, TokIn, TokLT, TokLTE, or TokNotIn

*********************************** / RPMT                                                  :3_4:Other "heal:
************************************ / $*|                                                 :3_4:Other "heal:
************************************* / slAKA                                             :3_4:Other "heal:
************************************** / $*|                                             :3_4:Other "heal:
*************************************** / slAKA base                                    :3_4:Other "heal:
**************************************** / slMultiTerm                                 :3_4:Other "heal:
***************************************** / someSL                                    :3_4:Other "heal:
someSL> IN: Other "health insurance" UnDeeper UnDeep <…>
someSL> MATCH (COK): Other "health insurance"
someSL> VALUE: ((["health insurance"],0),[])

***************************************** \ someSL has returned (["health insurance"],0) :4_2:UnDeeper:
slMultiTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
slMultiTerm> MATCH (COK): Other "health insurance"
slMultiTerm> VALUE: ((["health insurance"],0),[])

**************************************** \ slMultiTerm has returned (["health insurance"],0) :4_2:UnDeeper:
slAKA base> IN: Other "health insurance" UnDeeper UnDeep <…>
slAKA base> MATCH (COK): Other "health insurance"
slAKA base> VALUE: ((["health insurance"],0),[])

*************************************** \ slAKA base has returned (["health insurance"],0) :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************** \ $*| has returned (["health insurance"],0)    :4_2:UnDeeper:
************************************** / |>>/recurse                                  :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                     :4_2:UnDeeper:
*************************************** / slAKA optional akapart                     :4_2:UnDeeper:
**************************************** / |?| optional something                   :4_2:UnDeeper:
***************************************** / |>>/recurse                            :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

***************************************** / |>>/base                               :4_2:UnDeeper:
****************************************** / PAKA/akapart                         :4_2:UnDeeper:
******************************************* / $>|                                :4_2:UnDeeper:
******************************************** / Aka Token                        :4_2:UnDeeper:
Aka Token> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
Aka Token> MATCH (EERR): <EMPTY>
Aka Token> ERROR:
Aka Token> offset=23:
Aka Token> unexpected UnDeeper
Aka Token> expecting Aka

$>|> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=23:
$>|> unexpected UnDeeper
$>|> expecting Aka

PAKA/akapart> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
PAKA/akapart> MATCH (EERR): <EMPTY>
PAKA/akapart> ERROR:
PAKA/akapart> offset=23:
PAKA/akapart> unexpected UnDeeper
PAKA/akapart> expecting Aka

|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Aka

|?| optional something> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

**************************************** \ |?| optional something has returned (Nothing,0) :4_2:UnDeeper:
slAKA optional akapart> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
slAKA optional akapart> MATCH (EOK): <EMPTY>
slAKA optional akapart> VALUE: ((Nothing,0),[])

*************************************** \ slAKA optional akapart has returned (Nothing,0) :4_2:UnDeeper:
*************************************** > |>>/base got Nothing                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************************************** \ |>>/base has returned (Nothing,0)            :4_2:UnDeeper:
************************************** / |>>/recurse                                  :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************************** / |>>/base                                     :4_2:UnDeeper:
*************************************** / slAKA optional typically                   :4_2:UnDeeper:
**************************************** / |?| optional something                   :4_2:UnDeeper:
***************************************** / |>>/recurse                            :4_2:UnDeeper:
|>>/recurse> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=23:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

***************************************** / |>>/base                               :4_2:UnDeeper:
****************************************** / typically                            :4_2:UnDeeper:
******************************************* / $>|                                :4_2:UnDeeper:
$>|> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=23:
$>|> unexpected UnDeeper
$>|> expecting Typically

typically> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
typically> MATCH (EERR): <EMPTY>
typically> ERROR:
typically> offset=23:
typically> unexpected UnDeeper
typically> expecting Typically

|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=23:
|>>/base> unexpected UnDeeper
|>>/base> expecting Typically

|?| optional something> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

**************************************** \ |?| optional something has returned (Nothing,0) :4_2:UnDeeper:
slAKA optional typically> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
slAKA optional typically> MATCH (EOK): <EMPTY>
slAKA optional typically> VALUE: ((Nothing,0),[])

*************************************** \ slAKA optional typically has returned (Nothing,0) :4_2:UnDeeper:
*************************************** > |>>/base got Nothing                       :4_2:UnDeeper:
|>>/base> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************************************** \ |>>/base has returned (Nothing,0)            :4_2:UnDeeper:
************************************** > slAKA: proceeding after base and entityalias are retrieved ... :4_2:UnDeeper:
************************************** > pAKA: entityalias = Nothing                  :4_2:UnDeeper:
slAKA> IN: Other "health insurance" UnDeeper UnDeep <…>
slAKA> MATCH (COK): Other "health insurance"
slAKA> VALUE: ((["health insurance"],0),[])

************************************* \ slAKA has returned (["health insurance"],0)    :4_2:UnDeeper:
$*|> IN: Other "health insurance" UnDeeper UnDeep <…>
$*|> MATCH (COK): Other "health insurance"
$*|> VALUE: ((["health insurance"],0),[])

************************************ \ $*| has returned (["health insurance"],0)        :4_2:UnDeeper:
RPMT> IN: Other "health insurance" UnDeeper UnDeep <…>
RPMT> MATCH (COK): Other "health insurance"
RPMT> VALUE: ((RPMT ["health insurance"],0),[])

*********************************** \ RPMT has returned (RPMT ["health insurance"],0)    :4_2:UnDeeper:
slRelPred> IN: Other "health insurance" UnDeeper UnDeep <…>
slRelPred> MATCH (COK): Other "health insurance"
slRelPred> VALUE: ((RPMT ["health insurance"],0),[])

********************************** \ slRelPred has returned (RPMT ["health insurance"],0) :4_2:UnDeeper:
********************************** / undeepers                                            :4_2:UnDeeper:
*********************************** > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers :4_2:UnDeeper:
*********************************** > sameLine: success!                                 :4_2:UnDeeper:
undeepers> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

********************************** \ undeepers has returned ()                            :4_2:UnDeeper:
pRelPred> IN: Other "health insurance" UnDeeper UnDeep <…>
pRelPred> MATCH (COK): Other "health insurance"
pRelPred> VALUE: (RPMT ["health insurance"],[])

********************************* \ pRelPred has returned RPMT ["health insurance"]        :4_2:UnDeeper:
term p/3:plain p> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/3:plain p> MATCH (COK): Other "health insurance"
term p/3:plain p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

******************************** \ term p/3:plain p has returned MyLeaf (RPMT ["health insurance"]) :4_2:UnDeeper:
term p/notLabelTerm> IN: Other "health insurance" UnDeeper UnDeep <…>
term p/notLabelTerm> MATCH (COK): Other "health insurance"
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

******************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["health insurance"]) :4_2:UnDeeper:
term p> IN: Other "health insurance" UnDeeper UnDeep <…>
term p> MATCH (COK): Other "health insurance"
term p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

****************************** \ term p has returned MyLeaf (RPMT ["health insurance"])       :4_2:UnDeeper:
****************************** / binary(Or)                                                   :4_2:UnDeeper:
binary(Or)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=23:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

****************************** / binary(And)                                                  :4_2:UnDeeper:
binary(And)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=23:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

****************************** / binary(SetLess)                                              :4_2:UnDeeper:
binary(SetLess)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=23:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

****************************** / binary(SetPlus)                                              :4_2:UnDeeper:
binary(SetPlus)> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=23:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "health insurance" UnDeeper UnDeep <…>
expression> MATCH (COK): Other "health insurance"
expression> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

***************************** \ expression has returned MyLeaf (RPMT ["health insurance"])     :4_2:UnDeeper:
manyIndentation/leaf?> IN: Other "health insurance" UnDeeper UnDeep <…>
manyIndentation/leaf?> MATCH (COK): Other "health insurance"
manyIndentation/leaf?> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

**************************** \ manyIndentation/leaf? has returned MyLeaf (RPMT ["health insurance"]) :4_2:UnDeeper:
**************************** / myindented: consuming UnDeeper                                   :4_2:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper UnDeeper UnDeeper May GoDeeper  <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

**************************** \ myindented: consuming UnDeeper has returned UnDeeper               :4_3:UnDeeper:
someIndentation> IN: GoDeeper Other "health insurance" UnDeep <…>
someIndentation> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
someIndentation> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

*************************** \ someIndentation has returned MyLeaf (RPMT ["health insurance"])      :4_3:UnDeeper:
term p/2:someIndentation expr p> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
term p/2:someIndentation expr p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

************************** \ term p/2:someIndentation expr p has returned MyLeaf (RPMT ["health insurance"]) :4_3:UnDeeper:
term p/notLabelTerm> IN: GoDeeper Other "health insurance" UnDeep <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
term p/notLabelTerm> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

************************* \ term p/notLabelTerm has returned MyLeaf (RPMT ["health insurance"])      :4_3:UnDeeper:
term p> IN: GoDeeper Other "health insurance" UnDeep <…>
term p> MATCH (COK): GoDeeper Other "health insurance" UnDeep <…>
term p> VALUE: (MyLeaf (RPMT ["health insurance"]),[])

************************ \ term p has returned MyLeaf (RPMT ["health insurance"])                     :4_3:UnDeeper:
************************ / binary(Or)                                                                 :4_3:UnDeeper:
binary(Or)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=24:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

************************ / binary(And)                                                                :4_3:UnDeeper:
binary(And)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=24:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

************************ / binary(SetLess)                                                            :4_3:UnDeeper:
binary(SetLess)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=24:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

************************ / binary(SetPlus)                                                            :4_3:UnDeeper:
binary(SetPlus)> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=24:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "has" GoDeeper Other "health insur <…>
expression> MATCH (COK): Other "has" GoDeeper Other "health insur <…>
expression> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

*********************** \ expression has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])) :4_3:UnDeeper:
manyIndentation/leaf?> IN: Other "has" GoDeeper Other "health insur <…>
manyIndentation/leaf?> MATCH (COK): Other "has" GoDeeper Other "health insur <…>
manyIndentation/leaf?> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

********************** \ manyIndentation/leaf? has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])) :4_3:UnDeeper:
********************** / myindented: consuming UnDeeper                                                 :4_3:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper UnDeeper May GoDeeper Other "sh <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

********************** \ myindented: consuming UnDeeper has returned UnDeeper                             :4_4:UnDeeper:
someIndentation> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
someIndentation> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
someIndentation> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

********************* \ someIndentation has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))  :4_4:UnDeeper:
term p/2:someIndentation expr p> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
term p/2:someIndentation expr p> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

******************** \ term p/2:someIndentation expr p has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])) :4_4:UnDeeper:
term p/notLabelTerm> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p/notLabelTerm> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
term p/notLabelTerm> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

******************* \ term p/notLabelTerm has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))  :4_4:UnDeeper:
term p> IN: GoDeeper Other "has" GoDeeper Other "hea <…>
term p> MATCH (COK): GoDeeper Other "has" GoDeeper Other "hea <…>
term p> VALUE: (MyLabel ["has"] (MyLeaf (RPMT ["health insurance"])),[])

****************** \ term p has returned MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))                 :4_4:UnDeeper:
****************** / binary(Or)                                                                               :4_4:UnDeeper:
binary(Or)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=25:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

****************** / binary(And)                                                                              :4_4:UnDeeper:
binary(And)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=25:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

****************** / binary(SetLess)                                                                          :4_4:UnDeeper:
binary(SetLess)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=25:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

****************** / binary(SetPlus)                                                                          :4_4:UnDeeper:
binary(SetPlus)> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=25:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
expression> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
expression> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

***************** \ expression has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_4:UnDeeper:
manyIndentation/leaf?> IN: GoDeeper Other "is" GoDeeper Other "immo <…>
manyIndentation/leaf?> MATCH (COK): GoDeeper Other "is" GoDeeper Other "immo <…>
manyIndentation/leaf?> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

**************** \ manyIndentation/leaf? has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_4:UnDeeper:
**************** / myindented: consuming UnDeeper                                                               :4_4:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper May GoDeeper Other "sharpen kni <…>
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

**************** \ myindented: consuming UnDeeper has returned UnDeeper                                  :4_1:May:
someIndentation> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someIndentation> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
someIndentation> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*************** \ someIndentation has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
term p/2:someIndentation expr p> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/2:someIndentation expr p> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/2:someIndentation expr p> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************** \ term p/2:someIndentation expr p has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
term p/notLabelTerm> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/notLabelTerm> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p/notLabelTerm> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************* \ term p/notLabelTerm has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
term p> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
term p> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

************ \ term p has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
************ / binary(Or)                                                                                    :4_1:May:
binary(Or)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=26:
binary(Or)> unexpected May
binary(Or)> expecting Or

************ / binary(And)                                                                                   :4_1:May:
binary(And)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=26:
binary(And)> unexpected May
binary(And)> expecting And

************ / binary(SetLess)                                                                               :4_1:May:
binary(SetLess)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=26:
binary(SetLess)> unexpected May
binary(SetLess)> expecting SetLess

************ / binary(SetPlus)                                                                               :4_1:May:
binary(SetPlus)> IN: May GoDeeper Other "sharpen knives" UnDe <…>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=26:
binary(SetPlus)> unexpected May
binary(SetPlus)> expecting SetPlus

expression> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
expression> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
expression> VALUE: (MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*********** \ expression has returned MyAny [MyLabel ["is"] (MyLeaf (RPMT ["immortal"])),MyLabel ["has"] (MyLeaf (RPMT ["health insurance"]))] :4_1:May:
ppp inner> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
ppp inner> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
ppp inner> VALUE: (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********** \ ppp inner has returned Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])] :4_1:May:
pBSR> IN: GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pBSR> MATCH (COK): GoDeeper GoDeeper Other "is" GoDeeper Ot <…>
pBSR> VALUE: (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])],[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

********* \ pBSR has returned Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])] :4_1:May:
preambleBoolStructR [Who,Which,Whose]> IN: Who GoDeeper GoDeeper Other "is" GoDeepe <…>
preambleBoolStructR [Who,Which,Whose]> MATCH (COK): Who GoDeeper GoDeeper Other "is" GoDeepe <…>
preambleBoolStructR [Who,Which,Whose]> VALUE: ((Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******** \ preambleBoolStructR [Who,Which,Whose] has returned (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]) :4_1:May:
manyIndentation/leaf?> IN: Who GoDeeper GoDeeper Other "is" GoDeepe <…>
manyIndentation/leaf?> MATCH (COK): Who GoDeeper GoDeeper Other "is" GoDeepe <…>
manyIndentation/leaf?> VALUE: ((Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]),[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

******* \ manyIndentation/leaf? has returned (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]) :4_1:May:
******* / WHERE                                                                                                   :4_1:May:
WHERE> IN: May GoDeeper Other "sharpen knives" UnDe <…>
WHERE> MATCH (EERR): <EMPTY>
WHERE> ERROR:
WHERE> offset=26:
WHERE> unexpected May
WHERE> expecting Where

******* / preambleParamText:[Having]                                                                              :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=26:
$>|> unexpected May
$>|> expecting Having

preambleParamText:[Having]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleParamText:[Having]> MATCH (EERR): <EMPTY>
preambleParamText:[Having]> ERROR:
preambleParamText:[Having]> offset=26:
preambleParamText:[Having]> unexpected May
preambleParamText:[Having]> expecting Having

******* / preambleParamText:[Given]                                                                               :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=26:
$>|> unexpected May
$>|> expecting Given

preambleParamText:[Given]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=26:
preambleParamText:[Given]> unexpected May
preambleParamText:[Given]> expecting Given

******* / preambleParamText:[Upon]                                                                                :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=26:
$>|> unexpected May
$>|> expecting Upon

preambleParamText:[Upon]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=26:
preambleParamText:[Upon]> unexpected May
preambleParamText:[Upon]> expecting Upon

******* / preambleBoolStructR [Unless]                                                                            :4_1:May:
preambleBoolStructR [Unless]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleBoolStructR [Unless]> MATCH (EERR): <EMPTY>
preambleBoolStructR [Unless]> ERROR:
preambleBoolStructR [Unless]> offset=26:
preambleBoolStructR [Unless]> unexpected May
preambleBoolStructR [Unless]> expecting Unless

******* / preambleBoolStructR [When,If]                                                                           :4_1:May:
preambleBoolStructR [When,If]> IN: May GoDeeper Other "sharpen knives" UnDe <…>
preambleBoolStructR [When,If]> MATCH (EERR): <EMPTY>
preambleBoolStructR [When,If]> ERROR:
preambleBoolStructR [When,If]> offset=26:
preambleBoolStructR [When,If]> unexpected May
preambleBoolStructR [When,If]> expecting If or When

******* / pTemporal/eventually                                                                                    :4_1:May:
pTemporal/eventually> IN: May GoDeeper Other "sharpen knives" UnDe <…>
pTemporal/eventually> MATCH (EERR): <EMPTY>
pTemporal/eventually> ERROR:
pTemporal/eventually> offset=26:
pTemporal/eventually> unexpected May
pTemporal/eventually> expecting Eventually

******* / pTemporal/specifically                                                                                  :4_1:May:
******** / $>|                                                                                                   :4_1:May:
$>|> IN: May GoDeeper Other "sharpen knives" UnDe <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=26:
$>|> unexpected May
$>|> expecting After, Before, By, or On

pTemporal/specifically> IN: May GoDeeper Other "sharpen knives" UnDe <…>
pTemporal/specifically> MATCH (EERR): <EMPTY>
pTemporal/specifically> ERROR:
pTemporal/specifically> offset=26:
pTemporal/specifically> unexpected May
pTemporal/specifically> expecting After, Before, By, or On

******* / pTemporal/vaguely                                                                                       :4_1:May:
pTemporal/vaguely> IN: May GoDeeper Other "sharpen knives" UnDe <…>
pTemporal/vaguely> MATCH (EERR): <EMPTY>
pTemporal/vaguely> ERROR:
pTemporal/vaguely> offset=26:
pTemporal/vaguely> unexpected May
pTemporal/vaguely> expecting Other text

******* / pDA                                                                                                     :4_1:May:
******** / pAction calling dBoolStructP                                                                           :4_2:GoDeeper:
********* / dBoolStructP calling exprP                                                                           :4_2:GoDeeper:
********** / expr pParamText                                                                                    :4_2:GoDeeper:
*********** / expression                                                                                       :4_2:GoDeeper:
************ / labelPrefix                                                                                    :4_2:GoDeeper:
labelPrefix> IN: GoDeeper Other "sharpen knives" UnDeeper
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=27:
labelPrefix> unexpected GoDeeper
labelPrefix> expecting Other text

************ / term p                                                                                         :4_2:GoDeeper:
************* / term p/1a:label directly above                                                               :4_2:GoDeeper:
************** / $*|                                                                                        :4_2:GoDeeper:
*************** / someSL                                                                                   :4_2:GoDeeper:
**************** / pNumAsText                                                                             :4_2:GoDeeper:
pNumAsText> IN: GoDeeper Other "sharpen knives" UnDeeper
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=27:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "sharpen knives" UnDeeper
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=27:
someSL> unexpected GoDeeper
someSL> expecting other text or number

$*|> IN: GoDeeper Other "sharpen knives" UnDeeper
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=27:
$*|> unexpected GoDeeper
$*|> expecting other text or number

term p/1a:label directly above> IN: GoDeeper Other "sharpen knives" UnDeeper
term p/1a:label directly above> MATCH (EERR): <EMPTY>
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=27:
term p/1a:label directly above> unexpected GoDeeper
term p/1a:label directly above> expecting other text or number

************* / term p/b:label to the left of line below, with EOL                                           :4_2:GoDeeper:
************** / someSL                                                                                     :4_2:GoDeeper:
*************** / pNumAsText                                                                               :4_2:GoDeeper:
pNumAsText> IN: GoDeeper Other "sharpen knives" UnDeeper
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=27:
pNumAsText> unexpected GoDeeper
pNumAsText> expecting number

someSL> IN: GoDeeper Other "sharpen knives" UnDeeper
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=27:
someSL> unexpected GoDeeper
someSL> expecting other text or number

term p/b:label to the left of line below, with EOL> IN: GoDeeper Other "sharpen knives" UnDeeper
term p/b:label to the left of line below, with EOL> MATCH (EERR): <EMPTY>
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=27:
term p/b:label to the left of line below, with EOL> unexpected GoDeeper
term p/b:label to the left of line below, with EOL> expecting other text or number

************* / term p/notLabelTerm                                                                          :4_2:GoDeeper:
************** / term p/2:someIndentation expr p                                                            :4_2:GoDeeper:
*************** / someIndentation                                                                          :4_2:GoDeeper:
**************** / myindented: consuming GoDeeper                                                         :4_2:GoDeeper:
myindented: consuming GoDeeper> IN: GoDeeper Other "sharpen knives" UnDeeper
myindented: consuming GoDeeper> MATCH (COK): GoDeeper
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

**************** \ myindented: consuming GoDeeper has returned GoDeeper                                    :4_2:Other "shar:
**************** / manyIndentation/leaf?                                                                   :4_2:Other "shar:
***************** / expression                                                                            :4_2:Other "shar:
****************** / labelPrefix                                                                         :4_2:Other "shar:
labelPrefix> IN: Other "sharpen knives" UnDeeper
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=29:
labelPrefix> unexpected UnDeeper

****************** / term p                                                                              :4_2:Other "shar:
******************* / term p/1a:label directly above                                                    :4_2:Other "shar:
******************** / $*|                                                                             :4_2:Other "shar:
********************* / someSL                                                                        :4_2:Other "shar:
someSL> IN: Other "sharpen knives" UnDeeper
someSL> MATCH (COK): Other "sharpen knives"
someSL> VALUE: ((["sharpen knives"],0),[])

********************* \ someSL has returned (["sharpen knives"],0)                                     :1_2:UnDeeper:
********************* / pNumAsText                                                                     :1_2:UnDeeper:
pNumAsText> IN: UnDeeper
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=29:
pNumAsText> unexpected UnDeeper
pNumAsText> expecting number

$*|> IN: Other "sharpen knives" UnDeeper
$*|> MATCH (CERR): Other "sharpen knives"
$*|> ERROR:
$*|> offset=29:
$*|> unexpected UnDeeper
$*|> expecting GoDeeper or other text or number

term p/1a:label directly above> IN: Other "sharpen knives" UnDeeper
term p/1a:label directly above> MATCH (CERR): Other "sharpen knives"
term p/1a:label directly above> ERROR:
term p/1a:label directly above> offset=29:
term p/1a:label directly above> unexpected UnDeeper
term p/1a:label directly above> expecting GoDeeper or other text or number

******************* / term p/b:label to the left of line below, with EOL                                :4_2:Other "shar:
******************** / someSL                                                                          :4_2:Other "shar:
someSL> IN: Other "sharpen knives" UnDeeper
someSL> MATCH (COK): Other "sharpen knives"
someSL> VALUE: ((["sharpen knives"],0),[])

******************** \ someSL has returned (["sharpen knives"],0)                                       :1_2:UnDeeper:
******************** / undeepers                                                                        :1_2:UnDeeper:
********************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers         :1_2:UnDeeper:
********************* > sameLine: success!                                                             :1_2:UnDeeper:
undeepers> IN: UnDeeper
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

******************** \ undeepers has returned ()                                                        :1_2:UnDeeper:
******************** / matching EOL                                                                     :1_2:UnDeeper:
matching EOL> IN: UnDeeper
matching EOL> MATCH (EERR): <EMPTY>
matching EOL> ERROR:
matching EOL> offset=29:
matching EOL> unexpected UnDeeper
matching EOL> expecting EOL

term p/b:label to the left of line below, with EOL> IN: Other "sharpen knives" UnDeeper
term p/b:label to the left of line below, with EOL> MATCH (CERR): Other "sharpen knives"
term p/b:label to the left of line below, with EOL> ERROR:
term p/b:label to the left of line below, with EOL> offset=29:
term p/b:label to the left of line below, with EOL> unexpected UnDeeper
term p/b:label to the left of line below, with EOL> expecting EOL or GoDeeper

******************* / term p/notLabelTerm                                                               :4_2:Other "shar:
******************** / term p/2:someIndentation expr p                                                 :4_2:Other "shar:
********************* / someIndentation                                                               :4_2:Other "shar:
********************** / myindented: consuming GoDeeper                                              :4_2:Other "shar:
myindented: consuming GoDeeper> IN: Other "sharpen knives" UnDeeper
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=28:
myindented: consuming GoDeeper> unexpected Other "sharpen knives"
myindented: consuming GoDeeper> expecting GoDeeper

someIndentation> IN: Other "sharpen knives" UnDeeper
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=28:
someIndentation> unexpected Other "sharpen knives"
someIndentation> expecting GoDeeper

term p/2:someIndentation expr p> IN: Other "sharpen knives" UnDeeper
term p/2:someIndentation expr p> MATCH (EERR): <EMPTY>
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=28:
term p/2:someIndentation expr p> unexpected Other "sharpen knives"
term p/2:someIndentation expr p> expecting GoDeeper

******************** / term p/3:plain p                                                                :4_2:Other "shar:
********************* / pParamText                                                                    :4_2:Other "shar:
********************** / pParamText(flat) first line: pKeyValues                                     :4_2:Other "shar:
*********************** / pKeyValuesAka                                                             :4_2:Other "shar:
************************ / slAKA                                                                   :4_2:Other "shar:
************************* / $*|                                                                   :4_2:Other "shar:
************************** / slAKA base                                                          :4_2:Other "shar:
*************************** / slKeyValues                                                       :4_2:Other "shar:
**************************** / $*|                                                             :4_2:Other "shar:
***************************** / someSL                                                        :4_2:Other "shar:
someSL> IN: Other "sharpen knives" UnDeeper
someSL> MATCH (COK): Other "sharpen knives"
someSL> VALUE: ((["sharpen knives"],0),[])

***************************** \ someSL has returned (["sharpen knives"],0)                     :1_2:UnDeeper:
$*|> IN: Other "sharpen knives" UnDeeper
$*|> MATCH (COK): Other "sharpen knives"
$*|> VALUE: ((["sharpen knives"],0),[])

**************************** \ $*| has returned (["sharpen knives"],0)                          :1_2:UnDeeper:
**************************** / |>>/recurse                                                      :1_2:UnDeeper:
|>>/recurse> IN: UnDeeper
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=29:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

**************************** / |>>/base                                                         :1_2:UnDeeper:
***************************** / |?| optional something                                         :1_2:UnDeeper:
****************************** / |>>/recurse                                                  :1_2:UnDeeper:
|>>/recurse> IN: UnDeeper
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=29:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

****************************** / |>>/base                                                     :1_2:UnDeeper:
******************************* / slTypeSig                                                  :1_2:UnDeeper:
******************************** / $>|                                                      :1_2:UnDeeper:
$>|> IN: UnDeeper
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=29:
$>|> unexpected UnDeeper
$>|> expecting Is or TypeSeparator

slTypeSig> IN: UnDeeper
slTypeSig> MATCH (EERR): <EMPTY>
slTypeSig> ERROR:
slTypeSig> offset=29:
slTypeSig> unexpected UnDeeper
slTypeSig> expecting Is or TypeSeparator

|>>/base> IN: UnDeeper
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=29:
|>>/base> unexpected UnDeeper
|>>/base> expecting Is or TypeSeparator

|?| optional something> IN: UnDeeper
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

***************************** \ |?| optional something has returned (Nothing,0)                :1_2:UnDeeper:
***************************** > |>>/base got Nothing                                           :1_2:UnDeeper:
|>>/base> IN: UnDeeper
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

**************************** \ |>>/base has returned (Nothing,0)                                :1_2:UnDeeper:
slKeyValues> IN: Other "sharpen knives" UnDeeper
slKeyValues> MATCH (COK): Other "sharpen knives"
slKeyValues> VALUE: ((("sharpen knives" :| [],Nothing),0),[])

*************************** \ slKeyValues has returned (("sharpen knives" :| [],Nothing),0)      :1_2:UnDeeper:
slAKA base> IN: Other "sharpen knives" UnDeeper
slAKA base> MATCH (COK): Other "sharpen knives"
slAKA base> VALUE: ((("sharpen knives" :| [],Nothing),0),[])

************************** \ slAKA base has returned (("sharpen knives" :| [],Nothing),0)         :1_2:UnDeeper:
$*|> IN: Other "sharpen knives" UnDeeper
$*|> MATCH (COK): Other "sharpen knives"
$*|> VALUE: ((("sharpen knives" :| [],Nothing),0),[])

************************* \ $*| has returned (("sharpen knives" :| [],Nothing),0)                  :1_2:UnDeeper:
************************* / |>>/recurse                                                            :1_2:UnDeeper:
|>>/recurse> IN: UnDeeper
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=29:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************* / |>>/base                                                               :1_2:UnDeeper:
************************** / slAKA optional akapart                                               :1_2:UnDeeper:
*************************** / |?| optional something                                             :1_2:UnDeeper:
**************************** / |>>/recurse                                                      :1_2:UnDeeper:
|>>/recurse> IN: UnDeeper
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=29:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

**************************** / |>>/base                                                         :1_2:UnDeeper:
***************************** / PAKA/akapart                                                   :1_2:UnDeeper:
****************************** / $>|                                                          :1_2:UnDeeper:
******************************* / Aka Token                                                  :1_2:UnDeeper:
Aka Token> IN: UnDeeper
Aka Token> MATCH (EERR): <EMPTY>
Aka Token> ERROR:
Aka Token> offset=29:
Aka Token> unexpected UnDeeper
Aka Token> expecting Aka

$>|> IN: UnDeeper
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=29:
$>|> unexpected UnDeeper
$>|> expecting Aka

PAKA/akapart> IN: UnDeeper
PAKA/akapart> MATCH (EERR): <EMPTY>
PAKA/akapart> ERROR:
PAKA/akapart> offset=29:
PAKA/akapart> unexpected UnDeeper
PAKA/akapart> expecting Aka

|>>/base> IN: UnDeeper
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=29:
|>>/base> unexpected UnDeeper
|>>/base> expecting Aka

|?| optional something> IN: UnDeeper
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

*************************** \ |?| optional something has returned (Nothing,0)                    :1_2:UnDeeper:
slAKA optional akapart> IN: UnDeeper
slAKA optional akapart> MATCH (EOK): <EMPTY>
slAKA optional akapart> VALUE: ((Nothing,0),[])

************************** \ slAKA optional akapart has returned (Nothing,0)                      :1_2:UnDeeper:
************************** > |>>/base got Nothing                                                 :1_2:UnDeeper:
|>>/base> IN: UnDeeper
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************************* \ |>>/base has returned (Nothing,0)                                      :1_2:UnDeeper:
************************* / |>>/recurse                                                            :1_2:UnDeeper:
|>>/recurse> IN: UnDeeper
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=29:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

************************* / |>>/base                                                               :1_2:UnDeeper:
************************** / slAKA optional typically                                             :1_2:UnDeeper:
*************************** / |?| optional something                                             :1_2:UnDeeper:
**************************** / |>>/recurse                                                      :1_2:UnDeeper:
|>>/recurse> IN: UnDeeper
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=29:
|>>/recurse> unexpected UnDeeper
|>>/recurse> expecting GoDeeper

**************************** / |>>/base                                                         :1_2:UnDeeper:
***************************** / typically                                                      :1_2:UnDeeper:
****************************** / $>|                                                          :1_2:UnDeeper:
$>|> IN: UnDeeper
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=29:
$>|> unexpected UnDeeper
$>|> expecting Typically

typically> IN: UnDeeper
typically> MATCH (EERR): <EMPTY>
typically> ERROR:
typically> offset=29:
typically> unexpected UnDeeper
typically> expecting Typically

|>>/base> IN: UnDeeper
|>>/base> MATCH (EERR): <EMPTY>
|>>/base> ERROR:
|>>/base> offset=29:
|>>/base> unexpected UnDeeper
|>>/base> expecting Typically

|?| optional something> IN: UnDeeper
|?| optional something> MATCH (EOK): <EMPTY>
|?| optional something> VALUE: ((Nothing,0),[])

*************************** \ |?| optional something has returned (Nothing,0)                    :1_2:UnDeeper:
slAKA optional typically> IN: UnDeeper
slAKA optional typically> MATCH (EOK): <EMPTY>
slAKA optional typically> VALUE: ((Nothing,0),[])

************************** \ slAKA optional typically has returned (Nothing,0)                    :1_2:UnDeeper:
************************** > |>>/base got Nothing                                                 :1_2:UnDeeper:
|>>/base> IN: UnDeeper
|>>/base> MATCH (EOK): <EMPTY>
|>>/base> VALUE: ((Nothing,0),[])

************************* \ |>>/base has returned (Nothing,0)                                      :1_2:UnDeeper:
************************* > slAKA: proceeding after base and entityalias are retrieved ...         :1_2:UnDeeper:
************************* > pAKA: entityalias = Nothing                                            :1_2:UnDeeper:
slAKA> IN: Other "sharpen knives" UnDeeper
slAKA> MATCH (COK): Other "sharpen knives"
slAKA> VALUE: ((("sharpen knives" :| [],Nothing),0),[])

************************ \ slAKA has returned (("sharpen knives" :| [],Nothing),0)                  :1_2:UnDeeper:
************************ / undeepers                                                                :1_2:UnDeeper:
************************* > sameLine/undeepers: reached end of line; now need to clear 0 UnDeepers :1_2:UnDeeper:
************************* > sameLine: success!                                                     :1_2:UnDeeper:
undeepers> IN: UnDeeper
undeepers> MATCH (EOK): <EMPTY>
undeepers> VALUE: ((),[])

************************ \ undeepers has returned ()                                                :1_2:UnDeeper:
pKeyValuesAka> IN: Other "sharpen knives" UnDeeper
pKeyValuesAka> MATCH (COK): Other "sharpen knives"
pKeyValuesAka> VALUE: (("sharpen knives" :| [],Nothing),[])

*********************** \ pKeyValuesAka has returned ("sharpen knives" :| [],Nothing)                :1_2:UnDeeper:
pParamText(flat) first line: pKeyValues> IN: Other "sharpen knives" UnDeeper
pParamText(flat) first line: pKeyValues> MATCH (COK): Other "sharpen knives"
pParamText(flat) first line: pKeyValues> VALUE: (("sharpen knives" :| [],Nothing),[])

********************** \ pParamText(flat) first line: pKeyValues has returned ("sharpen knives" :| [],Nothing) :1_2:UnDeeper:
********************** / pParamText(flat) subsequent lines: sameMany pKeyValues                       :1_2:UnDeeper:
*********************** / manyIndentation/leaf?                                                      :1_2:UnDeeper:
************************ / sameMany                                                                 :1_2:UnDeeper:
************************* / pKeyValuesAka                                                          :1_2:UnDeeper:
************************** / slAKA                                                                :1_2:UnDeeper:
*************************** / $*|                                                                :1_2:UnDeeper:
**************************** / slAKA base                                                       :1_2:UnDeeper:
***************************** / slKeyValues                                                    :1_2:UnDeeper:
****************************** / $*|                                                          :1_2:UnDeeper:
******************************* / someSL                                                     :1_2:UnDeeper:
******************************** / pNumAsText                                               :1_2:UnDeeper:
pNumAsText> IN: UnDeeper
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=29:
pNumAsText> unexpected UnDeeper
pNumAsText> expecting number

someSL> IN: UnDeeper
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=29:
someSL> unexpected UnDeeper
someSL> expecting other text or number

$*|> IN: UnDeeper
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=29:
$*|> unexpected UnDeeper
$*|> expecting other text or number

slKeyValues> IN: UnDeeper
slKeyValues> MATCH (EERR): <EMPTY>
slKeyValues> ERROR:
slKeyValues> offset=29:
slKeyValues> unexpected UnDeeper
slKeyValues> expecting other text or number

slAKA base> IN: UnDeeper
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=29:
slAKA base> unexpected UnDeeper
slAKA base> expecting other text or number

$*|> IN: UnDeeper
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=29:
$*|> unexpected UnDeeper
$*|> expecting other text or number

slAKA> IN: UnDeeper
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=29:
slAKA> unexpected UnDeeper
slAKA> expecting other text or number

pKeyValuesAka> IN: UnDeeper
pKeyValuesAka> MATCH (EERR): <EMPTY>
pKeyValuesAka> ERROR:
pKeyValuesAka> offset=29:
pKeyValuesAka> unexpected UnDeeper
pKeyValuesAka> expecting other text or number

sameMany> IN: UnDeeper
sameMany> MATCH (EOK): <EMPTY>
sameMany> VALUE: ([],[])

************************ \ sameMany has returned []                                                 :1_2:UnDeeper:
manyIndentation/leaf?> IN: UnDeeper
manyIndentation/leaf?> MATCH (EOK): <EMPTY>
manyIndentation/leaf?> VALUE: ([],[])

*********************** \ manyIndentation/leaf? has returned []                                      :1_2:UnDeeper:
pParamText(flat) subsequent lines: sameMany pKeyValues> IN: UnDeeper
pParamText(flat) subsequent lines: sameMany pKeyValues> MATCH (EOK): <EMPTY>
pParamText(flat) subsequent lines: sameMany pKeyValues> VALUE: ([],[])

********************** \ pParamText(flat) subsequent lines: sameMany pKeyValues has returned []       :1_2:UnDeeper:
pParamText> IN: Other "sharpen knives" UnDeeper
pParamText> MATCH (COK): Other "sharpen knives"
pParamText> VALUE: (("sharpen knives" :| [],Nothing) :| [],[])

********************* \ pParamText has returned ("sharpen knives" :| [],Nothing) :| []                 :1_2:UnDeeper:
term p/3:plain p> IN: Other "sharpen knives" UnDeeper
term p/3:plain p> MATCH (COK): Other "sharpen knives"
term p/3:plain p> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

******************** \ term p/3:plain p has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])    :1_2:UnDeeper:
term p/notLabelTerm> IN: Other "sharpen knives" UnDeeper
term p/notLabelTerm> MATCH (COK): Other "sharpen knives"
term p/notLabelTerm> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

******************* \ term p/notLabelTerm has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])   :1_2:UnDeeper:
term p> IN: Other "sharpen knives" UnDeeper
term p> MATCH (COK): Other "sharpen knives"
term p> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

****************** \ term p has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])                  :1_2:UnDeeper:
****************** / binary(Or)                                                                           :1_2:UnDeeper:
binary(Or)> IN: UnDeeper
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=29:
binary(Or)> unexpected UnDeeper
binary(Or)> expecting Or

****************** / binary(And)                                                                          :1_2:UnDeeper:
binary(And)> IN: UnDeeper
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=29:
binary(And)> unexpected UnDeeper
binary(And)> expecting And

****************** / binary(SetLess)                                                                      :1_2:UnDeeper:
binary(SetLess)> IN: UnDeeper
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=29:
binary(SetLess)> unexpected UnDeeper
binary(SetLess)> expecting SetLess

****************** / binary(SetPlus)                                                                      :1_2:UnDeeper:
binary(SetPlus)> IN: UnDeeper
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=29:
binary(SetPlus)> unexpected UnDeeper
binary(SetPlus)> expecting SetPlus

expression> IN: Other "sharpen knives" UnDeeper
expression> MATCH (COK): Other "sharpen knives"
expression> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

***************** \ expression has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])                :1_2:UnDeeper:
manyIndentation/leaf?> IN: Other "sharpen knives" UnDeeper
manyIndentation/leaf?> MATCH (COK): Other "sharpen knives"
manyIndentation/leaf?> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

**************** \ manyIndentation/leaf? has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])       :1_2:UnDeeper:
**************** / myindented: consuming UnDeeper                                                           :1_2:UnDeeper:
myindented: consuming UnDeeper> IN: UnDeeper
myindented: consuming UnDeeper> MATCH (COK): UnDeeper
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

**************** \ myindented: consuming UnDeeper has returned UnDeeper                                :EOF:
someIndentation> IN: GoDeeper Other "sharpen knives" UnDeeper
someIndentation> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
someIndentation> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

*************** \ someIndentation has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])          :EOF:
term p/2:someIndentation expr p> IN: GoDeeper Other "sharpen knives" UnDeeper
term p/2:someIndentation expr p> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
term p/2:someIndentation expr p> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

************** \ term p/2:someIndentation expr p has returned MyLeaf (("sharpen knives" :| [],Nothing) :| []) :EOF:
term p/notLabelTerm> IN: GoDeeper Other "sharpen knives" UnDeeper
term p/notLabelTerm> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
term p/notLabelTerm> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

************* \ term p/notLabelTerm has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])          :EOF:
term p> IN: GoDeeper Other "sharpen knives" UnDeeper
term p> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
term p> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

************ \ term p has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])                         :EOF:
************ / binary(Or)                                                                                  :EOF:
binary(Or)> IN: <EMPTY>
binary(Or)> MATCH (EERR): <EMPTY>
binary(Or)> ERROR:
binary(Or)> offset=30:
binary(Or)> unexpected end of input
binary(Or)> expecting Or

************ / binary(And)                                                                                 :EOF:
binary(And)> IN: <EMPTY>
binary(And)> MATCH (EERR): <EMPTY>
binary(And)> ERROR:
binary(And)> offset=30:
binary(And)> unexpected end of input
binary(And)> expecting And

************ / binary(SetLess)                                                                             :EOF:
binary(SetLess)> IN: <EMPTY>
binary(SetLess)> MATCH (EERR): <EMPTY>
binary(SetLess)> ERROR:
binary(SetLess)> offset=30:
binary(SetLess)> unexpected end of input
binary(SetLess)> expecting SetLess

************ / binary(SetPlus)                                                                             :EOF:
binary(SetPlus)> IN: <EMPTY>
binary(SetPlus)> MATCH (EERR): <EMPTY>
binary(SetPlus)> ERROR:
binary(SetPlus)> offset=30:
binary(SetPlus)> unexpected end of input
binary(SetPlus)> expecting SetPlus

expression> IN: GoDeeper Other "sharpen knives" UnDeeper
expression> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
expression> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

*********** \ expression has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])                       :EOF:
expr pParamText> IN: GoDeeper Other "sharpen knives" UnDeeper
expr pParamText> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
expr pParamText> VALUE: (MyLeaf (("sharpen knives" :| [],Nothing) :| []),[])

********** \ expr pParamText has returned MyLeaf (("sharpen knives" :| [],Nothing) :| [])                    :EOF:
dBoolStructP calling exprP> IN: GoDeeper Other "sharpen knives" UnDeeper
dBoolStructP calling exprP> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
dBoolStructP calling exprP> VALUE: (Leaf (("sharpen knives" :| [],Nothing) :| []),[])

********* \ dBoolStructP calling exprP has returned Leaf (("sharpen knives" :| [],Nothing) :| [])             :EOF:
pAction calling dBoolStructP> IN: GoDeeper Other "sharpen knives" UnDeeper
pAction calling dBoolStructP> MATCH (COK): GoDeeper Other "sharpen knives" UnDeeper
pAction calling dBoolStructP> VALUE: (Leaf (("sharpen knives" :| [],Nothing) :| []),[])

******** \ pAction calling dBoolStructP has returned Leaf (("sharpen knives" :| [],Nothing) :| [])             :EOF:
pDA> IN: May GoDeeper Other "sharpen knives" UnDe <…>
pDA> MATCH (COK): May GoDeeper Other "sharpen knives" UnDe <…>
pDA> VALUE: ((DMay,Leaf (("sharpen knives" :| [],Nothing) :| [])),[])

******* \ pDA has returned (DMay,Leaf (("sharpen knives" :| [],Nothing) :| []))                                 :EOF:
******* / WHERE                                                                                                 :EOF:
WHERE> IN: <EMPTY>
WHERE> MATCH (EERR): <EMPTY>
WHERE> ERROR:
WHERE> offset=30:
WHERE> unexpected end of input
WHERE> expecting Where

******* / preambleParamText:[Having]                                                                            :EOF:
******** / $>|                                                                                                 :EOF:
$>|> IN: <EMPTY>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=30:
$>|> unexpected end of input
$>|> expecting Having

preambleParamText:[Having]> IN: <EMPTY>
preambleParamText:[Having]> MATCH (EERR): <EMPTY>
preambleParamText:[Having]> ERROR:
preambleParamText:[Having]> offset=30:
preambleParamText:[Having]> unexpected end of input
preambleParamText:[Having]> expecting Having or any token

******* / preambleParamText:[Given]                                                                             :EOF:
******** / $>|                                                                                                 :EOF:
$>|> IN: <EMPTY>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=30:
$>|> unexpected end of input
$>|> expecting Given

preambleParamText:[Given]> IN: <EMPTY>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=30:
preambleParamText:[Given]> unexpected end of input
preambleParamText:[Given]> expecting Given or any token

******* / preambleParamText:[Upon]                                                                              :EOF:
******** / $>|                                                                                                 :EOF:
$>|> IN: <EMPTY>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=30:
$>|> unexpected end of input
$>|> expecting Upon

preambleParamText:[Upon]> IN: <EMPTY>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=30:
preambleParamText:[Upon]> unexpected end of input
preambleParamText:[Upon]> expecting Upon or any token

******* / preambleBoolStructR [Unless]                                                                          :EOF:
preambleBoolStructR [Unless]> IN: <EMPTY>
preambleBoolStructR [Unless]> MATCH (EERR): <EMPTY>
preambleBoolStructR [Unless]> ERROR:
preambleBoolStructR [Unless]> offset=30:
preambleBoolStructR [Unless]> unexpected end of input
preambleBoolStructR [Unless]> expecting Unless

******* / preambleBoolStructR [When,If]                                                                         :EOF:
preambleBoolStructR [When,If]> IN: <EMPTY>
preambleBoolStructR [When,If]> MATCH (EERR): <EMPTY>
preambleBoolStructR [When,If]> ERROR:
preambleBoolStructR [When,If]> offset=30:
preambleBoolStructR [When,If]> unexpected end of input
preambleBoolStructR [When,If]> expecting If or When

******* / pTemporal/eventually                                                                                  :EOF:
pTemporal/eventually> IN: <EMPTY>
pTemporal/eventually> MATCH (EERR): <EMPTY>
pTemporal/eventually> ERROR:
pTemporal/eventually> offset=30:
pTemporal/eventually> unexpected end of input
pTemporal/eventually> expecting Eventually

******* / pTemporal/specifically                                                                                :EOF:
******** / $>|                                                                                                 :EOF:
$>|> IN: <EMPTY>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=30:
$>|> unexpected end of input
$>|> expecting After, Before, By, or On

pTemporal/specifically> IN: <EMPTY>
pTemporal/specifically> MATCH (EERR): <EMPTY>
pTemporal/specifically> ERROR:
pTemporal/specifically> offset=30:
pTemporal/specifically> unexpected end of input
pTemporal/specifically> expecting After, Before, By, On, or any token

******* / pTemporal/vaguely                                                                                     :EOF:
pTemporal/vaguely> IN: <EMPTY>
pTemporal/vaguely> MATCH (EERR): <EMPTY>
pTemporal/vaguely> ERROR:
pTemporal/vaguely> offset=30:
pTemporal/vaguely> unexpected end of input
pTemporal/vaguely> expecting Other text

regulative permutation with deontic-action> IN: Every GoDeeper Other "person" UnDeeper W <…>
regulative permutation with deontic-action> MATCH (COK): Every GoDeeper Other "person" UnDeeper W <…>
regulative permutation with deontic-action> VALUE: (RuleBody {rbaction = Leaf (("sharpen knives" :| [],Nothing) :| []), rbpbrs = [], rbpbrneg = [], rbdeon = DMay, rbtemporal = Nothing, rbupon = [], rbgiven = [], rbhaving = Nothing, rbkeyname = (Every,Leaf (("person" :| [],Nothing) :| [])), rbwho = Just (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), rbwhere = []},[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

****** \ regulative permutation with deontic-action has returned RuleBody {rbaction = Leaf (("sharpen knives" :| [],Nothing) :| []), rbpbrs = [], rbpbrneg = [], rbdeon = DMay, rbtemporal = Nothing, rbupon = [], rbgiven = [], rbhaving = Nothing, rbkeyname = (Every,Leaf (("person" :| [],Nothing) :| [])), rbwho = Just (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), rbwhere = []} :EOF:
permutationsReg> IN: Every GoDeeper Other "person" UnDeeper W <…>
permutationsReg> MATCH (COK): Every GoDeeper Other "person" UnDeeper W <…>
permutationsReg> VALUE: (RuleBody {rbaction = Leaf (("sharpen knives" :| [],Nothing) :| []), rbpbrs = [], rbpbrneg = [], rbdeon = DMay, rbtemporal = Nothing, rbupon = [], rbgiven = [], rbhaving = Nothing, rbkeyname = (Every,Leaf (("person" :| [],Nothing) :| [])), rbwho = Just (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), rbwhere = []},[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

***** \ permutationsReg has returned RuleBody {rbaction = Leaf (("sharpen knives" :| [],Nothing) :| []), rbpbrs = [], rbpbrneg = [], rbdeon = DMay, rbtemporal = Nothing, rbupon = [], rbgiven = [], rbhaving = Nothing, rbkeyname = (Every,Leaf (("person" :| [],Nothing) :| [])), rbwho = Just (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), rbwhere = []} :EOF:
***** / pHenceLest-Hence                                                                                          :EOF:
pHenceLest-Hence> IN: <EMPTY>
pHenceLest-Hence> MATCH (EERR): <EMPTY>
pHenceLest-Hence> ERROR:
pHenceLest-Hence> offset=30:
pHenceLest-Hence> unexpected end of input
pHenceLest-Hence> expecting Hence

***** / pHenceLest-Lest                                                                                           :EOF:
pHenceLest-Lest> IN: <EMPTY>
pHenceLest-Lest> MATCH (EERR): <EMPTY>
pHenceLest-Lest> ERROR:
pHenceLest-Lest> offset=30:
pHenceLest-Lest> unexpected end of input
pHenceLest-Lest> expecting Lest

****   pRegRuleNormal: permutations returned rulebody RuleBody {rbaction = Leaf (("sharpen knives" :| [],Nothing) :| []), rbpbrs = [], rbpbrneg = [], rbdeon = DMay, rbtemporal = Nothing, rbupon = [], rbgiven = [], rbhaving = Nothing, rbkeyname = (Every,Leaf (("person" :| [],Nothing) :| [])), rbwho = Just (Who,Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), rbwhere = []} :EOF:
****   pRegRuleNormal: the positive preamble is Nothing                                                           :EOF:
****   pRegRuleNormal: the negative preamble is Nothing                                                           :EOF:
****   pRegRuleNormal: returning Regulative {subj = Leaf (("person" :| [],Nothing) :| []), keyword = Every, who = Just (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), cond = Nothing, deontic = DMay, action = Leaf (("sharpen knives" :| [],Nothing) :| []), temporal = Nothing, hence = Nothing, lest = Nothing, rlabel = Nothing, lsource = Nothing, srcref = Nothing, upon = Nothing, given = Nothing, having = Nothing, wwhere = [], defaults = [], symtab = []} :EOF:
pRegRuleNormal> IN: Every GoDeeper Other "person" UnDeeper W <…>
pRegRuleNormal> MATCH (COK): Every GoDeeper Other "person" UnDeeper W <…>
pRegRuleNormal> VALUE: (Regulative {subj = Leaf (("person" :| [],Nothing) :| []), keyword = Every, who = Just (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), cond = Nothing, deontic = DMay, action = Leaf (("sharpen knives" :| [],Nothing) :| []), temporal = Nothing, hence = Nothing, lest = Nothing, rlabel = Nothing, lsource = Nothing, srcref = Nothing, upon = Nothing, given = Nothing, having = Nothing, wwhere = [], defaults = [], symtab = []},[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

**** \ pRegRuleNormal has returned Regulative {subj = Leaf (("person" :| [],Nothing) :| []), keyword = Every, who = Just (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), cond = Nothing, deontic = DMay, action = Leaf (("sharpen knives" :| [],Nothing) :| []), temporal = Nothing, hence = Nothing, lest = Nothing, rlabel = Nothing, lsource = Nothing, srcref = Nothing, upon = Nothing, given = Nothing, having = Nothing, wwhere = [], defaults = [], symtab = []} :EOF:
pRegRule> IN: Every GoDeeper Other "person" UnDeeper W <…>
pRegRule> MATCH (COK): Every GoDeeper Other "person" UnDeeper W <…>
pRegRule> VALUE: (Regulative {subj = Leaf (("person" :| [],Nothing) :| []), keyword = Every, who = Just (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), cond = Nothing, deontic = DMay, action = Leaf (("sharpen knives" :| [],Nothing) :| []), temporal = Nothing, hence = Nothing, lest = Nothing, rlabel = Nothing, lsource = Nothing, srcref = Nothing, upon = Nothing, given = Nothing, having = Nothing, wwhere = [], defaults = [], symtab = []},[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

*** \ pRegRule has returned Regulative {subj = Leaf (("person" :| [],Nothing) :| []), keyword = Every, who = Just (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), cond = Nothing, deontic = DMay, action = Leaf (("sharpen knives" :| [],Nothing) :| []), temporal = Nothing, hence = Nothing, lest = Nothing, rlabel = Nothing, lsource = Nothing, srcref = Nothing, upon = Nothing, given = Nothing, having = Nothing, wwhere = [], defaults = [], symtab = []} :EOF:
pRule> IN: Every GoDeeper Other "person" UnDeeper W <…>
pRule> MATCH (COK): Every GoDeeper Other "person" UnDeeper W <…>
pRule> VALUE: (Regulative {subj = Leaf (("person" :| [],Nothing) :| []), keyword = Every, who = Just (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), cond = Nothing, deontic = DMay, action = Leaf (("sharpen knives" :| [],Nothing) :| []), temporal = Nothing, hence = Nothing, lest = Nothing, rlabel = Nothing, lsource = Nothing, srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 1, srccol = 1, version = Nothing}), upon = Nothing, given = Nothing, having = Nothing, wwhere = [], defaults = [], symtab = []},[DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}])

** \ pRule has returned Regulative {subj = Leaf (("person" :| [],Nothing) :| []), keyword = Every, who = Just (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), cond = Nothing, deontic = DMay, action = Leaf (("sharpen knives" :| [],Nothing) :| []), temporal = Nothing, hence = Nothing, lest = Nothing, rlabel = Nothing, lsource = Nothing, srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 1, srccol = 1, version = Nothing}), upon = Nothing, given = Nothing, having = Nothing, wwhere = [], defaults = [], symtab = []} :EOF:

PDPA
  boolstructp-3 FAILED [1]
  boolstructp-3 FAILED [2]
  boolstructp-3
  boolstructp-3

Failures:

  test/Spec.hs:124:3: 
  1) PDPA boolstructp-3
       expected: [[Regulative {subj = Leaf (("person" :| [],Nothing) :| []), keyword = Every, who = Just (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), cond = Nothing, deontic = DMay, action = Leaf (("sharpen knives" :| [],Nothing) :| []), temporal = Nothing, hence = Nothing, lest = Nothing, rlabel = Nothing, lsource = Nothing, srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 1, srccol = 1, version = Nothing}), upon = Nothing, given = Nothing, having = Nothing, wwhere = [], defaults = [], symtab = []},DefTypically {name = ["is","immortal"], defaults = [RPConstraint ["is","immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}]]
        but got: [[Regulative {subj = Leaf (("person" :| [],Nothing) :| []), keyword = Every, who = Just (Any Nothing [Leaf (RPMT ["is","immortal"]),Leaf (RPMT ["has","health insurance"])]), cond = Nothing, deontic = DMay, action = Leaf (("sharpen knives" :| [],Nothing) :| []), temporal = Nothing, hence = Nothing, lest = Nothing, rlabel = Nothing, lsource = Nothing, srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 1, srccol = 1, version = Nothing}), upon = Nothing, given = Nothing, having = Nothing, wwhere = [], defaults = [], symtab = []},DefTypically {name = ["immortal"], defaults = [RPConstraint ["immortal"] RPis ["false"]], srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 3, srccol = 3, version = Nothing})}]]

  To rerun use: --match "/PDPA/boolstructp-3/"

  test/Spec.hs:124:3: 
  2) PDPA boolstructp-3
       expected: [[["person","has","health insurance"]]]
        but got: [[["person","is","immortal"],["person","has","health insurance"]]]

  To rerun use: --match "/PDPA/boolstructp-3/"

Randomized with seed 1560370964

Finished in 0.1464 seconds
4 examples, 2 failures

natural4> Test suite natural4-test failed
Test suite failure for package natural4-0.1.0.0
    natural4-test:  exited with: ExitFailure 1
Logs printed to console

