* preface
:PROPERTIES:
:VISIBILITY: folded
:END:

natural4> test (suite: natural4-test, args: --match "/revised parser/horn-2/")

* Tokens
DECIDE
    ( "X"
        ( IS ( "Y" ) )
    ) WHEN
    ( "Z"
        ( IS ( "Q" ) )
    ) AND
    ( "P"
        ( > ( "NP" ) )
    )
* main
:PROPERTIES:
:VISIBILITY: children
:END:

** / pRule                                                                                                             :1_1:Decide:
*** / pRegRule                                                                                                        :1_1:Decide:
**** / pRuleLabel                                                                                                    :1_1:Decide:
***** / $>|                                                                                                         :1_1:Decide:
$>|> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected DECIDE
$>|> expecting §

pRuleLabel> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pRuleLabel> MATCH (EERR): <EMPTY>
pRuleLabel> ERROR:
pRuleLabel> offset=0:
pRuleLabel> unexpected DECIDE
pRuleLabel> expecting §

**** / pRegRuleSugary                                                                                                :1_1:Decide:
***** / someDeep                                                                                                    :1_1:Decide:
****** / someDeep first part calls base directly                                                                   :1_1:Decide:
someDeep first part calls base directly> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
someDeep first part calls base directly> MATCH (EERR): <EMPTY>
someDeep first part calls base directly> ERROR:
someDeep first part calls base directly> offset=0:
someDeep first part calls base directly> unexpected DECIDE
someDeep first part calls base directly> expecting Other text

someDeep> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
someDeep> MATCH (EERR): <EMPTY>
someDeep> ERROR:
someDeep> offset=0:
someDeep> unexpected DECIDE
someDeep> expecting Other text

pRegRuleSugary> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pRegRuleSugary> MATCH (EERR): <EMPTY>
pRegRuleSugary> ERROR:
pRegRuleSugary> offset=0:
pRegRuleSugary> unexpected DECIDE
pRegRuleSugary> expecting Other text

**** / pRegRuleNormal                                                                                                :1_1:Decide:
***** / permutationsReg                                                                                             :1_1:Decide:
****** / regulative permutation with deontic-temporal                                                              :1_1:Decide:
******* / WHERE                                                                                                   :1_1:Decide:
WHERE> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
WHERE> MATCH (EERR): <EMPTY>
WHERE> ERROR:
WHERE> offset=0:
WHERE> unexpected DECIDE
WHERE> expecting WHERE

******* / preambleParamText:[Having]                                                                              :1_1:Decide:
******** / $>|                                                                                                   :1_1:Decide:
$>|> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected DECIDE
$>|> expecting HAVING

preambleParamText:[Having]> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
preambleParamText:[Having]> MATCH (EERR): <EMPTY>
preambleParamText:[Having]> ERROR:
preambleParamText:[Having]> offset=0:
preambleParamText:[Having]> unexpected DECIDE
preambleParamText:[Having]> expecting HAVING

******* / preambleParamText:[Given]                                                                               :1_1:Decide:
******** / $>|                                                                                                   :1_1:Decide:
$>|> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected DECIDE
$>|> expecting GIVEN

preambleParamText:[Given]> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=0:
preambleParamText:[Given]> unexpected DECIDE
preambleParamText:[Given]> expecting GIVEN

******* / preambleParamText:[Upon]                                                                                :1_1:Decide:
******** / $>|                                                                                                   :1_1:Decide:
$>|> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected DECIDE
$>|> expecting UPON

preambleParamText:[Upon]> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=0:
preambleParamText:[Upon]> unexpected DECIDE
preambleParamText:[Upon]> expecting UPON

******* / preambleBoolStructR [Unless]                                                                            :1_1:Decide:
preambleBoolStructR [Unless]> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
preambleBoolStructR [Unless]> MATCH (EERR): <EMPTY>
preambleBoolStructR [Unless]> ERROR:
preambleBoolStructR [Unless]> offset=0:
preambleBoolStructR [Unless]> unexpected DECIDE
preambleBoolStructR [Unless]> expecting UNLESS

******* / preambleBoolStructR [When,If]                                                                           :1_1:Decide:
preambleBoolStructR [When,If]> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
preambleBoolStructR [When,If]> MATCH (EERR): <EMPTY>
preambleBoolStructR [When,If]> ERROR:
preambleBoolStructR [When,If]> offset=0:
preambleBoolStructR [When,If]> unexpected DECIDE
preambleBoolStructR [When,If]> expecting IF or WHEN

******* / pDT                                                                                                     :1_1:Decide:
******** / $>|                                                                                                   :1_1:Decide:
$>|> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected DECIDE
$>|> expecting MAY, MUST, or SHANT

pDT> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pDT> MATCH (EERR): <EMPTY>
pDT> ERROR:
pDT> offset=0:
pDT> unexpected DECIDE
pDT> expecting MAY, MUST, or SHANT

******* / pActor [Every,Party,TokAll]                                                                             :1_1:Decide:
pActor [Every,Party,TokAll]> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pActor [Every,Party,TokAll]> MATCH (EERR): <EMPTY>
pActor [Every,Party,TokAll]> ERROR:
pActor [Every,Party,TokAll]> offset=0:
pActor [Every,Party,TokAll]> unexpected DECIDE
pActor [Every,Party,TokAll]> expecting ALL, EVERY, or PARTY

******* / pDoAction/Do                                                                                            :1_1:Decide:
pDoAction/Do> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pDoAction/Do> MATCH (EERR): <EMPTY>
pDoAction/Do> ERROR:
pDoAction/Do> offset=0:
pDoAction/Do> unexpected DECIDE
pDoAction/Do> expecting DO

regulative permutation with deontic-temporal> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
regulative permutation with deontic-temporal> MATCH (EERR): <EMPTY>
regulative permutation with deontic-temporal> ERROR:
regulative permutation with deontic-temporal> offset=0:
regulative permutation with deontic-temporal> unexpected DECIDE
regulative permutation with deontic-temporal> expecting ALL, DO, EVERY, GIVEN, HAVING, IF, MAY, MUST, PARTY, SHANT, UNLESS, UPON, WHEN, or WHERE

****** / regulative permutation with deontic-action                                                                :1_1:Decide:
******* / WHERE                                                                                                   :1_1:Decide:
WHERE> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
WHERE> MATCH (EERR): <EMPTY>
WHERE> ERROR:
WHERE> offset=0:
WHERE> unexpected DECIDE
WHERE> expecting WHERE

******* / preambleParamText:[Having]                                                                              :1_1:Decide:
******** / $>|                                                                                                   :1_1:Decide:
$>|> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected DECIDE
$>|> expecting HAVING

preambleParamText:[Having]> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
preambleParamText:[Having]> MATCH (EERR): <EMPTY>
preambleParamText:[Having]> ERROR:
preambleParamText:[Having]> offset=0:
preambleParamText:[Having]> unexpected DECIDE
preambleParamText:[Having]> expecting HAVING

******* / preambleParamText:[Given]                                                                               :1_1:Decide:
******** / $>|                                                                                                   :1_1:Decide:
$>|> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected DECIDE
$>|> expecting GIVEN

preambleParamText:[Given]> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=0:
preambleParamText:[Given]> unexpected DECIDE
preambleParamText:[Given]> expecting GIVEN

******* / preambleParamText:[Upon]                                                                                :1_1:Decide:
******** / $>|                                                                                                   :1_1:Decide:
$>|> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected DECIDE
$>|> expecting UPON

preambleParamText:[Upon]> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=0:
preambleParamText:[Upon]> unexpected DECIDE
preambleParamText:[Upon]> expecting UPON

******* / preambleBoolStructR [Unless]                                                                            :1_1:Decide:
preambleBoolStructR [Unless]> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
preambleBoolStructR [Unless]> MATCH (EERR): <EMPTY>
preambleBoolStructR [Unless]> ERROR:
preambleBoolStructR [Unless]> offset=0:
preambleBoolStructR [Unless]> unexpected DECIDE
preambleBoolStructR [Unless]> expecting UNLESS

******* / preambleBoolStructR [When,If]                                                                           :1_1:Decide:
preambleBoolStructR [When,If]> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
preambleBoolStructR [When,If]> MATCH (EERR): <EMPTY>
preambleBoolStructR [When,If]> ERROR:
preambleBoolStructR [When,If]> offset=0:
preambleBoolStructR [When,If]> unexpected DECIDE
preambleBoolStructR [When,If]> expecting IF or WHEN

******* / pTemporal/eventually                                                                                    :1_1:Decide:
pTemporal/eventually> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pTemporal/eventually> MATCH (EERR): <EMPTY>
pTemporal/eventually> ERROR:
pTemporal/eventually> offset=0:
pTemporal/eventually> unexpected DECIDE
pTemporal/eventually> expecting EVENTUALLY

******* / pTemporal/specifically                                                                                  :1_1:Decide:
******** / $>|                                                                                                   :1_1:Decide:
$>|> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected DECIDE
$>|> expecting AFTER, BEFORE, BY, or ON

pTemporal/specifically> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pTemporal/specifically> MATCH (EERR): <EMPTY>
pTemporal/specifically> ERROR:
pTemporal/specifically> offset=0:
pTemporal/specifically> unexpected DECIDE
pTemporal/specifically> expecting AFTER, BEFORE, BY, or ON

******* / pTemporal/vaguely                                                                                       :1_1:Decide:
pTemporal/vaguely> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pTemporal/vaguely> MATCH (EERR): <EMPTY>
pTemporal/vaguely> ERROR:
pTemporal/vaguely> offset=0:
pTemporal/vaguely> unexpected DECIDE
pTemporal/vaguely> expecting Other text

******* / pActor [Every,Party,TokAll]                                                                             :1_1:Decide:
pActor [Every,Party,TokAll]> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pActor [Every,Party,TokAll]> MATCH (EERR): <EMPTY>
pActor [Every,Party,TokAll]> ERROR:
pActor [Every,Party,TokAll]> offset=0:
pActor [Every,Party,TokAll]> unexpected DECIDE
pActor [Every,Party,TokAll]> expecting ALL, EVERY, or PARTY

******* / pDA                                                                                                     :1_1:Decide:
pDA> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pDA> MATCH (EERR): <EMPTY>
pDA> ERROR:
pDA> offset=0:
pDA> unexpected DECIDE
pDA> expecting MAY, MUST, or SHANT

regulative permutation with deontic-action> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
regulative permutation with deontic-action> MATCH (EERR): <EMPTY>
regulative permutation with deontic-action> ERROR:
regulative permutation with deontic-action> offset=0:
regulative permutation with deontic-action> unexpected DECIDE
regulative permutation with deontic-action> expecting AFTER, ALL, BEFORE, BY, EVENTUALLY, EVERY, GIVEN, HAVING, IF, MAY, MUST, ON, Other text, PARTY, SHANT, UNLESS, UPON, WHEN, or WHERE

permutationsReg> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
permutationsReg> MATCH (EERR): <EMPTY>
permutationsReg> ERROR:
permutationsReg> offset=0:
permutationsReg> unexpected DECIDE
permutationsReg> expecting AFTER, ALL, BEFORE, BY, DO, EVENTUALLY, EVERY, GIVEN, HAVING, IF, MAY, MUST, ON, Other text, PARTY, SHANT, UNLESS, UPON, WHEN, or WHERE

pRegRuleNormal> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pRegRuleNormal> MATCH (EERR): <EMPTY>
pRegRuleNormal> ERROR:
pRegRuleNormal> offset=0:
pRegRuleNormal> unexpected DECIDE
pRegRuleNormal> expecting AFTER, ALL, BEFORE, BY, DO, EVENTUALLY, EVERY, GIVEN, HAVING, IF, MAY, MUST, ON, Other text, PARTY, SHANT, UNLESS, UPON, WHEN, or WHERE

pRegRule> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pRegRule> MATCH (EERR): <EMPTY>
pRegRule> ERROR:
pRegRule> offset=0:
pRegRule> unexpected DECIDE
pRegRule> expecting AFTER, ALL, BEFORE, BREACH, BY, DO, EVENTUALLY, EVERY, FULFILLED, GIVEN, HAVING, IF, MAY, MUST, ON, Other text, PARTY, SHANT, UNLESS, UPON, WHEN, WHERE, or §

*** / pTypeDefinition                                                                                                 :1_1:Decide:
**** / pRuleLabel                                                                                                    :1_1:Decide:
***** / $>|                                                                                                         :1_1:Decide:
$>|> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected DECIDE
$>|> expecting §

pRuleLabel> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pRuleLabel> MATCH (EERR): <EMPTY>
pRuleLabel> ERROR:
pRuleLabel> offset=0:
pRuleLabel> unexpected DECIDE
pRuleLabel> expecting §

**** / pHornlike/uponLimb                                                                                            :1_1:Decide:
***** / preambleParamText:[Upon]                                                                                    :1_1:Decide:
****** / $>|                                                                                                       :1_1:Decide:
$>|> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected DECIDE
$>|> expecting UPON

preambleParamText:[Upon]> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=0:
preambleParamText:[Upon]> unexpected DECIDE
preambleParamText:[Upon]> expecting UPON

pHornlike/uponLimb> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pHornlike/uponLimb> MATCH (EERR): <EMPTY>
pHornlike/uponLimb> ERROR:
pHornlike/uponLimb> offset=0:
pHornlike/uponLimb> unexpected DECIDE
pHornlike/uponLimb> expecting UPON

**** / pHornlike/givenLimb                                                                                           :1_1:Decide:
***** / preambleParamText:[Given]                                                                                   :1_1:Decide:
****** / $>|                                                                                                       :1_1:Decide:
$>|> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected DECIDE
$>|> expecting GIVEN

preambleParamText:[Given]> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=0:
preambleParamText:[Given]> unexpected DECIDE
preambleParamText:[Given]> expecting GIVEN

pHornlike/givenLimb> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pHornlike/givenLimb> MATCH (EERR): <EMPTY>
pHornlike/givenLimb> ERROR:
pHornlike/givenLimb> offset=0:
pHornlike/givenLimb> unexpected DECIDE
pHornlike/givenLimb> expecting GIVEN

pTypeDefinition> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pTypeDefinition> MATCH (EERR): <EMPTY>
pTypeDefinition> ERROR:
pTypeDefinition> offset=0:
pTypeDefinition> unexpected DECIDE
pTypeDefinition> expecting DEFINE, GIVEN, UPON, or §

*** / pConstitutiveRule                                                                                               :1_1:Decide:
**** / pRuleLabel                                                                                                    :1_1:Decide:
***** / $>|                                                                                                         :1_1:Decide:
$>|> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected DECIDE
$>|> expecting §

pRuleLabel> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pRuleLabel> MATCH (EERR): <EMPTY>
pRuleLabel> ERROR:
pRuleLabel> offset=0:
pRuleLabel> unexpected DECIDE
pRuleLabel> expecting §

**** / calling myindented pNameParens                                                                                :1_1:Decide:
***** / manyIndentation/leaf?                                                                                       :1_1:Decide:
****** / pMultiTermAka                                                                                             :1_1:Decide:
******* / pAKA                                                                                                    :1_1:Decide:
******** / slAKA                                                                                                 :1_1:Decide:
********* / $*|                                                                                                 :1_1:Decide:
********** / slAKA base                                                                                        :1_1:Decide:
*********** / slMultiTerm                                                                                     :1_1:Decide:
************ / someSL                                                                                        :1_1:Decide:
************* / pNumAsText                                                                                  :1_1:Decide:
pNumAsText> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=0:
pNumAsText> unexpected DECIDE
pNumAsText> expecting number

someSL> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=0:
someSL> unexpected DECIDE
someSL> expecting other text or number

slMultiTerm> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=0:
slMultiTerm> unexpected DECIDE
slMultiTerm> expecting other text or number

slAKA base> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=0:
slAKA base> unexpected DECIDE
slAKA base> expecting other text or number

$*|> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=0:
$*|> unexpected DECIDE
$*|> expecting other text or number

slAKA> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=0:
slAKA> unexpected DECIDE
slAKA> expecting other text or number

pAKA> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pAKA> MATCH (EERR): <EMPTY>
pAKA> ERROR:
pAKA> offset=0:
pAKA> unexpected DECIDE
pAKA> expecting other text or number

pMultiTermAka> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pMultiTermAka> MATCH (EERR): <EMPTY>
pMultiTermAka> ERROR:
pMultiTermAka> offset=0:
pMultiTermAka> unexpected DECIDE
pMultiTermAka> expecting other text or number

manyIndentation/leaf?> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
manyIndentation/leaf?> MATCH (EERR): <EMPTY>
manyIndentation/leaf?> ERROR:
manyIndentation/leaf?> offset=0:
manyIndentation/leaf?> unexpected DECIDE
manyIndentation/leaf?> expecting other text or number

***** / manyIndentation/deeper; calling someIndentation                                                             :1_1:Decide:
****** / someIndentation                                                                                           :1_1:Decide:
******* / myindented: consuming GoDeeper                                                                          :1_1:Decide:
myindented: consuming GoDeeper> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=0:
myindented: consuming GoDeeper> unexpected DECIDE
myindented: consuming GoDeeper> expecting (

someIndentation> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=0:
someIndentation> unexpected DECIDE
someIndentation> expecting (

manyIndentation/deeper; calling someIndentation> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
manyIndentation/deeper; calling someIndentation> MATCH (EERR): <EMPTY>
manyIndentation/deeper; calling someIndentation> ERROR:
manyIndentation/deeper; calling someIndentation> offset=0:
manyIndentation/deeper; calling someIndentation> unexpected DECIDE
manyIndentation/deeper; calling someIndentation> expecting (

calling myindented pNameParens> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
calling myindented pNameParens> MATCH (EERR): <EMPTY>
calling myindented pNameParens> ERROR:
calling myindented pNameParens> offset=0:
calling myindented pNameParens> unexpected DECIDE
calling myindented pNameParens> expecting ( or other text or number

pConstitutiveRule> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pConstitutiveRule> MATCH (EERR): <EMPTY>
pConstitutiveRule> ERROR:
pConstitutiveRule> offset=0:
pConstitutiveRule> unexpected DECIDE
pConstitutiveRule> expecting (, other text or number, or §

*** / pScenarioRule                                                                                                   :1_1:Decide:
**** / pRuleLabel                                                                                                    :1_1:Decide:
***** / $>|                                                                                                         :1_1:Decide:
$>|> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected DECIDE
$>|> expecting §

pRuleLabel> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pRuleLabel> MATCH (EERR): <EMPTY>
pRuleLabel> ERROR:
pRuleLabel> offset=0:
pRuleLabel> unexpected DECIDE
pRuleLabel> expecting §

**** / pExpect                                                                                                       :1_1:Decide:
pExpect> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pExpect> MATCH (EERR): <EMPTY>
pExpect> ERROR:
pExpect> offset=0:
pExpect> unexpected DECIDE
pExpect> expecting EXPECT

pScenarioRule> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pScenarioRule> MATCH (EERR): <EMPTY>
pScenarioRule> ERROR:
pScenarioRule> offset=0:
pScenarioRule> unexpected DECIDE
pScenarioRule> expecting EXPECT, GIVEN, or §

*** / pHornlike                                                                                                       :1_1:Decide:
**** / pSrcRef                                                                                                       :1_1:Decide:
***** / pRuleLabel                                                                                                  :1_1:Decide:
****** / $>|                                                                                                       :1_1:Decide:
$>|> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected DECIDE
$>|> expecting §

pRuleLabel> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pRuleLabel> MATCH (EERR): <EMPTY>
pRuleLabel> ERROR:
pRuleLabel> offset=0:
pRuleLabel> unexpected DECIDE
pRuleLabel> expecting §

pSrcRef> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pSrcRef> MATCH (EOK): <EMPTY>
pSrcRef> VALUE: ((Nothing,Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 1, srccol = 1, version = Nothing})),[])

**** \ pSrcRef has returned (Nothing,Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 1, srccol = 1, version = Nothing})) :1_1:Decide:
**** / pHornlike / permute                                                                                           :1_1:Decide:
***** / whenCase                                                                                                    :1_1:Decide:
****** / whenMeansIf                                                                                               :1_1:Decide:
whenMeansIf> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
whenMeansIf> MATCH (EERR): <EMPTY>
whenMeansIf> ERROR:
whenMeansIf> offset=0:
whenMeansIf> unexpected DECIDE
whenMeansIf> expecting IF, MEANS, or WHEN

****** / Otherwise                                                                                                 :1_1:Decide:
Otherwise> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
Otherwise> MATCH (EERR): <EMPTY>
Otherwise> ERROR:
Otherwise> offset=0:
Otherwise> unexpected DECIDE
Otherwise> expecting OTHERWISE

whenCase> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
whenCase> MATCH (EERR): <EMPTY>
whenCase> ERROR:
whenCase> offset=0:
whenCase> unexpected DECIDE
whenCase> expecting IF, MEANS, OTHERWISE, or WHEN

***** / pHornlike/uponLimb                                                                                          :1_1:Decide:
****** / preambleParamText:[Upon]                                                                                  :1_1:Decide:
******* / $>|                                                                                                     :1_1:Decide:
$>|> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected DECIDE
$>|> expecting UPON

preambleParamText:[Upon]> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=0:
preambleParamText:[Upon]> unexpected DECIDE
preambleParamText:[Upon]> expecting UPON

pHornlike/uponLimb> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pHornlike/uponLimb> MATCH (EERR): <EMPTY>
pHornlike/uponLimb> ERROR:
pHornlike/uponLimb> offset=0:
pHornlike/uponLimb> unexpected DECIDE
pHornlike/uponLimb> expecting UPON

***** / whenCase                                                                                                    :1_1:Decide:
****** / whenMeansIf                                                                                               :1_1:Decide:
whenMeansIf> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
whenMeansIf> MATCH (EERR): <EMPTY>
whenMeansIf> ERROR:
whenMeansIf> offset=0:
whenMeansIf> unexpected DECIDE
whenMeansIf> expecting IF, MEANS, or WHEN

****** / Otherwise                                                                                                 :1_1:Decide:
Otherwise> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
Otherwise> MATCH (EERR): <EMPTY>
Otherwise> ERROR:
Otherwise> offset=0:
Otherwise> unexpected DECIDE
Otherwise> expecting OTHERWISE

whenCase> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
whenCase> MATCH (EERR): <EMPTY>
whenCase> ERROR:
whenCase> offset=0:
whenCase> unexpected DECIDE
whenCase> expecting IF, MEANS, OTHERWISE, or WHEN

***** / pHornlike/givenLimb                                                                                         :1_1:Decide:
****** / preambleParamText:[Given]                                                                                 :1_1:Decide:
******* / $>|                                                                                                     :1_1:Decide:
$>|> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=0:
$>|> unexpected DECIDE
$>|> expecting GIVEN

preambleParamText:[Given]> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=0:
preambleParamText:[Given]> unexpected DECIDE
preambleParamText:[Given]> expecting GIVEN

pHornlike/givenLimb> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pHornlike/givenLimb> MATCH (EERR): <EMPTY>
pHornlike/givenLimb> ERROR:
pHornlike/givenLimb> offset=0:
pHornlike/givenLimb> unexpected DECIDE
pHornlike/givenLimb> expecting GIVEN

***** / whenCase                                                                                                    :1_1:Decide:
****** / whenMeansIf                                                                                               :1_1:Decide:
whenMeansIf> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
whenMeansIf> MATCH (EERR): <EMPTY>
whenMeansIf> ERROR:
whenMeansIf> offset=0:
whenMeansIf> unexpected DECIDE
whenMeansIf> expecting IF, MEANS, or WHEN

****** / Otherwise                                                                                                 :1_1:Decide:
Otherwise> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
Otherwise> MATCH (EERR): <EMPTY>
Otherwise> ERROR:
Otherwise> offset=0:
Otherwise> unexpected DECIDE
Otherwise> expecting OTHERWISE

whenCase> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
whenCase> MATCH (EERR): <EMPTY>
whenCase> ERROR:
whenCase> offset=0:
whenCase> unexpected DECIDE
whenCase> expecting IF, MEANS, OTHERWISE, or WHEN

***** / pHornlike/ambitious                                                                                         :1_1:Decide:
****** / $>|                                                                                                       :1_1:Decide:
$>|> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
$>|> MATCH (COK): DECIDE
$>|> VALUE: (Decide,[])

****** \ $>| has returned Decide                                                                                    :1_2:GoDeeper:
****** / |>>/recurse                                                                                                :1_2:GoDeeper:
******* / |>>/recurse                                                                                               :1_2:Other "X":
|>>/recurse> IN: "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( " <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=2:
|>>/recurse> unexpected "X"
|>>/recurse> expecting (

******* / |>>/base                                                                                                  :1_2:Other "X":
******** / slMultiTerm                                                                                             :1_2:Other "X":
********* / someSL                                                                                                :1_2:Other "X":
********** / pNumAsText                                                                                            :1_3:Is:
pNumAsText> IN: IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( "Q" ) ) <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=4:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( " <…>
someSL> MATCH (COK): "X"
someSL> VALUE: ((["X"],0),[])

********* \ someSL has returned (["X"],0)                                                                          :1_3:GoDeeper:
slMultiTerm> IN: "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( " <…>
slMultiTerm> MATCH (COK): "X"
slMultiTerm> VALUE: ((["X"],0),[])

******** \ slMultiTerm has returned (["X"],0)                                                                       :1_3:GoDeeper:
******** > |>>/base got ["X"]                                                                                       :1_3:GoDeeper:
|>>/base> IN: "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( " <…>
|>>/base> MATCH (COK): "X"
|>>/base> VALUE: ((["X"],0),[])

******* \ |>>/base has returned (["X"],0)                                                                            :1_3:GoDeeper:
|>>/recurse> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
|>>/recurse> MATCH (COK): ( "X"
|>>/recurse> VALUE: ((["X"],1),[])

****** \ |>>/recurse has returned (["X"],1)                                                                           :1_3:GoDeeper:
****** / undeepers                                                                                                    :1_3:GoDeeper:
******* > sameLine/undeepers: reached end of line; now need to clear 1 UnDeepers                                     :1_3:GoDeeper:
undeepers> IN: ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( "Q" ) <…>
undeepers> MATCH (EERR): <EMPTY>
undeepers> ERROR:
undeepers> offset=3:
undeepers> unexpected (
undeepers> expecting )

pHornlike/ambitious> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pHornlike/ambitious> MATCH (CERR): DECIDE ( "X"
pHornlike/ambitious> ERROR:
pHornlike/ambitious> offset=3:
pHornlike/ambitious> unexpected (
pHornlike/ambitious> expecting )

***** / pHornlike/someStructure                                                                                     :1_1:Decide:
****** / manyIndentation/leaf?                                                                                      :1_2:GoDeeper:
******* / relPredNextlineWhen                                                                                      :1_2:GoDeeper:
******** / pRelPred optIndentedTuple whenCase                                                                     :1_2:GoDeeper:
********* / optIndentedTuple                                                                                     :1_2:GoDeeper:
********** / optIndented                                                                                        :1_2:GoDeeper:
*********** / pRelPred                                                                                         :1_2:GoDeeper:
************ / slRelPred                                                                                      :1_2:GoDeeper:
************* / nested simpleHorn                                                                            :1_2:GoDeeper:
************** > |^|                                                                                        :1_2:GoDeeper:
************** / $*|                                                                                        :1_2:GoDeeper:
*************** / slMultiTerm                                                                              :1_2:GoDeeper:
**************** / someSL                                                                                 :1_2:GoDeeper:
***************** / pNumAsText                                                                           :1_2:GoDeeper:
pNumAsText> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=1:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=1:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=1:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=1:
$*|> unexpected (
$*|> expecting other text or number

nested simpleHorn> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=1:
nested simpleHorn> unexpected (
nested simpleHorn> expecting other text or number

************* / RPConstraint                                                                                 :1_2:GoDeeper:
************** / $*|                                                                                        :1_2:GoDeeper:
*************** / slMultiTerm                                                                              :1_2:GoDeeper:
**************** / someSL                                                                                 :1_2:GoDeeper:
***************** / pNumAsText                                                                           :1_2:GoDeeper:
pNumAsText> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=1:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=1:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=1:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=1:
$*|> unexpected (
$*|> expecting other text or number

RPConstraint> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=1:
RPConstraint> unexpected (
RPConstraint> expecting other text or number

************* / RPBoolStructR                                                                                :1_2:GoDeeper:
************** / $*|                                                                                        :1_2:GoDeeper:
*************** / slMultiTerm                                                                              :1_2:GoDeeper:
**************** / someSL                                                                                 :1_2:GoDeeper:
***************** / pNumAsText                                                                           :1_2:GoDeeper:
pNumAsText> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=1:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=1:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=1:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=1:
$*|> unexpected (
$*|> expecting other text or number

RPBoolStructR> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=1:
RPBoolStructR> unexpected (
RPBoolStructR> expecting other text or number

************* / RPMT                                                                                         :1_2:GoDeeper:
************** / $*|                                                                                        :1_2:GoDeeper:
*************** / slAKA                                                                                    :1_2:GoDeeper:
**************** / $*|                                                                                    :1_2:GoDeeper:
***************** / slAKA base                                                                           :1_2:GoDeeper:
****************** / slMultiTerm                                                                        :1_2:GoDeeper:
******************* / someSL                                                                           :1_2:GoDeeper:
******************** / pNumAsText                                                                     :1_2:GoDeeper:
pNumAsText> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=1:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=1:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=1:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

slAKA base> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=1:
slAKA base> unexpected (
slAKA base> expecting other text or number

$*|> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=1:
$*|> unexpected (
$*|> expecting other text or number

slAKA> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=1:
slAKA> unexpected (
slAKA> expecting other text or number

$*|> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=1:
$*|> unexpected (
$*|> expecting other text or number

RPMT> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=1:
RPMT> unexpected (
RPMT> expecting other text or number

slRelPred> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=1:
slRelPred> unexpected (
slRelPred> expecting other text or number

pRelPred> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
pRelPred> MATCH (EERR): <EMPTY>
pRelPred> ERROR:
pRelPred> offset=1:
pRelPred> unexpected (
pRelPred> expecting other text or number

optIndented> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
optIndented> MATCH (EERR): <EMPTY>
optIndented> ERROR:
optIndented> offset=1:
optIndented> unexpected (
optIndented> expecting other text or number

optIndentedTuple> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
optIndentedTuple> MATCH (EERR): <EMPTY>
optIndentedTuple> ERROR:
optIndentedTuple> offset=1:
optIndentedTuple> unexpected (
optIndentedTuple> expecting other text or number

pRelPred optIndentedTuple whenCase> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
pRelPred optIndentedTuple whenCase> MATCH (EERR): <EMPTY>
pRelPred optIndentedTuple whenCase> ERROR:
pRelPred optIndentedTuple whenCase> offset=1:
pRelPred optIndentedTuple whenCase> unexpected (
pRelPred optIndentedTuple whenCase> expecting other text or number

relPredNextlineWhen> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
relPredNextlineWhen> MATCH (EERR): <EMPTY>
relPredNextlineWhen> ERROR:
relPredNextlineWhen> offset=1:
relPredNextlineWhen> unexpected (
relPredNextlineWhen> expecting other text or number

******* / relPredSamelineWhen                                                                                      :1_2:GoDeeper:
******** / $*|                                                                                                    :1_2:GoDeeper:
********* / slRelPred                                                                                            :1_2:GoDeeper:
********** / nested simpleHorn                                                                                  :1_2:GoDeeper:
*********** > |^|                                                                                              :1_2:GoDeeper:
*********** / $*|                                                                                              :1_2:GoDeeper:
************ / slMultiTerm                                                                                    :1_2:GoDeeper:
************* / someSL                                                                                       :1_2:GoDeeper:
************** / pNumAsText                                                                                 :1_2:GoDeeper:
pNumAsText> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=1:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=1:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=1:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=1:
$*|> unexpected (
$*|> expecting other text or number

nested simpleHorn> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=1:
nested simpleHorn> unexpected (
nested simpleHorn> expecting other text or number

********** / RPConstraint                                                                                       :1_2:GoDeeper:
*********** / $*|                                                                                              :1_2:GoDeeper:
************ / slMultiTerm                                                                                    :1_2:GoDeeper:
************* / someSL                                                                                       :1_2:GoDeeper:
************** / pNumAsText                                                                                 :1_2:GoDeeper:
pNumAsText> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=1:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=1:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=1:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=1:
$*|> unexpected (
$*|> expecting other text or number

RPConstraint> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=1:
RPConstraint> unexpected (
RPConstraint> expecting other text or number

********** / RPBoolStructR                                                                                      :1_2:GoDeeper:
*********** / $*|                                                                                              :1_2:GoDeeper:
************ / slMultiTerm                                                                                    :1_2:GoDeeper:
************* / someSL                                                                                       :1_2:GoDeeper:
************** / pNumAsText                                                                                 :1_2:GoDeeper:
pNumAsText> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=1:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=1:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=1:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=1:
$*|> unexpected (
$*|> expecting other text or number

RPBoolStructR> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=1:
RPBoolStructR> unexpected (
RPBoolStructR> expecting other text or number

********** / RPMT                                                                                               :1_2:GoDeeper:
*********** / $*|                                                                                              :1_2:GoDeeper:
************ / slAKA                                                                                          :1_2:GoDeeper:
************* / $*|                                                                                          :1_2:GoDeeper:
************** / slAKA base                                                                                 :1_2:GoDeeper:
*************** / slMultiTerm                                                                              :1_2:GoDeeper:
**************** / someSL                                                                                 :1_2:GoDeeper:
***************** / pNumAsText                                                                           :1_2:GoDeeper:
pNumAsText> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=1:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=1:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=1:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

slAKA base> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=1:
slAKA base> unexpected (
slAKA base> expecting other text or number

$*|> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=1:
$*|> unexpected (
$*|> expecting other text or number

slAKA> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=1:
slAKA> unexpected (
slAKA> expecting other text or number

$*|> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=1:
$*|> unexpected (
$*|> expecting other text or number

RPMT> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=1:
RPMT> unexpected (
RPMT> expecting other text or number

slRelPred> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=1:
slRelPred> unexpected (
slRelPred> expecting other text or number

$*|> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=1:
$*|> unexpected (
$*|> expecting other text or number

relPredSamelineWhen> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
relPredSamelineWhen> MATCH (EERR): <EMPTY>
relPredSamelineWhen> ERROR:
relPredSamelineWhen> offset=1:
relPredSamelineWhen> unexpected (
relPredSamelineWhen> expecting other text or number

manyIndentation/leaf?> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
manyIndentation/leaf?> MATCH (EERR): <EMPTY>
manyIndentation/leaf?> ERROR:
manyIndentation/leaf?> offset=1:
manyIndentation/leaf?> unexpected (
manyIndentation/leaf?> expecting other text or number

****** / manyIndentation/deeper; calling someIndentation                                                            :1_2:GoDeeper:
******* / someIndentation                                                                                          :1_2:GoDeeper:
******** / myindented: consuming GoDeeper                                                                         :1_2:GoDeeper:
myindented: consuming GoDeeper> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
myindented: consuming GoDeeper> MATCH (COK): (
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

******** \ myindented: consuming GoDeeper has returned GoDeeper                                                    :1_2:Other "X":
******** / manyIndentation/leaf?                                                                                   :1_2:Other "X":
********* / relPredNextlineWhen                                                                                   :1_2:Other "X":
********** / pRelPred optIndentedTuple whenCase                                                                  :1_2:Other "X":
*********** / optIndentedTuple                                                                                  :1_2:Other "X":
************ / optIndented                                                                                     :1_2:Other "X":
************* / pRelPred                                                                                      :1_2:Other "X":
************** / slRelPred                                                                                   :1_2:Other "X":
*************** / nested simpleHorn                                                                         :1_2:Other "X":
**************** > |^|                                                                                     :1_2:Other "X":
**************** / $*|                                                                                     :1_2:Other "X":
***************** / slMultiTerm                                                                           :1_2:Other "X":
****************** / someSL                                                                              :1_2:Other "X":
******************* / pNumAsText                                                                          :1_3:Is:
pNumAsText> IN: IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( "Q" ) ) <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=4:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( " <…>
someSL> MATCH (COK): "X"
someSL> VALUE: ((["X"],0),[])

****************** \ someSL has returned (["X"],0)                                                        :1_3:GoDeeper:
slMultiTerm> IN: "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( " <…>
slMultiTerm> MATCH (COK): "X"
slMultiTerm> VALUE: ((["X"],0),[])

***************** \ slMultiTerm has returned (["X"],0)                                                     :1_3:GoDeeper:
$*|> IN: "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( " <…>
$*|> MATCH (COK): "X"
$*|> VALUE: ((["X"],0),[])

**************** \ $*| has returned (["X"],0)                                                               :1_3:GoDeeper:
**************** / |^| deeps                                                                                :1_3:GoDeeper:
|^| deeps> IN: ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( "Q" ) <…>
|^| deeps> MATCH (COK): (
|^| deeps> VALUE: (([()],1),[])

**************** \ |^| deeps has returned ([()],1)                                                           :1_3:Is:
nested simpleHorn> IN: "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( " <…>
nested simpleHorn> MATCH (CERR): "X" (
nested simpleHorn> ERROR:
nested simpleHorn> offset=4:
nested simpleHorn> unexpected IS
nested simpleHorn> expecting ( or MEANS

*************** / RPConstraint                                                                              :1_2:Other "X":
**************** / $*|                                                                                     :1_2:Other "X":
***************** / slMultiTerm                                                                           :1_2:Other "X":
****************** / someSL                                                                              :1_2:Other "X":
******************* / pNumAsText                                                                          :1_3:Is:
pNumAsText> IN: IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( "Q" ) ) <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=4:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( " <…>
someSL> MATCH (COK): "X"
someSL> VALUE: ((["X"],0),[])

****************** \ someSL has returned (["X"],0)                                                        :1_3:GoDeeper:
slMultiTerm> IN: "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( " <…>
slMultiTerm> MATCH (COK): "X"
slMultiTerm> VALUE: ((["X"],0),[])

***************** \ slMultiTerm has returned (["X"],0)                                                     :1_3:GoDeeper:
$*|> IN: "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( " <…>
$*|> MATCH (COK): "X"
$*|> VALUE: ((["X"],0),[])

**************** \ $*| has returned (["X"],0)                                                               :1_3:GoDeeper:
**************** / |>| calling $>>                                                                          :1_3:GoDeeper:
***************** / |>>/recurse                                                                            :1_3:GoDeeper:
****************** / |>>/recurse                                                                           :1_3:Is:
|>>/recurse> IN: IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( "Q" ) ) <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=4:
|>>/recurse> unexpected IS
|>>/recurse> expecting (

****************** / |>>/base                                                                              :1_3:Is:
******************* > |>>/base got RPis                                                                    :1_4:GoDeeper:
|>>/base> IN: IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( "Q" ) ) <…>
|>>/base> MATCH (COK): IS
|>>/base> VALUE: ((RPis,0),[])

****************** \ |>>/base has returned (RPis,0)                                                         :1_4:GoDeeper:
|>>/recurse> IN: ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( "Q" ) <…>
|>>/recurse> MATCH (COK): ( IS
|>>/recurse> VALUE: ((RPis,1),[])

***************** \ |>>/recurse has returned (RPis,1)                                                        :1_4:GoDeeper:
|>| calling $>>> IN: ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( "Q" ) <…>
|>| calling $>>> MATCH (COK): ( IS
|>| calling $>>> VALUE: ((RPis,1),[])

**************** \ |>| calling $>> has returned (RPis,1)                                                      :1_4:GoDeeper:
**************** / |>>/recurse                                                                                :1_4:GoDeeper:
***************** / |>>/recurse                                                                               :1_4:Other "Y":
|>>/recurse> IN: "Y" ) ) ) WHEN ( "Z" ( IS ( "Q" ) ) ) AN <…>
|>>/recurse> MATCH (EERR): <EMPTY>
|>>/recurse> ERROR:
|>>/recurse> offset=6:
|>>/recurse> unexpected "Y"
|>>/recurse> expecting (

***************** / |>>/base                                                                                  :1_4:Other "Y":
****************** / slMultiTerm                                                                             :1_4:Other "Y":
******************* / someSL                                                                                :1_4:Other "Y":
someSL> IN: "Y" ) ) ) WHEN ( "Z" ( IS ( "Q" ) ) ) AN <…>
someSL> MATCH (COK): "Y"
someSL> VALUE: ((["Y"],0),[])

******************* \ someSL has returned (["Y"],0)                                                      :2_2:UnDeeper:
slMultiTerm> IN: "Y" ) ) ) WHEN ( "Z" ( IS ( "Q" ) ) ) AN <…>
slMultiTerm> MATCH (COK): "Y"
slMultiTerm> VALUE: ((["Y"],0),[])

****************** \ slMultiTerm has returned (["Y"],0)                                                   :2_2:UnDeeper:
****************** > |>>/base got ["Y"]                                                                   :2_2:UnDeeper:
|>>/base> IN: "Y" ) ) ) WHEN ( "Z" ( IS ( "Q" ) ) ) AN <…>
|>>/base> MATCH (COK): "Y"
|>>/base> VALUE: ((["Y"],0),[])

***************** \ |>>/base has returned (["Y"],0)                                                        :2_2:UnDeeper:
|>>/recurse> IN: ( "Y" ) ) ) WHEN ( "Z" ( IS ( "Q" ) ) )  <…>
|>>/recurse> MATCH (COK): ( "Y"
|>>/recurse> VALUE: ((["Y"],1),[])

**************** \ |>>/recurse has returned (["Y"],1)                                                       :2_2:UnDeeper:
RPConstraint> IN: "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( " <…>
RPConstraint> MATCH (COK): "X" ( IS ( "Y"
RPConstraint> VALUE: ((RPConstraint ["X"] RPis ["Y"],2),[])

*************** \ RPConstraint has returned (RPConstraint ["X"] RPis ["Y"],2)                                :2_2:UnDeeper:
slRelPred> IN: "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( " <…>
slRelPred> MATCH (COK): "X" ( IS ( "Y"
slRelPred> VALUE: ((RPConstraint ["X"] RPis ["Y"],2),[])

************** \ slRelPred has returned (RPConstraint ["X"] RPis ["Y"],2)                                     :2_2:UnDeeper:
************** / undeepers                                                                                    :2_2:UnDeeper:
*************** > sameLine/undeepers: reached end of line; now need to clear 2 UnDeepers                     :2_2:UnDeeper:
*************** > sameLine: success!                                                                             :2_4:UnDeeper:
undeepers> IN: ) ) ) WHEN ( "Z" ( IS ( "Q" ) ) ) AND (  <…>
undeepers> MATCH (COK): ) )
undeepers> VALUE: ((),[])

************** \ undeepers has returned ()                                                                        :2_4:UnDeeper:
pRelPred> IN: "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( " <…>
pRelPred> MATCH (COK): "X" ( IS ( "Y" ) )
pRelPred> VALUE: (RPConstraint ["X"] RPis ["Y"],[])

************* \ pRelPred has returned RPConstraint ["X"] RPis ["Y"]                                                :2_4:UnDeeper:
************* / someIndentation                                                                                    :2_4:UnDeeper:
************** / myindented: consuming GoDeeper                                                                   :2_4:UnDeeper:
myindented: consuming GoDeeper> IN: ) WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P"  <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=9:
myindented: consuming GoDeeper> unexpected )
myindented: consuming GoDeeper> expecting (

someIndentation> IN: ) WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P"  <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=9:
someIndentation> unexpected )
someIndentation> expecting (

optIndented> IN: "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( " <…>
optIndented> MATCH (COK): "X" ( IS ( "Y" ) )
optIndented> VALUE: ((RPConstraint ["X"] RPis ["Y"],Nothing),[])

************ \ optIndented has returned (RPConstraint ["X"] RPis ["Y"],Nothing)                                     :2_4:UnDeeper:
optIndentedTuple> IN: "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( " <…>
optIndentedTuple> MATCH (COK): "X" ( IS ( "Y" ) )
optIndentedTuple> VALUE: ((RPConstraint ["X"] RPis ["Y"],Nothing),[])

*********** \ optIndentedTuple has returned (RPConstraint ["X"] RPis ["Y"],Nothing)                                  :2_4:UnDeeper:
pRelPred optIndentedTuple whenCase> IN: "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( " <…>
pRelPred optIndentedTuple whenCase> MATCH (COK): "X" ( IS ( "Y" ) )
pRelPred optIndentedTuple whenCase> VALUE: ((RPConstraint ["X"] RPis ["Y"],Nothing),[])

********** \ pRelPred optIndentedTuple whenCase has returned (RPConstraint ["X"] RPis ["Y"],Nothing)                  :2_4:UnDeeper:
relPredNextlineWhen> IN: "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( " <…>
relPredNextlineWhen> MATCH (COK): "X" ( IS ( "Y" ) )
relPredNextlineWhen> VALUE: ((RPConstraint ["X"] RPis ["Y"],Nothing),[])

********* \ relPredNextlineWhen has returned (RPConstraint ["X"] RPis ["Y"],Nothing)                                   :2_4:UnDeeper:
manyIndentation/leaf?> IN: "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( " <…>
manyIndentation/leaf?> MATCH (COK): "X" ( IS ( "Y" ) )
manyIndentation/leaf?> VALUE: ((RPConstraint ["X"] RPis ["Y"],Nothing),[])

******** \ manyIndentation/leaf? has returned (RPConstraint ["X"] RPis ["Y"],Nothing)                                   :2_4:UnDeeper:
******** / myindented: consuming UnDeeper                                                                               :2_4:UnDeeper:
myindented: consuming UnDeeper> IN: ) WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P"  <…>
myindented: consuming UnDeeper> MATCH (COK): )
myindented: consuming UnDeeper> VALUE: (UnDeeper,[])

******** \ myindented: consuming UnDeeper has returned UnDeeper                                                  :2_1:When:
someIndentation> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
someIndentation> MATCH (COK): ( "X" ( IS ( "Y" ) ) )
someIndentation> VALUE: ((RPConstraint ["X"] RPis ["Y"],Nothing),[])

******* \ someIndentation has returned (RPConstraint ["X"] RPis ["Y"],Nothing)                                    :2_1:When:
manyIndentation/deeper; calling someIndentation> IN: ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" ( IS ( <…>
manyIndentation/deeper; calling someIndentation> MATCH (COK): ( "X" ( IS ( "Y" ) ) )
manyIndentation/deeper; calling someIndentation> VALUE: ((RPConstraint ["X"] RPis ["Y"],Nothing),[])

****** \ manyIndentation/deeper; calling someIndentation has returned (RPConstraint ["X"] RPis ["Y"],Nothing)      :2_1:When:
pHornlike/someStructure> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pHornlike/someStructure> MATCH (COK): DECIDE ( "X" ( IS ( "Y" ) ) )
pHornlike/someStructure> VALUE: ((Just Decide,["X"],[HC2 {hHead = RPConstraint ["X"] RPis ["Y"], hBody = Nothing}]),[])

***** \ pHornlike/someStructure has returned (Just Decide,["X"],[HC2 {hHead = RPConstraint ["X"] RPis ["Y"], hBody = Nothing}]) :2_1:When:
***** / whenCase                                                                                                    :2_1:When:
****** / whenMeansIf                                                                                               :2_1:When:
whenMeansIf> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
whenMeansIf> MATCH (COK): WHEN
whenMeansIf> VALUE: (When,[])

****** \ whenMeansIf has returned When                                                                              :2_2:GoDeeper:
****** / pBSR                                                                                                       :2_2:GoDeeper:
******* / ppp inner                                                                                                :2_2:GoDeeper:
******** / expression                                                                                             :2_2:GoDeeper:
********* / labelPrefix                                                                                          :2_2:GoDeeper:
labelPrefix> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=11:
labelPrefix> unexpected (
labelPrefix> expecting Other text

********* / term p                                                                                               :2_2:GoDeeper:
********** / term p/notLabelTerm                                                                                :2_2:GoDeeper:
*********** / term p/2:someIndentation expr p                                                                  :2_2:GoDeeper:
************ / someIndentation                                                                                :2_2:GoDeeper:
************* / myindented: consuming GoDeeper                                                               :2_2:GoDeeper:
myindented: consuming GoDeeper> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
myindented: consuming GoDeeper> MATCH (COK): (
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

************* \ myindented: consuming GoDeeper has returned GoDeeper                                          :2_2:Other "Z":
************* / manyIndentation/leaf?                                                                         :2_2:Other "Z":
************** / expression                                                                                  :2_2:Other "Z":
*************** / labelPrefix                                                                               :2_2:Other "Z":
labelPrefix> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
labelPrefix> MATCH (COK): "Z"
labelPrefix> VALUE: ("Z",[])

*************** \ labelPrefix has returned "Z"                                                               :2_3:GoDeeper:
*************** / term p                                                                                     :2_3:GoDeeper:
**************** / term p/notLabelTerm                                                                      :2_3:GoDeeper:
***************** / term p/2:someIndentation expr p                                                        :2_3:GoDeeper:
****************** / someIndentation                                                                      :2_3:GoDeeper:
******************* / myindented: consuming GoDeeper                                                     :2_3:GoDeeper:
myindented: consuming GoDeeper> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
myindented: consuming GoDeeper> MATCH (COK): (
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

******************* \ myindented: consuming GoDeeper has returned GoDeeper                                :2_3:Is:
******************* / manyIndentation/leaf?                                                               :2_3:Is:
******************** / expression                                                                        :2_3:Is:
********************* / labelPrefix                                                                     :2_3:Is:
labelPrefix> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=14:
labelPrefix> unexpected IS
labelPrefix> expecting Other text

********************* / term p                                                                          :2_3:Is:
********************** / term p/notLabelTerm                                                           :2_3:Is:
*********************** / term p/2:someIndentation expr p                                             :2_3:Is:
************************ / someIndentation                                                           :2_3:Is:
************************* / myindented: consuming GoDeeper                                          :2_3:Is:
myindented: consuming GoDeeper> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=14:
myindented: consuming GoDeeper> unexpected IS
myindented: consuming GoDeeper> expecting (

someIndentation> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting (

term p/2:someIndentation expr p> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p/2:someIndentation expr p> MATCH (EERR): <EMPTY>
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=14:
term p/2:someIndentation expr p> unexpected IS
term p/2:someIndentation expr p> expecting (

*********************** / term p/3:plain p                                                            :2_3:Is:
************************ / pRelPred                                                                  :2_3:Is:
************************* / slRelPred                                                               :2_3:Is:
************************** / nested simpleHorn                                                     :2_3:Is:
*************************** > |^|                                                                 :2_3:Is:
*************************** / $*|                                                                 :2_3:Is:
**************************** / slMultiTerm                                                       :2_3:Is:
***************************** / someSL                                                          :2_3:Is:
****************************** / pNumAsText                                                    :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

nested simpleHorn> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=14:
nested simpleHorn> unexpected IS
nested simpleHorn> expecting other text or number

************************** / RPConstraint                                                          :2_3:Is:
*************************** / $*|                                                                 :2_3:Is:
**************************** / slMultiTerm                                                       :2_3:Is:
***************************** / someSL                                                          :2_3:Is:
****************************** / pNumAsText                                                    :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

RPConstraint> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=14:
RPConstraint> unexpected IS
RPConstraint> expecting other text or number

************************** / RPBoolStructR                                                         :2_3:Is:
*************************** / $*|                                                                 :2_3:Is:
**************************** / slMultiTerm                                                       :2_3:Is:
***************************** / someSL                                                          :2_3:Is:
****************************** / pNumAsText                                                    :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

RPBoolStructR> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=14:
RPBoolStructR> unexpected IS
RPBoolStructR> expecting other text or number

************************** / RPMT                                                                  :2_3:Is:
*************************** / $*|                                                                 :2_3:Is:
**************************** / slAKA                                                             :2_3:Is:
***************************** / $*|                                                             :2_3:Is:
****************************** / slAKA base                                                    :2_3:Is:
******************************* / slMultiTerm                                                 :2_3:Is:
******************************** / someSL                                                    :2_3:Is:
********************************* / pNumAsText                                              :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

slAKA base> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=14:
slAKA base> unexpected IS
slAKA base> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

slAKA> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=14:
slAKA> unexpected IS
slAKA> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

RPMT> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=14:
RPMT> unexpected IS
RPMT> expecting other text or number

slRelPred> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=14:
slRelPred> unexpected IS
slRelPred> expecting other text or number

pRelPred> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pRelPred> MATCH (EERR): <EMPTY>
pRelPred> ERROR:
pRelPred> offset=14:
pRelPred> unexpected IS
pRelPred> expecting other text or number

term p/3:plain p> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p/3:plain p> MATCH (EERR): <EMPTY>
term p/3:plain p> ERROR:
term p/3:plain p> offset=14:
term p/3:plain p> unexpected IS
term p/3:plain p> expecting other text or number

term p/notLabelTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p/notLabelTerm> MATCH (EERR): <EMPTY>
term p/notLabelTerm> ERROR:
term p/notLabelTerm> offset=14:
term p/notLabelTerm> unexpected IS
term p/notLabelTerm> expecting ( or term

term p> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p> MATCH (EERR): <EMPTY>
term p> ERROR:
term p> offset=14:
term p> unexpected IS
term p> expecting ( or term

expression> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
expression> MATCH (EERR): <EMPTY>
expression> ERROR:
expression> offset=14:
expression> unexpected IS
expression> expecting expression

manyIndentation/leaf?> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
manyIndentation/leaf?> MATCH (EERR): <EMPTY>
manyIndentation/leaf?> ERROR:
manyIndentation/leaf?> offset=14:
manyIndentation/leaf?> unexpected IS
manyIndentation/leaf?> expecting expression

******************* / manyIndentation/deeper; calling someIndentation                                     :2_3:Is:
******************** / someIndentation                                                                   :2_3:Is:
********************* / myindented: consuming GoDeeper                                                  :2_3:Is:
myindented: consuming GoDeeper> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=14:
myindented: consuming GoDeeper> unexpected IS
myindented: consuming GoDeeper> expecting (

someIndentation> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting (

manyIndentation/deeper; calling someIndentation> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
manyIndentation/deeper; calling someIndentation> MATCH (EERR): <EMPTY>
manyIndentation/deeper; calling someIndentation> ERROR:
manyIndentation/deeper; calling someIndentation> offset=14:
manyIndentation/deeper; calling someIndentation> unexpected IS
manyIndentation/deeper; calling someIndentation> expecting (

someIndentation> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someIndentation> MATCH (CERR): (
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting ( or expression

term p/2:someIndentation expr p> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p/2:someIndentation expr p> MATCH (CERR): (
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=14:
term p/2:someIndentation expr p> unexpected IS
term p/2:someIndentation expr p> expecting ( or expression

***************** / term p/3:plain p                                                                       :2_3:GoDeeper:
****************** / pRelPred                                                                             :2_3:GoDeeper:
******************* / slRelPred                                                                          :2_3:GoDeeper:
******************** / nested simpleHorn                                                                :2_3:GoDeeper:
********************* > |^|                                                                            :2_3:GoDeeper:
********************* / $*|                                                                            :2_3:GoDeeper:
********************** / slMultiTerm                                                                  :2_3:GoDeeper:
*********************** / someSL                                                                     :2_3:GoDeeper:
************************ / pNumAsText                                                               :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

nested simpleHorn> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=13:
nested simpleHorn> unexpected (
nested simpleHorn> expecting other text or number

******************** / RPConstraint                                                                     :2_3:GoDeeper:
********************* / $*|                                                                            :2_3:GoDeeper:
********************** / slMultiTerm                                                                  :2_3:GoDeeper:
*********************** / someSL                                                                     :2_3:GoDeeper:
************************ / pNumAsText                                                               :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

RPConstraint> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=13:
RPConstraint> unexpected (
RPConstraint> expecting other text or number

******************** / RPBoolStructR                                                                    :2_3:GoDeeper:
********************* / $*|                                                                            :2_3:GoDeeper:
********************** / slMultiTerm                                                                  :2_3:GoDeeper:
*********************** / someSL                                                                     :2_3:GoDeeper:
************************ / pNumAsText                                                               :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

RPBoolStructR> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=13:
RPBoolStructR> unexpected (
RPBoolStructR> expecting other text or number

******************** / RPMT                                                                             :2_3:GoDeeper:
********************* / $*|                                                                            :2_3:GoDeeper:
********************** / slAKA                                                                        :2_3:GoDeeper:
*********************** / $*|                                                                        :2_3:GoDeeper:
************************ / slAKA base                                                               :2_3:GoDeeper:
************************* / slMultiTerm                                                            :2_3:GoDeeper:
************************** / someSL                                                               :2_3:GoDeeper:
*************************** / pNumAsText                                                         :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

slAKA base> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=13:
slAKA base> unexpected (
slAKA base> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

slAKA> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=13:
slAKA> unexpected (
slAKA> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

RPMT> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=13:
RPMT> unexpected (
RPMT> expecting other text or number

slRelPred> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=13:
slRelPred> unexpected (
slRelPred> expecting other text or number

pRelPred> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pRelPred> MATCH (EERR): <EMPTY>
pRelPred> ERROR:
pRelPred> offset=13:
pRelPred> unexpected (
pRelPred> expecting other text or number

term p/3:plain p> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p/3:plain p> MATCH (EERR): <EMPTY>
term p/3:plain p> ERROR:
term p/3:plain p> offset=13:
term p/3:plain p> unexpected (
term p/3:plain p> expecting other text or number

term p/notLabelTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p/notLabelTerm> MATCH (EERR): <EMPTY>
term p/notLabelTerm> ERROR:
term p/notLabelTerm> offset=14:
term p/notLabelTerm> unexpected IS
term p/notLabelTerm> expecting ( or expression

term p> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p> MATCH (EERR): <EMPTY>
term p> ERROR:
term p> offset=14:
term p> unexpected IS
term p> expecting ( or expression

expression> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
expression> MATCH (CERR): "Z"
expression> ERROR:
expression> offset=14:
expression> unexpected IS
expression> expecting (, NOT, or expression

manyIndentation/leaf?> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
manyIndentation/leaf?> MATCH (EERR): <EMPTY>
manyIndentation/leaf?> ERROR:
manyIndentation/leaf?> offset=14:
manyIndentation/leaf?> unexpected IS
manyIndentation/leaf?> expecting (, NOT, or expression

************* / manyIndentation/deeper; calling someIndentation                                               :2_2:Other "Z":
************** / someIndentation                                                                             :2_2:Other "Z":
*************** / myindented: consuming GoDeeper                                                            :2_2:Other "Z":
myindented: consuming GoDeeper> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=12:
myindented: consuming GoDeeper> unexpected "Z"
myindented: consuming GoDeeper> expecting (

someIndentation> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=12:
someIndentation> unexpected "Z"
someIndentation> expecting (

manyIndentation/deeper; calling someIndentation> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
manyIndentation/deeper; calling someIndentation> MATCH (EERR): <EMPTY>
manyIndentation/deeper; calling someIndentation> ERROR:
manyIndentation/deeper; calling someIndentation> offset=12:
manyIndentation/deeper; calling someIndentation> unexpected "Z"
manyIndentation/deeper; calling someIndentation> expecting (

someIndentation> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someIndentation> MATCH (CERR): (
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting (, NOT, or expression

term p/2:someIndentation expr p> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p/2:someIndentation expr p> MATCH (CERR): (
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=14:
term p/2:someIndentation expr p> unexpected IS
term p/2:someIndentation expr p> expecting (, NOT, or expression

*********** / term p/3:plain p                                                                                 :2_2:GoDeeper:
************ / pRelPred                                                                                       :2_2:GoDeeper:
************* / slRelPred                                                                                    :2_2:GoDeeper:
************** / nested simpleHorn                                                                          :2_2:GoDeeper:
*************** > |^|                                                                                      :2_2:GoDeeper:
*************** / $*|                                                                                      :2_2:GoDeeper:
**************** / slMultiTerm                                                                            :2_2:GoDeeper:
***************** / someSL                                                                               :2_2:GoDeeper:
****************** / pNumAsText                                                                         :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

nested simpleHorn> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=11:
nested simpleHorn> unexpected (
nested simpleHorn> expecting other text or number

************** / RPConstraint                                                                               :2_2:GoDeeper:
*************** / $*|                                                                                      :2_2:GoDeeper:
**************** / slMultiTerm                                                                            :2_2:GoDeeper:
***************** / someSL                                                                               :2_2:GoDeeper:
****************** / pNumAsText                                                                         :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

RPConstraint> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=11:
RPConstraint> unexpected (
RPConstraint> expecting other text or number

************** / RPBoolStructR                                                                              :2_2:GoDeeper:
*************** / $*|                                                                                      :2_2:GoDeeper:
**************** / slMultiTerm                                                                            :2_2:GoDeeper:
***************** / someSL                                                                               :2_2:GoDeeper:
****************** / pNumAsText                                                                         :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

RPBoolStructR> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=11:
RPBoolStructR> unexpected (
RPBoolStructR> expecting other text or number

************** / RPMT                                                                                       :2_2:GoDeeper:
*************** / $*|                                                                                      :2_2:GoDeeper:
**************** / slAKA                                                                                  :2_2:GoDeeper:
***************** / $*|                                                                                  :2_2:GoDeeper:
****************** / slAKA base                                                                         :2_2:GoDeeper:
******************* / slMultiTerm                                                                      :2_2:GoDeeper:
******************** / someSL                                                                         :2_2:GoDeeper:
********************* / pNumAsText                                                                   :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

slAKA base> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=11:
slAKA base> unexpected (
slAKA base> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

slAKA> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=11:
slAKA> unexpected (
slAKA> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

RPMT> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=11:
RPMT> unexpected (
RPMT> expecting other text or number

slRelPred> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=11:
slRelPred> unexpected (
slRelPred> expecting other text or number

pRelPred> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pRelPred> MATCH (EERR): <EMPTY>
pRelPred> ERROR:
pRelPred> offset=11:
pRelPred> unexpected (
pRelPred> expecting other text or number

term p/3:plain p> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p/3:plain p> MATCH (EERR): <EMPTY>
term p/3:plain p> ERROR:
term p/3:plain p> offset=11:
term p/3:plain p> unexpected (
term p/3:plain p> expecting other text or number

term p/notLabelTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p/notLabelTerm> MATCH (EERR): <EMPTY>
term p/notLabelTerm> ERROR:
term p/notLabelTerm> offset=14:
term p/notLabelTerm> unexpected IS
term p/notLabelTerm> expecting (, NOT, or expression

term p> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p> MATCH (EERR): <EMPTY>
term p> ERROR:
term p> offset=14:
term p> unexpected IS
term p> expecting (, NOT, or expression

expression> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
expression> MATCH (EERR): <EMPTY>
expression> ERROR:
expression> offset=14:
expression> unexpected IS
expression> expecting expression

ppp inner> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
ppp inner> MATCH (EERR): <EMPTY>
ppp inner> ERROR:
ppp inner> offset=14:
ppp inner> unexpected IS
ppp inner> expecting expression

******* / withPrePost                                                                                              :2_2:GoDeeper:
******** > |<* starting                                                                                           :2_2:GoDeeper:
******** / $*|                                                                                                    :2_2:GoDeeper:
********* / pre part                                                                                             :2_2:GoDeeper:
********** / aboveNextLineKeyword                                                                                :2_2:Other "Z":
*********** / expectUnDeepers                                                                                   :2_2:Other "Z":
************ / pNumAsText                                                                                       :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
expectUnDeepers> MATCH (CERR): "Z" (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
aboveNextLineKeyword> MATCH (CERR): "Z" (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                       :2_2:Other "Z":
********** / aboveNextLineKeyword                                                                                 :2_3:GoDeeper:
*********** / expectUnDeepers                                                                                    :2_3:GoDeeper:
************ / pNumAsText                                                                                       :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
expectUnDeepers> MATCH (CERR): (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
aboveNextLineKeyword> MATCH (CERR): (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                        :2_3:GoDeeper:
********** / aboveNextLineKeyword                                                                                  :2_3:Is:
*********** / expectUnDeepers                                                                                     :2_3:Is:
************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
expectUnDeepers> MATCH (EERR): <EMPTY>
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
aboveNextLineKeyword> MATCH (EERR): <EMPTY>
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                         :2_3:Is:
pre part> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pre part> MATCH (CERR): (
pre part> ERROR:
pre part> offset=14:
pre part> unexpected IS
pre part> expecting (, ), Other text, or other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (CERR): (
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting (, ), Other text, or other text or number

withPrePost> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
withPrePost> MATCH (CERR): (
withPrePost> ERROR:
withPrePost> offset=14:
withPrePost> unexpected IS
withPrePost> expecting (, ), Other text, or other text or number

******* / withPreOnly                                                                                              :2_2:GoDeeper:
******** / $*|                                                                                                    :2_2:GoDeeper:
********* / pre part                                                                                             :2_2:GoDeeper:
********** / aboveNextLineKeyword                                                                                :2_2:Other "Z":
*********** / expectUnDeepers                                                                                   :2_2:Other "Z":
************ / pNumAsText                                                                                       :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
expectUnDeepers> MATCH (CERR): "Z" (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
aboveNextLineKeyword> MATCH (CERR): "Z" (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                       :2_2:Other "Z":
********** / aboveNextLineKeyword                                                                                 :2_3:GoDeeper:
*********** / expectUnDeepers                                                                                    :2_3:GoDeeper:
************ / pNumAsText                                                                                       :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
expectUnDeepers> MATCH (CERR): (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
aboveNextLineKeyword> MATCH (CERR): (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                        :2_3:GoDeeper:
********** / aboveNextLineKeyword                                                                                  :2_3:Is:
*********** / expectUnDeepers                                                                                     :2_3:Is:
************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
expectUnDeepers> MATCH (EERR): <EMPTY>
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
aboveNextLineKeyword> MATCH (EERR): <EMPTY>
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                         :2_3:Is:
pre part> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pre part> MATCH (CERR): (
pre part> ERROR:
pre part> offset=14:
pre part> unexpected IS
pre part> expecting (, ), Other text, or other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (CERR): (
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting (, ), Other text, or other text or number

withPreOnly> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
withPreOnly> MATCH (CERR): (
withPreOnly> ERROR:
withPreOnly> offset=14:
withPreOnly> unexpected IS
withPreOnly> expecting (, ), Other text, or other text or number

pBSR> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pBSR> MATCH (CERR): (
pBSR> ERROR:
pBSR> offset=14:
pBSR> unexpected IS
pBSR> expecting (, ), Other text, expression, or other text or number

****** / Otherwise                                                                                                 :2_1:When:
Otherwise> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
Otherwise> MATCH (EERR): <EMPTY>
Otherwise> ERROR:
Otherwise> offset=10:
Otherwise> unexpected WHEN
Otherwise> expecting OTHERWISE

whenCase> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
whenCase> MATCH (EERR): <EMPTY>
whenCase> ERROR:
whenCase> offset=14:
whenCase> unexpected IS
whenCase> expecting (, ), Other text, expression, or other text or number

pHornlike / permute> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pHornlike / permute> MATCH (COK): DECIDE ( "X" ( IS ( "Y" ) ) )
pHornlike / permute> VALUE: (((Just Decide,["X"],[HC2 {hHead = RPConstraint ["X"] RPis ["Y"], hBody = Nothing}]),Nothing,Nothing,Nothing),[])

**** \ pHornlike / permute has returned ((Just Decide,["X"],[HC2 {hHead = RPConstraint ["X"] RPis ["Y"], hBody = Nothing}]),Nothing,Nothing,Nothing) :2_1:When:
pHornlike> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pHornlike> MATCH (COK): DECIDE ( "X" ( IS ( "Y" ) ) )
pHornlike> VALUE: (Hornlike {name = ["X"], keyword = Decide, given = Nothing, upon = Nothing, clauses = [HC2 {hHead = RPConstraint ["X"] RPis ["Y"], hBody = Nothing}], rlabel = Nothing, lsource = Nothing, srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 1, srccol = 1, version = Nothing}), defaults = [], symtab = []},[])

*** \ pHornlike has returned Hornlike {name = ["X"], keyword = Decide, given = Nothing, upon = Nothing, clauses = [HC2 {hHead = RPConstraint ["X"] RPis ["Y"], hBody = Nothing}], rlabel = Nothing, lsource = Nothing, srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 1, srccol = 1, version = Nothing}), defaults = [], symtab = []} :2_1:When:
pRule> IN: DECIDE ( "X" ( IS ( "Y" ) ) ) WHEN ( "Z" <…>
pRule> MATCH (COK): DECIDE ( "X" ( IS ( "Y" ) ) )
pRule> VALUE: (Hornlike {name = ["X"], keyword = Decide, given = Nothing, upon = Nothing, clauses = [HC2 {hHead = RPConstraint ["X"] RPis ["Y"], hBody = Nothing}], rlabel = Nothing, lsource = Nothing, srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 1, srccol = 1, version = Nothing}), defaults = [], symtab = []},[])

** \ pRule has returned Hornlike {name = ["X"], keyword = Decide, given = Nothing, upon = Nothing, clauses = [HC2 {hHead = RPConstraint ["X"] RPis ["Y"], hBody = Nothing}], rlabel = Nothing, lsource = Nothing, srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 1, srccol = 1, version = Nothing}), defaults = [], symtab = []} :2_1:When:
** / pRule                                                                                                             :2_1:When:
*** / pRegRule                                                                                                        :2_1:When:
**** / pRuleLabel                                                                                                    :2_1:When:
***** / $>|                                                                                                         :2_1:When:
$>|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=10:
$>|> unexpected WHEN
$>|> expecting §

pRuleLabel> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pRuleLabel> MATCH (EERR): <EMPTY>
pRuleLabel> ERROR:
pRuleLabel> offset=10:
pRuleLabel> unexpected WHEN
pRuleLabel> expecting §

**** / pRegRuleSugary                                                                                                :2_1:When:
***** / someDeep                                                                                                    :2_1:When:
****** / someDeep first part calls base directly                                                                   :2_1:When:
someDeep first part calls base directly> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someDeep first part calls base directly> MATCH (EERR): <EMPTY>
someDeep first part calls base directly> ERROR:
someDeep first part calls base directly> offset=10:
someDeep first part calls base directly> unexpected WHEN
someDeep first part calls base directly> expecting Other text

someDeep> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someDeep> MATCH (EERR): <EMPTY>
someDeep> ERROR:
someDeep> offset=10:
someDeep> unexpected WHEN
someDeep> expecting Other text

pRegRuleSugary> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pRegRuleSugary> MATCH (EERR): <EMPTY>
pRegRuleSugary> ERROR:
pRegRuleSugary> offset=10:
pRegRuleSugary> unexpected WHEN
pRegRuleSugary> expecting Other text

**** / pRegRuleNormal                                                                                                :2_1:When:
***** / permutationsReg                                                                                             :2_1:When:
****** / regulative permutation with deontic-temporal                                                              :2_1:When:
******* / WHERE                                                                                                   :2_1:When:
WHERE> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
WHERE> MATCH (EERR): <EMPTY>
WHERE> ERROR:
WHERE> offset=10:
WHERE> unexpected WHEN
WHERE> expecting WHERE

******* / preambleParamText:[Having]                                                                              :2_1:When:
******** / $>|                                                                                                   :2_1:When:
$>|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=10:
$>|> unexpected WHEN
$>|> expecting HAVING

preambleParamText:[Having]> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
preambleParamText:[Having]> MATCH (EERR): <EMPTY>
preambleParamText:[Having]> ERROR:
preambleParamText:[Having]> offset=10:
preambleParamText:[Having]> unexpected WHEN
preambleParamText:[Having]> expecting HAVING

******* / preambleParamText:[Given]                                                                               :2_1:When:
******** / $>|                                                                                                   :2_1:When:
$>|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=10:
$>|> unexpected WHEN
$>|> expecting GIVEN

preambleParamText:[Given]> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=10:
preambleParamText:[Given]> unexpected WHEN
preambleParamText:[Given]> expecting GIVEN

******* / preambleParamText:[Upon]                                                                                :2_1:When:
******** / $>|                                                                                                   :2_1:When:
$>|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=10:
$>|> unexpected WHEN
$>|> expecting UPON

preambleParamText:[Upon]> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=10:
preambleParamText:[Upon]> unexpected WHEN
preambleParamText:[Upon]> expecting UPON

******* / preambleBoolStructR [Unless]                                                                            :2_1:When:
preambleBoolStructR [Unless]> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
preambleBoolStructR [Unless]> MATCH (EERR): <EMPTY>
preambleBoolStructR [Unless]> ERROR:
preambleBoolStructR [Unless]> offset=10:
preambleBoolStructR [Unless]> unexpected WHEN
preambleBoolStructR [Unless]> expecting UNLESS

******* / preambleBoolStructR [When,If]                                                                           :2_1:When:
******** / pBSR                                                                                                   :2_2:GoDeeper:
********* / ppp inner                                                                                            :2_2:GoDeeper:
********** / expression                                                                                         :2_2:GoDeeper:
*********** / labelPrefix                                                                                      :2_2:GoDeeper:
labelPrefix> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=11:
labelPrefix> unexpected (
labelPrefix> expecting Other text

*********** / term p                                                                                           :2_2:GoDeeper:
************ / term p/notLabelTerm                                                                            :2_2:GoDeeper:
************* / term p/2:someIndentation expr p                                                              :2_2:GoDeeper:
************** / someIndentation                                                                            :2_2:GoDeeper:
*************** / myindented: consuming GoDeeper                                                           :2_2:GoDeeper:
myindented: consuming GoDeeper> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
myindented: consuming GoDeeper> MATCH (COK): (
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

*************** \ myindented: consuming GoDeeper has returned GoDeeper                                      :2_2:Other "Z":
*************** / manyIndentation/leaf?                                                                     :2_2:Other "Z":
**************** / expression                                                                              :2_2:Other "Z":
***************** / labelPrefix                                                                           :2_2:Other "Z":
labelPrefix> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
labelPrefix> MATCH (COK): "Z"
labelPrefix> VALUE: ("Z",[])

***************** \ labelPrefix has returned "Z"                                                           :2_3:GoDeeper:
***************** / term p                                                                                 :2_3:GoDeeper:
****************** / term p/notLabelTerm                                                                  :2_3:GoDeeper:
******************* / term p/2:someIndentation expr p                                                    :2_3:GoDeeper:
******************** / someIndentation                                                                  :2_3:GoDeeper:
********************* / myindented: consuming GoDeeper                                                 :2_3:GoDeeper:
myindented: consuming GoDeeper> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
myindented: consuming GoDeeper> MATCH (COK): (
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

********************* \ myindented: consuming GoDeeper has returned GoDeeper                            :2_3:Is:
********************* / manyIndentation/leaf?                                                           :2_3:Is:
********************** / expression                                                                    :2_3:Is:
*********************** / labelPrefix                                                                 :2_3:Is:
labelPrefix> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=14:
labelPrefix> unexpected IS
labelPrefix> expecting Other text

*********************** / term p                                                                      :2_3:Is:
************************ / term p/notLabelTerm                                                       :2_3:Is:
************************* / term p/2:someIndentation expr p                                         :2_3:Is:
************************** / someIndentation                                                       :2_3:Is:
*************************** / myindented: consuming GoDeeper                                      :2_3:Is:
myindented: consuming GoDeeper> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=14:
myindented: consuming GoDeeper> unexpected IS
myindented: consuming GoDeeper> expecting (

someIndentation> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting (

term p/2:someIndentation expr p> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p/2:someIndentation expr p> MATCH (EERR): <EMPTY>
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=14:
term p/2:someIndentation expr p> unexpected IS
term p/2:someIndentation expr p> expecting (

************************* / term p/3:plain p                                                        :2_3:Is:
************************** / pRelPred                                                              :2_3:Is:
*************************** / slRelPred                                                           :2_3:Is:
**************************** / nested simpleHorn                                                 :2_3:Is:
***************************** > |^|                                                             :2_3:Is:
***************************** / $*|                                                             :2_3:Is:
****************************** / slMultiTerm                                                   :2_3:Is:
******************************* / someSL                                                      :2_3:Is:
******************************** / pNumAsText                                                :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

nested simpleHorn> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=14:
nested simpleHorn> unexpected IS
nested simpleHorn> expecting other text or number

**************************** / RPConstraint                                                      :2_3:Is:
***************************** / $*|                                                             :2_3:Is:
****************************** / slMultiTerm                                                   :2_3:Is:
******************************* / someSL                                                      :2_3:Is:
******************************** / pNumAsText                                                :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

RPConstraint> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=14:
RPConstraint> unexpected IS
RPConstraint> expecting other text or number

**************************** / RPBoolStructR                                                     :2_3:Is:
***************************** / $*|                                                             :2_3:Is:
****************************** / slMultiTerm                                                   :2_3:Is:
******************************* / someSL                                                      :2_3:Is:
******************************** / pNumAsText                                                :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

RPBoolStructR> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=14:
RPBoolStructR> unexpected IS
RPBoolStructR> expecting other text or number

**************************** / RPMT                                                              :2_3:Is:
***************************** / $*|                                                             :2_3:Is:
****************************** / slAKA                                                         :2_3:Is:
******************************* / $*|                                                         :2_3:Is:
******************************** / slAKA base                                                :2_3:Is:
********************************* / slMultiTerm                                             :2_3:Is:
********************************** / someSL                                                :2_3:Is:
*********************************** / pNumAsText                                          :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

slAKA base> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=14:
slAKA base> unexpected IS
slAKA base> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

slAKA> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=14:
slAKA> unexpected IS
slAKA> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

RPMT> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=14:
RPMT> unexpected IS
RPMT> expecting other text or number

slRelPred> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=14:
slRelPred> unexpected IS
slRelPred> expecting other text or number

pRelPred> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pRelPred> MATCH (EERR): <EMPTY>
pRelPred> ERROR:
pRelPred> offset=14:
pRelPred> unexpected IS
pRelPred> expecting other text or number

term p/3:plain p> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p/3:plain p> MATCH (EERR): <EMPTY>
term p/3:plain p> ERROR:
term p/3:plain p> offset=14:
term p/3:plain p> unexpected IS
term p/3:plain p> expecting other text or number

term p/notLabelTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p/notLabelTerm> MATCH (EERR): <EMPTY>
term p/notLabelTerm> ERROR:
term p/notLabelTerm> offset=14:
term p/notLabelTerm> unexpected IS
term p/notLabelTerm> expecting ( or term

term p> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p> MATCH (EERR): <EMPTY>
term p> ERROR:
term p> offset=14:
term p> unexpected IS
term p> expecting ( or term

expression> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
expression> MATCH (EERR): <EMPTY>
expression> ERROR:
expression> offset=14:
expression> unexpected IS
expression> expecting expression

manyIndentation/leaf?> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
manyIndentation/leaf?> MATCH (EERR): <EMPTY>
manyIndentation/leaf?> ERROR:
manyIndentation/leaf?> offset=14:
manyIndentation/leaf?> unexpected IS
manyIndentation/leaf?> expecting expression

********************* / manyIndentation/deeper; calling someIndentation                                 :2_3:Is:
********************** / someIndentation                                                               :2_3:Is:
*********************** / myindented: consuming GoDeeper                                              :2_3:Is:
myindented: consuming GoDeeper> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=14:
myindented: consuming GoDeeper> unexpected IS
myindented: consuming GoDeeper> expecting (

someIndentation> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting (

manyIndentation/deeper; calling someIndentation> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
manyIndentation/deeper; calling someIndentation> MATCH (EERR): <EMPTY>
manyIndentation/deeper; calling someIndentation> ERROR:
manyIndentation/deeper; calling someIndentation> offset=14:
manyIndentation/deeper; calling someIndentation> unexpected IS
manyIndentation/deeper; calling someIndentation> expecting (

someIndentation> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someIndentation> MATCH (CERR): (
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting ( or expression

term p/2:someIndentation expr p> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p/2:someIndentation expr p> MATCH (CERR): (
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=14:
term p/2:someIndentation expr p> unexpected IS
term p/2:someIndentation expr p> expecting ( or expression

******************* / term p/3:plain p                                                                   :2_3:GoDeeper:
******************** / pRelPred                                                                         :2_3:GoDeeper:
********************* / slRelPred                                                                      :2_3:GoDeeper:
********************** / nested simpleHorn                                                            :2_3:GoDeeper:
*********************** > |^|                                                                        :2_3:GoDeeper:
*********************** / $*|                                                                        :2_3:GoDeeper:
************************ / slMultiTerm                                                              :2_3:GoDeeper:
************************* / someSL                                                                 :2_3:GoDeeper:
************************** / pNumAsText                                                           :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

nested simpleHorn> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=13:
nested simpleHorn> unexpected (
nested simpleHorn> expecting other text or number

********************** / RPConstraint                                                                 :2_3:GoDeeper:
*********************** / $*|                                                                        :2_3:GoDeeper:
************************ / slMultiTerm                                                              :2_3:GoDeeper:
************************* / someSL                                                                 :2_3:GoDeeper:
************************** / pNumAsText                                                           :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

RPConstraint> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=13:
RPConstraint> unexpected (
RPConstraint> expecting other text or number

********************** / RPBoolStructR                                                                :2_3:GoDeeper:
*********************** / $*|                                                                        :2_3:GoDeeper:
************************ / slMultiTerm                                                              :2_3:GoDeeper:
************************* / someSL                                                                 :2_3:GoDeeper:
************************** / pNumAsText                                                           :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

RPBoolStructR> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=13:
RPBoolStructR> unexpected (
RPBoolStructR> expecting other text or number

********************** / RPMT                                                                         :2_3:GoDeeper:
*********************** / $*|                                                                        :2_3:GoDeeper:
************************ / slAKA                                                                    :2_3:GoDeeper:
************************* / $*|                                                                    :2_3:GoDeeper:
************************** / slAKA base                                                           :2_3:GoDeeper:
*************************** / slMultiTerm                                                        :2_3:GoDeeper:
**************************** / someSL                                                           :2_3:GoDeeper:
***************************** / pNumAsText                                                     :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

slAKA base> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=13:
slAKA base> unexpected (
slAKA base> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

slAKA> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=13:
slAKA> unexpected (
slAKA> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

RPMT> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=13:
RPMT> unexpected (
RPMT> expecting other text or number

slRelPred> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=13:
slRelPred> unexpected (
slRelPred> expecting other text or number

pRelPred> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pRelPred> MATCH (EERR): <EMPTY>
pRelPred> ERROR:
pRelPred> offset=13:
pRelPred> unexpected (
pRelPred> expecting other text or number

term p/3:plain p> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p/3:plain p> MATCH (EERR): <EMPTY>
term p/3:plain p> ERROR:
term p/3:plain p> offset=13:
term p/3:plain p> unexpected (
term p/3:plain p> expecting other text or number

term p/notLabelTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p/notLabelTerm> MATCH (EERR): <EMPTY>
term p/notLabelTerm> ERROR:
term p/notLabelTerm> offset=14:
term p/notLabelTerm> unexpected IS
term p/notLabelTerm> expecting ( or expression

term p> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p> MATCH (EERR): <EMPTY>
term p> ERROR:
term p> offset=14:
term p> unexpected IS
term p> expecting ( or expression

expression> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
expression> MATCH (CERR): "Z"
expression> ERROR:
expression> offset=14:
expression> unexpected IS
expression> expecting (, NOT, or expression

manyIndentation/leaf?> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
manyIndentation/leaf?> MATCH (EERR): <EMPTY>
manyIndentation/leaf?> ERROR:
manyIndentation/leaf?> offset=14:
manyIndentation/leaf?> unexpected IS
manyIndentation/leaf?> expecting (, NOT, or expression

*************** / manyIndentation/deeper; calling someIndentation                                           :2_2:Other "Z":
**************** / someIndentation                                                                         :2_2:Other "Z":
***************** / myindented: consuming GoDeeper                                                        :2_2:Other "Z":
myindented: consuming GoDeeper> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=12:
myindented: consuming GoDeeper> unexpected "Z"
myindented: consuming GoDeeper> expecting (

someIndentation> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=12:
someIndentation> unexpected "Z"
someIndentation> expecting (

manyIndentation/deeper; calling someIndentation> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
manyIndentation/deeper; calling someIndentation> MATCH (EERR): <EMPTY>
manyIndentation/deeper; calling someIndentation> ERROR:
manyIndentation/deeper; calling someIndentation> offset=12:
manyIndentation/deeper; calling someIndentation> unexpected "Z"
manyIndentation/deeper; calling someIndentation> expecting (

someIndentation> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someIndentation> MATCH (CERR): (
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting (, NOT, or expression

term p/2:someIndentation expr p> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p/2:someIndentation expr p> MATCH (CERR): (
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=14:
term p/2:someIndentation expr p> unexpected IS
term p/2:someIndentation expr p> expecting (, NOT, or expression

************* / term p/3:plain p                                                                             :2_2:GoDeeper:
************** / pRelPred                                                                                   :2_2:GoDeeper:
*************** / slRelPred                                                                                :2_2:GoDeeper:
**************** / nested simpleHorn                                                                      :2_2:GoDeeper:
***************** > |^|                                                                                  :2_2:GoDeeper:
***************** / $*|                                                                                  :2_2:GoDeeper:
****************** / slMultiTerm                                                                        :2_2:GoDeeper:
******************* / someSL                                                                           :2_2:GoDeeper:
******************** / pNumAsText                                                                     :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

nested simpleHorn> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=11:
nested simpleHorn> unexpected (
nested simpleHorn> expecting other text or number

**************** / RPConstraint                                                                           :2_2:GoDeeper:
***************** / $*|                                                                                  :2_2:GoDeeper:
****************** / slMultiTerm                                                                        :2_2:GoDeeper:
******************* / someSL                                                                           :2_2:GoDeeper:
******************** / pNumAsText                                                                     :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

RPConstraint> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=11:
RPConstraint> unexpected (
RPConstraint> expecting other text or number

**************** / RPBoolStructR                                                                          :2_2:GoDeeper:
***************** / $*|                                                                                  :2_2:GoDeeper:
****************** / slMultiTerm                                                                        :2_2:GoDeeper:
******************* / someSL                                                                           :2_2:GoDeeper:
******************** / pNumAsText                                                                     :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

RPBoolStructR> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=11:
RPBoolStructR> unexpected (
RPBoolStructR> expecting other text or number

**************** / RPMT                                                                                   :2_2:GoDeeper:
***************** / $*|                                                                                  :2_2:GoDeeper:
****************** / slAKA                                                                              :2_2:GoDeeper:
******************* / $*|                                                                              :2_2:GoDeeper:
******************** / slAKA base                                                                     :2_2:GoDeeper:
********************* / slMultiTerm                                                                  :2_2:GoDeeper:
********************** / someSL                                                                     :2_2:GoDeeper:
*********************** / pNumAsText                                                               :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

slAKA base> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=11:
slAKA base> unexpected (
slAKA base> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

slAKA> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=11:
slAKA> unexpected (
slAKA> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

RPMT> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=11:
RPMT> unexpected (
RPMT> expecting other text or number

slRelPred> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=11:
slRelPred> unexpected (
slRelPred> expecting other text or number

pRelPred> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pRelPred> MATCH (EERR): <EMPTY>
pRelPred> ERROR:
pRelPred> offset=11:
pRelPred> unexpected (
pRelPred> expecting other text or number

term p/3:plain p> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p/3:plain p> MATCH (EERR): <EMPTY>
term p/3:plain p> ERROR:
term p/3:plain p> offset=11:
term p/3:plain p> unexpected (
term p/3:plain p> expecting other text or number

term p/notLabelTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p/notLabelTerm> MATCH (EERR): <EMPTY>
term p/notLabelTerm> ERROR:
term p/notLabelTerm> offset=14:
term p/notLabelTerm> unexpected IS
term p/notLabelTerm> expecting (, NOT, or expression

term p> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p> MATCH (EERR): <EMPTY>
term p> ERROR:
term p> offset=14:
term p> unexpected IS
term p> expecting (, NOT, or expression

expression> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
expression> MATCH (EERR): <EMPTY>
expression> ERROR:
expression> offset=14:
expression> unexpected IS
expression> expecting expression

ppp inner> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
ppp inner> MATCH (EERR): <EMPTY>
ppp inner> ERROR:
ppp inner> offset=14:
ppp inner> unexpected IS
ppp inner> expecting expression

********* / withPrePost                                                                                          :2_2:GoDeeper:
********** > |<* starting                                                                                       :2_2:GoDeeper:
********** / $*|                                                                                                :2_2:GoDeeper:
*********** / pre part                                                                                         :2_2:GoDeeper:
************ / aboveNextLineKeyword                                                                            :2_2:Other "Z":
************* / expectUnDeepers                                                                               :2_2:Other "Z":
************** / pNumAsText                                                                                   :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************** / pNumAsText                                                                                    :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
expectUnDeepers> MATCH (CERR): "Z" (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
aboveNextLineKeyword> MATCH (CERR): "Z" (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

************ > /*= lookAhead failed, delegating to plain /+=                                                   :2_2:Other "Z":
************ / aboveNextLineKeyword                                                                             :2_3:GoDeeper:
************* / expectUnDeepers                                                                                :2_3:GoDeeper:
************** / pNumAsText                                                                                   :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************** / pNumAsText                                                                                    :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
expectUnDeepers> MATCH (CERR): (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
aboveNextLineKeyword> MATCH (CERR): (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

************ > /*= lookAhead failed, delegating to plain /+=                                                    :2_3:GoDeeper:
************ / aboveNextLineKeyword                                                                              :2_3:Is:
************* / expectUnDeepers                                                                                 :2_3:Is:
************** / pNumAsText                                                                                    :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
expectUnDeepers> MATCH (EERR): <EMPTY>
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
aboveNextLineKeyword> MATCH (EERR): <EMPTY>
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

************ > /*= lookAhead failed, delegating to plain /+=                                                     :2_3:Is:
pre part> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pre part> MATCH (CERR): (
pre part> ERROR:
pre part> offset=14:
pre part> unexpected IS
pre part> expecting (, ), Other text, or other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (CERR): (
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting (, ), Other text, or other text or number

withPrePost> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
withPrePost> MATCH (CERR): (
withPrePost> ERROR:
withPrePost> offset=14:
withPrePost> unexpected IS
withPrePost> expecting (, ), Other text, or other text or number

********* / withPreOnly                                                                                          :2_2:GoDeeper:
********** / $*|                                                                                                :2_2:GoDeeper:
*********** / pre part                                                                                         :2_2:GoDeeper:
************ / aboveNextLineKeyword                                                                            :2_2:Other "Z":
************* / expectUnDeepers                                                                               :2_2:Other "Z":
************** / pNumAsText                                                                                   :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************** / pNumAsText                                                                                    :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
expectUnDeepers> MATCH (CERR): "Z" (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
aboveNextLineKeyword> MATCH (CERR): "Z" (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

************ > /*= lookAhead failed, delegating to plain /+=                                                   :2_2:Other "Z":
************ / aboveNextLineKeyword                                                                             :2_3:GoDeeper:
************* / expectUnDeepers                                                                                :2_3:GoDeeper:
************** / pNumAsText                                                                                   :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************** / pNumAsText                                                                                    :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
expectUnDeepers> MATCH (CERR): (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
aboveNextLineKeyword> MATCH (CERR): (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

************ > /*= lookAhead failed, delegating to plain /+=                                                    :2_3:GoDeeper:
************ / aboveNextLineKeyword                                                                              :2_3:Is:
************* / expectUnDeepers                                                                                 :2_3:Is:
************** / pNumAsText                                                                                    :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
expectUnDeepers> MATCH (EERR): <EMPTY>
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
aboveNextLineKeyword> MATCH (EERR): <EMPTY>
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

************ > /*= lookAhead failed, delegating to plain /+=                                                     :2_3:Is:
pre part> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pre part> MATCH (CERR): (
pre part> ERROR:
pre part> offset=14:
pre part> unexpected IS
pre part> expecting (, ), Other text, or other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (CERR): (
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting (, ), Other text, or other text or number

withPreOnly> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
withPreOnly> MATCH (CERR): (
withPreOnly> ERROR:
withPreOnly> offset=14:
withPreOnly> unexpected IS
withPreOnly> expecting (, ), Other text, or other text or number

pBSR> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pBSR> MATCH (CERR): (
pBSR> ERROR:
pBSR> offset=14:
pBSR> unexpected IS
pBSR> expecting (, ), Other text, expression, or other text or number

preambleBoolStructR [When,If]> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
preambleBoolStructR [When,If]> MATCH (CERR): WHEN (
preambleBoolStructR [When,If]> ERROR:
preambleBoolStructR [When,If]> offset=14:
preambleBoolStructR [When,If]> unexpected IS
preambleBoolStructR [When,If]> expecting (, ), Other text, expression, or other text or number

regulative permutation with deontic-temporal> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
regulative permutation with deontic-temporal> MATCH (CERR): WHEN (
regulative permutation with deontic-temporal> ERROR:
regulative permutation with deontic-temporal> offset=14:
regulative permutation with deontic-temporal> unexpected IS
regulative permutation with deontic-temporal> expecting (, ), Other text, expression, or other text or number

****** / regulative permutation with deontic-action                                                                :2_1:When:
******* / WHERE                                                                                                   :2_1:When:
WHERE> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
WHERE> MATCH (EERR): <EMPTY>
WHERE> ERROR:
WHERE> offset=10:
WHERE> unexpected WHEN
WHERE> expecting WHERE

******* / preambleParamText:[Having]                                                                              :2_1:When:
******** / $>|                                                                                                   :2_1:When:
$>|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=10:
$>|> unexpected WHEN
$>|> expecting HAVING

preambleParamText:[Having]> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
preambleParamText:[Having]> MATCH (EERR): <EMPTY>
preambleParamText:[Having]> ERROR:
preambleParamText:[Having]> offset=10:
preambleParamText:[Having]> unexpected WHEN
preambleParamText:[Having]> expecting HAVING

******* / preambleParamText:[Given]                                                                               :2_1:When:
******** / $>|                                                                                                   :2_1:When:
$>|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=10:
$>|> unexpected WHEN
$>|> expecting GIVEN

preambleParamText:[Given]> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=10:
preambleParamText:[Given]> unexpected WHEN
preambleParamText:[Given]> expecting GIVEN

******* / preambleParamText:[Upon]                                                                                :2_1:When:
******** / $>|                                                                                                   :2_1:When:
$>|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=10:
$>|> unexpected WHEN
$>|> expecting UPON

preambleParamText:[Upon]> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=10:
preambleParamText:[Upon]> unexpected WHEN
preambleParamText:[Upon]> expecting UPON

******* / preambleBoolStructR [Unless]                                                                            :2_1:When:
preambleBoolStructR [Unless]> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
preambleBoolStructR [Unless]> MATCH (EERR): <EMPTY>
preambleBoolStructR [Unless]> ERROR:
preambleBoolStructR [Unless]> offset=10:
preambleBoolStructR [Unless]> unexpected WHEN
preambleBoolStructR [Unless]> expecting UNLESS

******* / preambleBoolStructR [When,If]                                                                           :2_1:When:
******** / pBSR                                                                                                   :2_2:GoDeeper:
********* / ppp inner                                                                                            :2_2:GoDeeper:
********** / expression                                                                                         :2_2:GoDeeper:
*********** / labelPrefix                                                                                      :2_2:GoDeeper:
labelPrefix> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=11:
labelPrefix> unexpected (
labelPrefix> expecting Other text

*********** / term p                                                                                           :2_2:GoDeeper:
************ / term p/notLabelTerm                                                                            :2_2:GoDeeper:
************* / term p/2:someIndentation expr p                                                              :2_2:GoDeeper:
************** / someIndentation                                                                            :2_2:GoDeeper:
*************** / myindented: consuming GoDeeper                                                           :2_2:GoDeeper:
myindented: consuming GoDeeper> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
myindented: consuming GoDeeper> MATCH (COK): (
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

*************** \ myindented: consuming GoDeeper has returned GoDeeper                                      :2_2:Other "Z":
*************** / manyIndentation/leaf?                                                                     :2_2:Other "Z":
**************** / expression                                                                              :2_2:Other "Z":
***************** / labelPrefix                                                                           :2_2:Other "Z":
labelPrefix> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
labelPrefix> MATCH (COK): "Z"
labelPrefix> VALUE: ("Z",[])

***************** \ labelPrefix has returned "Z"                                                           :2_3:GoDeeper:
***************** / term p                                                                                 :2_3:GoDeeper:
****************** / term p/notLabelTerm                                                                  :2_3:GoDeeper:
******************* / term p/2:someIndentation expr p                                                    :2_3:GoDeeper:
******************** / someIndentation                                                                  :2_3:GoDeeper:
********************* / myindented: consuming GoDeeper                                                 :2_3:GoDeeper:
myindented: consuming GoDeeper> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
myindented: consuming GoDeeper> MATCH (COK): (
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

********************* \ myindented: consuming GoDeeper has returned GoDeeper                            :2_3:Is:
********************* / manyIndentation/leaf?                                                           :2_3:Is:
********************** / expression                                                                    :2_3:Is:
*********************** / labelPrefix                                                                 :2_3:Is:
labelPrefix> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=14:
labelPrefix> unexpected IS
labelPrefix> expecting Other text

*********************** / term p                                                                      :2_3:Is:
************************ / term p/notLabelTerm                                                       :2_3:Is:
************************* / term p/2:someIndentation expr p                                         :2_3:Is:
************************** / someIndentation                                                       :2_3:Is:
*************************** / myindented: consuming GoDeeper                                      :2_3:Is:
myindented: consuming GoDeeper> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=14:
myindented: consuming GoDeeper> unexpected IS
myindented: consuming GoDeeper> expecting (

someIndentation> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting (

term p/2:someIndentation expr p> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p/2:someIndentation expr p> MATCH (EERR): <EMPTY>
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=14:
term p/2:someIndentation expr p> unexpected IS
term p/2:someIndentation expr p> expecting (

************************* / term p/3:plain p                                                        :2_3:Is:
************************** / pRelPred                                                              :2_3:Is:
*************************** / slRelPred                                                           :2_3:Is:
**************************** / nested simpleHorn                                                 :2_3:Is:
***************************** > |^|                                                             :2_3:Is:
***************************** / $*|                                                             :2_3:Is:
****************************** / slMultiTerm                                                   :2_3:Is:
******************************* / someSL                                                      :2_3:Is:
******************************** / pNumAsText                                                :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

nested simpleHorn> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=14:
nested simpleHorn> unexpected IS
nested simpleHorn> expecting other text or number

**************************** / RPConstraint                                                      :2_3:Is:
***************************** / $*|                                                             :2_3:Is:
****************************** / slMultiTerm                                                   :2_3:Is:
******************************* / someSL                                                      :2_3:Is:
******************************** / pNumAsText                                                :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

RPConstraint> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=14:
RPConstraint> unexpected IS
RPConstraint> expecting other text or number

**************************** / RPBoolStructR                                                     :2_3:Is:
***************************** / $*|                                                             :2_3:Is:
****************************** / slMultiTerm                                                   :2_3:Is:
******************************* / someSL                                                      :2_3:Is:
******************************** / pNumAsText                                                :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

RPBoolStructR> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=14:
RPBoolStructR> unexpected IS
RPBoolStructR> expecting other text or number

**************************** / RPMT                                                              :2_3:Is:
***************************** / $*|                                                             :2_3:Is:
****************************** / slAKA                                                         :2_3:Is:
******************************* / $*|                                                         :2_3:Is:
******************************** / slAKA base                                                :2_3:Is:
********************************* / slMultiTerm                                             :2_3:Is:
********************************** / someSL                                                :2_3:Is:
*********************************** / pNumAsText                                          :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

slAKA base> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=14:
slAKA base> unexpected IS
slAKA base> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

slAKA> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=14:
slAKA> unexpected IS
slAKA> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

RPMT> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=14:
RPMT> unexpected IS
RPMT> expecting other text or number

slRelPred> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=14:
slRelPred> unexpected IS
slRelPred> expecting other text or number

pRelPred> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pRelPred> MATCH (EERR): <EMPTY>
pRelPred> ERROR:
pRelPred> offset=14:
pRelPred> unexpected IS
pRelPred> expecting other text or number

term p/3:plain p> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p/3:plain p> MATCH (EERR): <EMPTY>
term p/3:plain p> ERROR:
term p/3:plain p> offset=14:
term p/3:plain p> unexpected IS
term p/3:plain p> expecting other text or number

term p/notLabelTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p/notLabelTerm> MATCH (EERR): <EMPTY>
term p/notLabelTerm> ERROR:
term p/notLabelTerm> offset=14:
term p/notLabelTerm> unexpected IS
term p/notLabelTerm> expecting ( or term

term p> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p> MATCH (EERR): <EMPTY>
term p> ERROR:
term p> offset=14:
term p> unexpected IS
term p> expecting ( or term

expression> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
expression> MATCH (EERR): <EMPTY>
expression> ERROR:
expression> offset=14:
expression> unexpected IS
expression> expecting expression

manyIndentation/leaf?> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
manyIndentation/leaf?> MATCH (EERR): <EMPTY>
manyIndentation/leaf?> ERROR:
manyIndentation/leaf?> offset=14:
manyIndentation/leaf?> unexpected IS
manyIndentation/leaf?> expecting expression

********************* / manyIndentation/deeper; calling someIndentation                                 :2_3:Is:
********************** / someIndentation                                                               :2_3:Is:
*********************** / myindented: consuming GoDeeper                                              :2_3:Is:
myindented: consuming GoDeeper> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=14:
myindented: consuming GoDeeper> unexpected IS
myindented: consuming GoDeeper> expecting (

someIndentation> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting (

manyIndentation/deeper; calling someIndentation> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
manyIndentation/deeper; calling someIndentation> MATCH (EERR): <EMPTY>
manyIndentation/deeper; calling someIndentation> ERROR:
manyIndentation/deeper; calling someIndentation> offset=14:
manyIndentation/deeper; calling someIndentation> unexpected IS
manyIndentation/deeper; calling someIndentation> expecting (

someIndentation> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someIndentation> MATCH (CERR): (
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting ( or expression

term p/2:someIndentation expr p> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p/2:someIndentation expr p> MATCH (CERR): (
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=14:
term p/2:someIndentation expr p> unexpected IS
term p/2:someIndentation expr p> expecting ( or expression

******************* / term p/3:plain p                                                                   :2_3:GoDeeper:
******************** / pRelPred                                                                         :2_3:GoDeeper:
********************* / slRelPred                                                                      :2_3:GoDeeper:
********************** / nested simpleHorn                                                            :2_3:GoDeeper:
*********************** > |^|                                                                        :2_3:GoDeeper:
*********************** / $*|                                                                        :2_3:GoDeeper:
************************ / slMultiTerm                                                              :2_3:GoDeeper:
************************* / someSL                                                                 :2_3:GoDeeper:
************************** / pNumAsText                                                           :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

nested simpleHorn> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=13:
nested simpleHorn> unexpected (
nested simpleHorn> expecting other text or number

********************** / RPConstraint                                                                 :2_3:GoDeeper:
*********************** / $*|                                                                        :2_3:GoDeeper:
************************ / slMultiTerm                                                              :2_3:GoDeeper:
************************* / someSL                                                                 :2_3:GoDeeper:
************************** / pNumAsText                                                           :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

RPConstraint> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=13:
RPConstraint> unexpected (
RPConstraint> expecting other text or number

********************** / RPBoolStructR                                                                :2_3:GoDeeper:
*********************** / $*|                                                                        :2_3:GoDeeper:
************************ / slMultiTerm                                                              :2_3:GoDeeper:
************************* / someSL                                                                 :2_3:GoDeeper:
************************** / pNumAsText                                                           :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

RPBoolStructR> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=13:
RPBoolStructR> unexpected (
RPBoolStructR> expecting other text or number

********************** / RPMT                                                                         :2_3:GoDeeper:
*********************** / $*|                                                                        :2_3:GoDeeper:
************************ / slAKA                                                                    :2_3:GoDeeper:
************************* / $*|                                                                    :2_3:GoDeeper:
************************** / slAKA base                                                           :2_3:GoDeeper:
*************************** / slMultiTerm                                                        :2_3:GoDeeper:
**************************** / someSL                                                           :2_3:GoDeeper:
***************************** / pNumAsText                                                     :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

slAKA base> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=13:
slAKA base> unexpected (
slAKA base> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

slAKA> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=13:
slAKA> unexpected (
slAKA> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

RPMT> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=13:
RPMT> unexpected (
RPMT> expecting other text or number

slRelPred> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=13:
slRelPred> unexpected (
slRelPred> expecting other text or number

pRelPred> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pRelPred> MATCH (EERR): <EMPTY>
pRelPred> ERROR:
pRelPred> offset=13:
pRelPred> unexpected (
pRelPred> expecting other text or number

term p/3:plain p> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p/3:plain p> MATCH (EERR): <EMPTY>
term p/3:plain p> ERROR:
term p/3:plain p> offset=13:
term p/3:plain p> unexpected (
term p/3:plain p> expecting other text or number

term p/notLabelTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p/notLabelTerm> MATCH (EERR): <EMPTY>
term p/notLabelTerm> ERROR:
term p/notLabelTerm> offset=14:
term p/notLabelTerm> unexpected IS
term p/notLabelTerm> expecting ( or expression

term p> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p> MATCH (EERR): <EMPTY>
term p> ERROR:
term p> offset=14:
term p> unexpected IS
term p> expecting ( or expression

expression> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
expression> MATCH (CERR): "Z"
expression> ERROR:
expression> offset=14:
expression> unexpected IS
expression> expecting (, NOT, or expression

manyIndentation/leaf?> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
manyIndentation/leaf?> MATCH (EERR): <EMPTY>
manyIndentation/leaf?> ERROR:
manyIndentation/leaf?> offset=14:
manyIndentation/leaf?> unexpected IS
manyIndentation/leaf?> expecting (, NOT, or expression

*************** / manyIndentation/deeper; calling someIndentation                                           :2_2:Other "Z":
**************** / someIndentation                                                                         :2_2:Other "Z":
***************** / myindented: consuming GoDeeper                                                        :2_2:Other "Z":
myindented: consuming GoDeeper> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=12:
myindented: consuming GoDeeper> unexpected "Z"
myindented: consuming GoDeeper> expecting (

someIndentation> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=12:
someIndentation> unexpected "Z"
someIndentation> expecting (

manyIndentation/deeper; calling someIndentation> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
manyIndentation/deeper; calling someIndentation> MATCH (EERR): <EMPTY>
manyIndentation/deeper; calling someIndentation> ERROR:
manyIndentation/deeper; calling someIndentation> offset=12:
manyIndentation/deeper; calling someIndentation> unexpected "Z"
manyIndentation/deeper; calling someIndentation> expecting (

someIndentation> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someIndentation> MATCH (CERR): (
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting (, NOT, or expression

term p/2:someIndentation expr p> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p/2:someIndentation expr p> MATCH (CERR): (
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=14:
term p/2:someIndentation expr p> unexpected IS
term p/2:someIndentation expr p> expecting (, NOT, or expression

************* / term p/3:plain p                                                                             :2_2:GoDeeper:
************** / pRelPred                                                                                   :2_2:GoDeeper:
*************** / slRelPred                                                                                :2_2:GoDeeper:
**************** / nested simpleHorn                                                                      :2_2:GoDeeper:
***************** > |^|                                                                                  :2_2:GoDeeper:
***************** / $*|                                                                                  :2_2:GoDeeper:
****************** / slMultiTerm                                                                        :2_2:GoDeeper:
******************* / someSL                                                                           :2_2:GoDeeper:
******************** / pNumAsText                                                                     :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

nested simpleHorn> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=11:
nested simpleHorn> unexpected (
nested simpleHorn> expecting other text or number

**************** / RPConstraint                                                                           :2_2:GoDeeper:
***************** / $*|                                                                                  :2_2:GoDeeper:
****************** / slMultiTerm                                                                        :2_2:GoDeeper:
******************* / someSL                                                                           :2_2:GoDeeper:
******************** / pNumAsText                                                                     :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

RPConstraint> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=11:
RPConstraint> unexpected (
RPConstraint> expecting other text or number

**************** / RPBoolStructR                                                                          :2_2:GoDeeper:
***************** / $*|                                                                                  :2_2:GoDeeper:
****************** / slMultiTerm                                                                        :2_2:GoDeeper:
******************* / someSL                                                                           :2_2:GoDeeper:
******************** / pNumAsText                                                                     :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

RPBoolStructR> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=11:
RPBoolStructR> unexpected (
RPBoolStructR> expecting other text or number

**************** / RPMT                                                                                   :2_2:GoDeeper:
***************** / $*|                                                                                  :2_2:GoDeeper:
****************** / slAKA                                                                              :2_2:GoDeeper:
******************* / $*|                                                                              :2_2:GoDeeper:
******************** / slAKA base                                                                     :2_2:GoDeeper:
********************* / slMultiTerm                                                                  :2_2:GoDeeper:
********************** / someSL                                                                     :2_2:GoDeeper:
*********************** / pNumAsText                                                               :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

slAKA base> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=11:
slAKA base> unexpected (
slAKA base> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

slAKA> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=11:
slAKA> unexpected (
slAKA> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

RPMT> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=11:
RPMT> unexpected (
RPMT> expecting other text or number

slRelPred> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=11:
slRelPred> unexpected (
slRelPred> expecting other text or number

pRelPred> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pRelPred> MATCH (EERR): <EMPTY>
pRelPred> ERROR:
pRelPred> offset=11:
pRelPred> unexpected (
pRelPred> expecting other text or number

term p/3:plain p> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p/3:plain p> MATCH (EERR): <EMPTY>
term p/3:plain p> ERROR:
term p/3:plain p> offset=11:
term p/3:plain p> unexpected (
term p/3:plain p> expecting other text or number

term p/notLabelTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p/notLabelTerm> MATCH (EERR): <EMPTY>
term p/notLabelTerm> ERROR:
term p/notLabelTerm> offset=14:
term p/notLabelTerm> unexpected IS
term p/notLabelTerm> expecting (, NOT, or expression

term p> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p> MATCH (EERR): <EMPTY>
term p> ERROR:
term p> offset=14:
term p> unexpected IS
term p> expecting (, NOT, or expression

expression> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
expression> MATCH (EERR): <EMPTY>
expression> ERROR:
expression> offset=14:
expression> unexpected IS
expression> expecting expression

ppp inner> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
ppp inner> MATCH (EERR): <EMPTY>
ppp inner> ERROR:
ppp inner> offset=14:
ppp inner> unexpected IS
ppp inner> expecting expression

********* / withPrePost                                                                                          :2_2:GoDeeper:
********** > |<* starting                                                                                       :2_2:GoDeeper:
********** / $*|                                                                                                :2_2:GoDeeper:
*********** / pre part                                                                                         :2_2:GoDeeper:
************ / aboveNextLineKeyword                                                                            :2_2:Other "Z":
************* / expectUnDeepers                                                                               :2_2:Other "Z":
************** / pNumAsText                                                                                   :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************** / pNumAsText                                                                                    :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
expectUnDeepers> MATCH (CERR): "Z" (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
aboveNextLineKeyword> MATCH (CERR): "Z" (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

************ > /*= lookAhead failed, delegating to plain /+=                                                   :2_2:Other "Z":
************ / aboveNextLineKeyword                                                                             :2_3:GoDeeper:
************* / expectUnDeepers                                                                                :2_3:GoDeeper:
************** / pNumAsText                                                                                   :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************** / pNumAsText                                                                                    :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
expectUnDeepers> MATCH (CERR): (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
aboveNextLineKeyword> MATCH (CERR): (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

************ > /*= lookAhead failed, delegating to plain /+=                                                    :2_3:GoDeeper:
************ / aboveNextLineKeyword                                                                              :2_3:Is:
************* / expectUnDeepers                                                                                 :2_3:Is:
************** / pNumAsText                                                                                    :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
expectUnDeepers> MATCH (EERR): <EMPTY>
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
aboveNextLineKeyword> MATCH (EERR): <EMPTY>
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

************ > /*= lookAhead failed, delegating to plain /+=                                                     :2_3:Is:
pre part> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pre part> MATCH (CERR): (
pre part> ERROR:
pre part> offset=14:
pre part> unexpected IS
pre part> expecting (, ), Other text, or other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (CERR): (
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting (, ), Other text, or other text or number

withPrePost> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
withPrePost> MATCH (CERR): (
withPrePost> ERROR:
withPrePost> offset=14:
withPrePost> unexpected IS
withPrePost> expecting (, ), Other text, or other text or number

********* / withPreOnly                                                                                          :2_2:GoDeeper:
********** / $*|                                                                                                :2_2:GoDeeper:
*********** / pre part                                                                                         :2_2:GoDeeper:
************ / aboveNextLineKeyword                                                                            :2_2:Other "Z":
************* / expectUnDeepers                                                                               :2_2:Other "Z":
************** / pNumAsText                                                                                   :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************** / pNumAsText                                                                                    :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
expectUnDeepers> MATCH (CERR): "Z" (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
aboveNextLineKeyword> MATCH (CERR): "Z" (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

************ > /*= lookAhead failed, delegating to plain /+=                                                   :2_2:Other "Z":
************ / aboveNextLineKeyword                                                                             :2_3:GoDeeper:
************* / expectUnDeepers                                                                                :2_3:GoDeeper:
************** / pNumAsText                                                                                   :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************** / pNumAsText                                                                                    :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
expectUnDeepers> MATCH (CERR): (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
aboveNextLineKeyword> MATCH (CERR): (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

************ > /*= lookAhead failed, delegating to plain /+=                                                    :2_3:GoDeeper:
************ / aboveNextLineKeyword                                                                              :2_3:Is:
************* / expectUnDeepers                                                                                 :2_3:Is:
************** / pNumAsText                                                                                    :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
expectUnDeepers> MATCH (EERR): <EMPTY>
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
aboveNextLineKeyword> MATCH (EERR): <EMPTY>
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

************ > /*= lookAhead failed, delegating to plain /+=                                                     :2_3:Is:
pre part> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pre part> MATCH (CERR): (
pre part> ERROR:
pre part> offset=14:
pre part> unexpected IS
pre part> expecting (, ), Other text, or other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (CERR): (
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting (, ), Other text, or other text or number

withPreOnly> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
withPreOnly> MATCH (CERR): (
withPreOnly> ERROR:
withPreOnly> offset=14:
withPreOnly> unexpected IS
withPreOnly> expecting (, ), Other text, or other text or number

pBSR> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pBSR> MATCH (CERR): (
pBSR> ERROR:
pBSR> offset=14:
pBSR> unexpected IS
pBSR> expecting (, ), Other text, expression, or other text or number

preambleBoolStructR [When,If]> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
preambleBoolStructR [When,If]> MATCH (CERR): WHEN (
preambleBoolStructR [When,If]> ERROR:
preambleBoolStructR [When,If]> offset=14:
preambleBoolStructR [When,If]> unexpected IS
preambleBoolStructR [When,If]> expecting (, ), Other text, expression, or other text or number

regulative permutation with deontic-action> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
regulative permutation with deontic-action> MATCH (CERR): WHEN (
regulative permutation with deontic-action> ERROR:
regulative permutation with deontic-action> offset=14:
regulative permutation with deontic-action> unexpected IS
regulative permutation with deontic-action> expecting (, ), Other text, expression, or other text or number

permutationsReg> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
permutationsReg> MATCH (EERR): <EMPTY>
permutationsReg> ERROR:
permutationsReg> offset=14:
permutationsReg> unexpected IS
permutationsReg> expecting (, ), Other text, expression, or other text or number

pRegRuleNormal> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pRegRuleNormal> MATCH (EERR): <EMPTY>
pRegRuleNormal> ERROR:
pRegRuleNormal> offset=14:
pRegRuleNormal> unexpected IS
pRegRuleNormal> expecting (, ), Other text, expression, or other text or number

pRegRule> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pRegRule> MATCH (EERR): <EMPTY>
pRegRule> ERROR:
pRegRule> offset=14:
pRegRule> unexpected IS
pRegRule> expecting (, ), Other text, expression, other text or number, or §

*** / pTypeDefinition                                                                                                 :2_1:When:
**** / pRuleLabel                                                                                                    :2_1:When:
***** / $>|                                                                                                         :2_1:When:
$>|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=10:
$>|> unexpected WHEN
$>|> expecting §

pRuleLabel> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pRuleLabel> MATCH (EERR): <EMPTY>
pRuleLabel> ERROR:
pRuleLabel> offset=10:
pRuleLabel> unexpected WHEN
pRuleLabel> expecting §

**** / pHornlike/uponLimb                                                                                            :2_1:When:
***** / preambleParamText:[Upon]                                                                                    :2_1:When:
****** / $>|                                                                                                       :2_1:When:
$>|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=10:
$>|> unexpected WHEN
$>|> expecting UPON

preambleParamText:[Upon]> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=10:
preambleParamText:[Upon]> unexpected WHEN
preambleParamText:[Upon]> expecting UPON

pHornlike/uponLimb> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pHornlike/uponLimb> MATCH (EERR): <EMPTY>
pHornlike/uponLimb> ERROR:
pHornlike/uponLimb> offset=10:
pHornlike/uponLimb> unexpected WHEN
pHornlike/uponLimb> expecting UPON

**** / pHornlike/givenLimb                                                                                           :2_1:When:
***** / preambleParamText:[Given]                                                                                   :2_1:When:
****** / $>|                                                                                                       :2_1:When:
$>|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=10:
$>|> unexpected WHEN
$>|> expecting GIVEN

preambleParamText:[Given]> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=10:
preambleParamText:[Given]> unexpected WHEN
preambleParamText:[Given]> expecting GIVEN

pHornlike/givenLimb> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pHornlike/givenLimb> MATCH (EERR): <EMPTY>
pHornlike/givenLimb> ERROR:
pHornlike/givenLimb> offset=10:
pHornlike/givenLimb> unexpected WHEN
pHornlike/givenLimb> expecting GIVEN

pTypeDefinition> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pTypeDefinition> MATCH (EERR): <EMPTY>
pTypeDefinition> ERROR:
pTypeDefinition> offset=10:
pTypeDefinition> unexpected WHEN
pTypeDefinition> expecting DEFINE, GIVEN, UPON, or §

*** / pConstitutiveRule                                                                                               :2_1:When:
**** / pRuleLabel                                                                                                    :2_1:When:
***** / $>|                                                                                                         :2_1:When:
$>|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=10:
$>|> unexpected WHEN
$>|> expecting §

pRuleLabel> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pRuleLabel> MATCH (EERR): <EMPTY>
pRuleLabel> ERROR:
pRuleLabel> offset=10:
pRuleLabel> unexpected WHEN
pRuleLabel> expecting §

**** / calling myindented pNameParens                                                                                :2_1:When:
***** / manyIndentation/leaf?                                                                                       :2_1:When:
****** / pMultiTermAka                                                                                             :2_1:When:
******* / pAKA                                                                                                    :2_1:When:
******** / slAKA                                                                                                 :2_1:When:
********* / $*|                                                                                                 :2_1:When:
********** / slAKA base                                                                                        :2_1:When:
*********** / slMultiTerm                                                                                     :2_1:When:
************ / someSL                                                                                        :2_1:When:
************* / pNumAsText                                                                                  :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

slAKA base> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=10:
slAKA base> unexpected WHEN
slAKA base> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

slAKA> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=10:
slAKA> unexpected WHEN
slAKA> expecting other text or number

pAKA> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pAKA> MATCH (EERR): <EMPTY>
pAKA> ERROR:
pAKA> offset=10:
pAKA> unexpected WHEN
pAKA> expecting other text or number

pMultiTermAka> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pMultiTermAka> MATCH (EERR): <EMPTY>
pMultiTermAka> ERROR:
pMultiTermAka> offset=10:
pMultiTermAka> unexpected WHEN
pMultiTermAka> expecting other text or number

manyIndentation/leaf?> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
manyIndentation/leaf?> MATCH (EERR): <EMPTY>
manyIndentation/leaf?> ERROR:
manyIndentation/leaf?> offset=10:
manyIndentation/leaf?> unexpected WHEN
manyIndentation/leaf?> expecting other text or number

***** / manyIndentation/deeper; calling someIndentation                                                             :2_1:When:
****** / someIndentation                                                                                           :2_1:When:
******* / myindented: consuming GoDeeper                                                                          :2_1:When:
myindented: consuming GoDeeper> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=10:
myindented: consuming GoDeeper> unexpected WHEN
myindented: consuming GoDeeper> expecting (

someIndentation> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=10:
someIndentation> unexpected WHEN
someIndentation> expecting (

manyIndentation/deeper; calling someIndentation> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
manyIndentation/deeper; calling someIndentation> MATCH (EERR): <EMPTY>
manyIndentation/deeper; calling someIndentation> ERROR:
manyIndentation/deeper; calling someIndentation> offset=10:
manyIndentation/deeper; calling someIndentation> unexpected WHEN
manyIndentation/deeper; calling someIndentation> expecting (

calling myindented pNameParens> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
calling myindented pNameParens> MATCH (EERR): <EMPTY>
calling myindented pNameParens> ERROR:
calling myindented pNameParens> offset=10:
calling myindented pNameParens> unexpected WHEN
calling myindented pNameParens> expecting ( or other text or number

pConstitutiveRule> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pConstitutiveRule> MATCH (EERR): <EMPTY>
pConstitutiveRule> ERROR:
pConstitutiveRule> offset=10:
pConstitutiveRule> unexpected WHEN
pConstitutiveRule> expecting (, other text or number, or §

*** / pScenarioRule                                                                                                   :2_1:When:
**** / pRuleLabel                                                                                                    :2_1:When:
***** / $>|                                                                                                         :2_1:When:
$>|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=10:
$>|> unexpected WHEN
$>|> expecting §

pRuleLabel> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pRuleLabel> MATCH (EERR): <EMPTY>
pRuleLabel> ERROR:
pRuleLabel> offset=10:
pRuleLabel> unexpected WHEN
pRuleLabel> expecting §

**** / pExpect                                                                                                       :2_1:When:
pExpect> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pExpect> MATCH (EERR): <EMPTY>
pExpect> ERROR:
pExpect> offset=10:
pExpect> unexpected WHEN
pExpect> expecting EXPECT

pScenarioRule> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pScenarioRule> MATCH (EERR): <EMPTY>
pScenarioRule> ERROR:
pScenarioRule> offset=10:
pScenarioRule> unexpected WHEN
pScenarioRule> expecting EXPECT, GIVEN, or §

*** / pHornlike                                                                                                       :2_1:When:
**** / pSrcRef                                                                                                       :2_1:When:
***** / pRuleLabel                                                                                                  :2_1:When:
****** / $>|                                                                                                       :2_1:When:
$>|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=10:
$>|> unexpected WHEN
$>|> expecting §

pRuleLabel> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pRuleLabel> MATCH (EERR): <EMPTY>
pRuleLabel> ERROR:
pRuleLabel> offset=10:
pRuleLabel> unexpected WHEN
pRuleLabel> expecting §

pSrcRef> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pSrcRef> MATCH (EOK): <EMPTY>
pSrcRef> VALUE: ((Nothing,Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 1, srccol = 2, version = Nothing})),[])

**** \ pSrcRef has returned (Nothing,Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 1, srccol = 2, version = Nothing})) :2_1:When:
**** / pHornlike / permute                                                                                           :2_1:When:
***** / whenCase                                                                                                    :2_1:When:
****** / whenMeansIf                                                                                               :2_1:When:
whenMeansIf> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
whenMeansIf> MATCH (COK): WHEN
whenMeansIf> VALUE: (When,[])

****** \ whenMeansIf has returned When                                                                              :2_2:GoDeeper:
****** / pBSR                                                                                                       :2_2:GoDeeper:
******* / ppp inner                                                                                                :2_2:GoDeeper:
******** / expression                                                                                             :2_2:GoDeeper:
********* / labelPrefix                                                                                          :2_2:GoDeeper:
labelPrefix> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=11:
labelPrefix> unexpected (
labelPrefix> expecting Other text

********* / term p                                                                                               :2_2:GoDeeper:
********** / term p/notLabelTerm                                                                                :2_2:GoDeeper:
*********** / term p/2:someIndentation expr p                                                                  :2_2:GoDeeper:
************ / someIndentation                                                                                :2_2:GoDeeper:
************* / myindented: consuming GoDeeper                                                               :2_2:GoDeeper:
myindented: consuming GoDeeper> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
myindented: consuming GoDeeper> MATCH (COK): (
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

************* \ myindented: consuming GoDeeper has returned GoDeeper                                          :2_2:Other "Z":
************* / manyIndentation/leaf?                                                                         :2_2:Other "Z":
************** / expression                                                                                  :2_2:Other "Z":
*************** / labelPrefix                                                                               :2_2:Other "Z":
labelPrefix> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
labelPrefix> MATCH (COK): "Z"
labelPrefix> VALUE: ("Z",[])

*************** \ labelPrefix has returned "Z"                                                               :2_3:GoDeeper:
*************** / term p                                                                                     :2_3:GoDeeper:
**************** / term p/notLabelTerm                                                                      :2_3:GoDeeper:
***************** / term p/2:someIndentation expr p                                                        :2_3:GoDeeper:
****************** / someIndentation                                                                      :2_3:GoDeeper:
******************* / myindented: consuming GoDeeper                                                     :2_3:GoDeeper:
myindented: consuming GoDeeper> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
myindented: consuming GoDeeper> MATCH (COK): (
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

******************* \ myindented: consuming GoDeeper has returned GoDeeper                                :2_3:Is:
******************* / manyIndentation/leaf?                                                               :2_3:Is:
******************** / expression                                                                        :2_3:Is:
********************* / labelPrefix                                                                     :2_3:Is:
labelPrefix> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=14:
labelPrefix> unexpected IS
labelPrefix> expecting Other text

********************* / term p                                                                          :2_3:Is:
********************** / term p/notLabelTerm                                                           :2_3:Is:
*********************** / term p/2:someIndentation expr p                                             :2_3:Is:
************************ / someIndentation                                                           :2_3:Is:
************************* / myindented: consuming GoDeeper                                          :2_3:Is:
myindented: consuming GoDeeper> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=14:
myindented: consuming GoDeeper> unexpected IS
myindented: consuming GoDeeper> expecting (

someIndentation> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting (

term p/2:someIndentation expr p> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p/2:someIndentation expr p> MATCH (EERR): <EMPTY>
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=14:
term p/2:someIndentation expr p> unexpected IS
term p/2:someIndentation expr p> expecting (

*********************** / term p/3:plain p                                                            :2_3:Is:
************************ / pRelPred                                                                  :2_3:Is:
************************* / slRelPred                                                               :2_3:Is:
************************** / nested simpleHorn                                                     :2_3:Is:
*************************** > |^|                                                                 :2_3:Is:
*************************** / $*|                                                                 :2_3:Is:
**************************** / slMultiTerm                                                       :2_3:Is:
***************************** / someSL                                                          :2_3:Is:
****************************** / pNumAsText                                                    :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

nested simpleHorn> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=14:
nested simpleHorn> unexpected IS
nested simpleHorn> expecting other text or number

************************** / RPConstraint                                                          :2_3:Is:
*************************** / $*|                                                                 :2_3:Is:
**************************** / slMultiTerm                                                       :2_3:Is:
***************************** / someSL                                                          :2_3:Is:
****************************** / pNumAsText                                                    :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

RPConstraint> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=14:
RPConstraint> unexpected IS
RPConstraint> expecting other text or number

************************** / RPBoolStructR                                                         :2_3:Is:
*************************** / $*|                                                                 :2_3:Is:
**************************** / slMultiTerm                                                       :2_3:Is:
***************************** / someSL                                                          :2_3:Is:
****************************** / pNumAsText                                                    :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

RPBoolStructR> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=14:
RPBoolStructR> unexpected IS
RPBoolStructR> expecting other text or number

************************** / RPMT                                                                  :2_3:Is:
*************************** / $*|                                                                 :2_3:Is:
**************************** / slAKA                                                             :2_3:Is:
***************************** / $*|                                                             :2_3:Is:
****************************** / slAKA base                                                    :2_3:Is:
******************************* / slMultiTerm                                                 :2_3:Is:
******************************** / someSL                                                    :2_3:Is:
********************************* / pNumAsText                                              :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

slAKA base> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=14:
slAKA base> unexpected IS
slAKA base> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

slAKA> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=14:
slAKA> unexpected IS
slAKA> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

RPMT> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=14:
RPMT> unexpected IS
RPMT> expecting other text or number

slRelPred> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=14:
slRelPred> unexpected IS
slRelPred> expecting other text or number

pRelPred> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pRelPred> MATCH (EERR): <EMPTY>
pRelPred> ERROR:
pRelPred> offset=14:
pRelPred> unexpected IS
pRelPred> expecting other text or number

term p/3:plain p> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p/3:plain p> MATCH (EERR): <EMPTY>
term p/3:plain p> ERROR:
term p/3:plain p> offset=14:
term p/3:plain p> unexpected IS
term p/3:plain p> expecting other text or number

term p/notLabelTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p/notLabelTerm> MATCH (EERR): <EMPTY>
term p/notLabelTerm> ERROR:
term p/notLabelTerm> offset=14:
term p/notLabelTerm> unexpected IS
term p/notLabelTerm> expecting ( or term

term p> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p> MATCH (EERR): <EMPTY>
term p> ERROR:
term p> offset=14:
term p> unexpected IS
term p> expecting ( or term

expression> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
expression> MATCH (EERR): <EMPTY>
expression> ERROR:
expression> offset=14:
expression> unexpected IS
expression> expecting expression

manyIndentation/leaf?> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
manyIndentation/leaf?> MATCH (EERR): <EMPTY>
manyIndentation/leaf?> ERROR:
manyIndentation/leaf?> offset=14:
manyIndentation/leaf?> unexpected IS
manyIndentation/leaf?> expecting expression

******************* / manyIndentation/deeper; calling someIndentation                                     :2_3:Is:
******************** / someIndentation                                                                   :2_3:Is:
********************* / myindented: consuming GoDeeper                                                  :2_3:Is:
myindented: consuming GoDeeper> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=14:
myindented: consuming GoDeeper> unexpected IS
myindented: consuming GoDeeper> expecting (

someIndentation> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting (

manyIndentation/deeper; calling someIndentation> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
manyIndentation/deeper; calling someIndentation> MATCH (EERR): <EMPTY>
manyIndentation/deeper; calling someIndentation> ERROR:
manyIndentation/deeper; calling someIndentation> offset=14:
manyIndentation/deeper; calling someIndentation> unexpected IS
manyIndentation/deeper; calling someIndentation> expecting (

someIndentation> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someIndentation> MATCH (CERR): (
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting ( or expression

term p/2:someIndentation expr p> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p/2:someIndentation expr p> MATCH (CERR): (
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=14:
term p/2:someIndentation expr p> unexpected IS
term p/2:someIndentation expr p> expecting ( or expression

***************** / term p/3:plain p                                                                       :2_3:GoDeeper:
****************** / pRelPred                                                                             :2_3:GoDeeper:
******************* / slRelPred                                                                          :2_3:GoDeeper:
******************** / nested simpleHorn                                                                :2_3:GoDeeper:
********************* > |^|                                                                            :2_3:GoDeeper:
********************* / $*|                                                                            :2_3:GoDeeper:
********************** / slMultiTerm                                                                  :2_3:GoDeeper:
*********************** / someSL                                                                     :2_3:GoDeeper:
************************ / pNumAsText                                                               :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

nested simpleHorn> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=13:
nested simpleHorn> unexpected (
nested simpleHorn> expecting other text or number

******************** / RPConstraint                                                                     :2_3:GoDeeper:
********************* / $*|                                                                            :2_3:GoDeeper:
********************** / slMultiTerm                                                                  :2_3:GoDeeper:
*********************** / someSL                                                                     :2_3:GoDeeper:
************************ / pNumAsText                                                               :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

RPConstraint> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=13:
RPConstraint> unexpected (
RPConstraint> expecting other text or number

******************** / RPBoolStructR                                                                    :2_3:GoDeeper:
********************* / $*|                                                                            :2_3:GoDeeper:
********************** / slMultiTerm                                                                  :2_3:GoDeeper:
*********************** / someSL                                                                     :2_3:GoDeeper:
************************ / pNumAsText                                                               :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

RPBoolStructR> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=13:
RPBoolStructR> unexpected (
RPBoolStructR> expecting other text or number

******************** / RPMT                                                                             :2_3:GoDeeper:
********************* / $*|                                                                            :2_3:GoDeeper:
********************** / slAKA                                                                        :2_3:GoDeeper:
*********************** / $*|                                                                        :2_3:GoDeeper:
************************ / slAKA base                                                               :2_3:GoDeeper:
************************* / slMultiTerm                                                            :2_3:GoDeeper:
************************** / someSL                                                               :2_3:GoDeeper:
*************************** / pNumAsText                                                         :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

slAKA base> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=13:
slAKA base> unexpected (
slAKA base> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

slAKA> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=13:
slAKA> unexpected (
slAKA> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

RPMT> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=13:
RPMT> unexpected (
RPMT> expecting other text or number

slRelPred> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=13:
slRelPred> unexpected (
slRelPred> expecting other text or number

pRelPred> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pRelPred> MATCH (EERR): <EMPTY>
pRelPred> ERROR:
pRelPred> offset=13:
pRelPred> unexpected (
pRelPred> expecting other text or number

term p/3:plain p> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p/3:plain p> MATCH (EERR): <EMPTY>
term p/3:plain p> ERROR:
term p/3:plain p> offset=13:
term p/3:plain p> unexpected (
term p/3:plain p> expecting other text or number

term p/notLabelTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p/notLabelTerm> MATCH (EERR): <EMPTY>
term p/notLabelTerm> ERROR:
term p/notLabelTerm> offset=14:
term p/notLabelTerm> unexpected IS
term p/notLabelTerm> expecting ( or expression

term p> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p> MATCH (EERR): <EMPTY>
term p> ERROR:
term p> offset=14:
term p> unexpected IS
term p> expecting ( or expression

expression> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
expression> MATCH (CERR): "Z"
expression> ERROR:
expression> offset=14:
expression> unexpected IS
expression> expecting (, NOT, or expression

manyIndentation/leaf?> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
manyIndentation/leaf?> MATCH (EERR): <EMPTY>
manyIndentation/leaf?> ERROR:
manyIndentation/leaf?> offset=14:
manyIndentation/leaf?> unexpected IS
manyIndentation/leaf?> expecting (, NOT, or expression

************* / manyIndentation/deeper; calling someIndentation                                               :2_2:Other "Z":
************** / someIndentation                                                                             :2_2:Other "Z":
*************** / myindented: consuming GoDeeper                                                            :2_2:Other "Z":
myindented: consuming GoDeeper> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=12:
myindented: consuming GoDeeper> unexpected "Z"
myindented: consuming GoDeeper> expecting (

someIndentation> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=12:
someIndentation> unexpected "Z"
someIndentation> expecting (

manyIndentation/deeper; calling someIndentation> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
manyIndentation/deeper; calling someIndentation> MATCH (EERR): <EMPTY>
manyIndentation/deeper; calling someIndentation> ERROR:
manyIndentation/deeper; calling someIndentation> offset=12:
manyIndentation/deeper; calling someIndentation> unexpected "Z"
manyIndentation/deeper; calling someIndentation> expecting (

someIndentation> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someIndentation> MATCH (CERR): (
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting (, NOT, or expression

term p/2:someIndentation expr p> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p/2:someIndentation expr p> MATCH (CERR): (
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=14:
term p/2:someIndentation expr p> unexpected IS
term p/2:someIndentation expr p> expecting (, NOT, or expression

*********** / term p/3:plain p                                                                                 :2_2:GoDeeper:
************ / pRelPred                                                                                       :2_2:GoDeeper:
************* / slRelPred                                                                                    :2_2:GoDeeper:
************** / nested simpleHorn                                                                          :2_2:GoDeeper:
*************** > |^|                                                                                      :2_2:GoDeeper:
*************** / $*|                                                                                      :2_2:GoDeeper:
**************** / slMultiTerm                                                                            :2_2:GoDeeper:
***************** / someSL                                                                               :2_2:GoDeeper:
****************** / pNumAsText                                                                         :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

nested simpleHorn> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=11:
nested simpleHorn> unexpected (
nested simpleHorn> expecting other text or number

************** / RPConstraint                                                                               :2_2:GoDeeper:
*************** / $*|                                                                                      :2_2:GoDeeper:
**************** / slMultiTerm                                                                            :2_2:GoDeeper:
***************** / someSL                                                                               :2_2:GoDeeper:
****************** / pNumAsText                                                                         :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

RPConstraint> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=11:
RPConstraint> unexpected (
RPConstraint> expecting other text or number

************** / RPBoolStructR                                                                              :2_2:GoDeeper:
*************** / $*|                                                                                      :2_2:GoDeeper:
**************** / slMultiTerm                                                                            :2_2:GoDeeper:
***************** / someSL                                                                               :2_2:GoDeeper:
****************** / pNumAsText                                                                         :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

RPBoolStructR> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=11:
RPBoolStructR> unexpected (
RPBoolStructR> expecting other text or number

************** / RPMT                                                                                       :2_2:GoDeeper:
*************** / $*|                                                                                      :2_2:GoDeeper:
**************** / slAKA                                                                                  :2_2:GoDeeper:
***************** / $*|                                                                                  :2_2:GoDeeper:
****************** / slAKA base                                                                         :2_2:GoDeeper:
******************* / slMultiTerm                                                                      :2_2:GoDeeper:
******************** / someSL                                                                         :2_2:GoDeeper:
********************* / pNumAsText                                                                   :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

slAKA base> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=11:
slAKA base> unexpected (
slAKA base> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

slAKA> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=11:
slAKA> unexpected (
slAKA> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

RPMT> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=11:
RPMT> unexpected (
RPMT> expecting other text or number

slRelPred> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=11:
slRelPred> unexpected (
slRelPred> expecting other text or number

pRelPred> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pRelPred> MATCH (EERR): <EMPTY>
pRelPred> ERROR:
pRelPred> offset=11:
pRelPred> unexpected (
pRelPred> expecting other text or number

term p/3:plain p> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p/3:plain p> MATCH (EERR): <EMPTY>
term p/3:plain p> ERROR:
term p/3:plain p> offset=11:
term p/3:plain p> unexpected (
term p/3:plain p> expecting other text or number

term p/notLabelTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p/notLabelTerm> MATCH (EERR): <EMPTY>
term p/notLabelTerm> ERROR:
term p/notLabelTerm> offset=14:
term p/notLabelTerm> unexpected IS
term p/notLabelTerm> expecting (, NOT, or expression

term p> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p> MATCH (EERR): <EMPTY>
term p> ERROR:
term p> offset=14:
term p> unexpected IS
term p> expecting (, NOT, or expression

expression> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
expression> MATCH (EERR): <EMPTY>
expression> ERROR:
expression> offset=14:
expression> unexpected IS
expression> expecting expression

ppp inner> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
ppp inner> MATCH (EERR): <EMPTY>
ppp inner> ERROR:
ppp inner> offset=14:
ppp inner> unexpected IS
ppp inner> expecting expression

******* / withPrePost                                                                                              :2_2:GoDeeper:
******** > |<* starting                                                                                           :2_2:GoDeeper:
******** / $*|                                                                                                    :2_2:GoDeeper:
********* / pre part                                                                                             :2_2:GoDeeper:
********** / aboveNextLineKeyword                                                                                :2_2:Other "Z":
*********** / expectUnDeepers                                                                                   :2_2:Other "Z":
************ / pNumAsText                                                                                       :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
expectUnDeepers> MATCH (CERR): "Z" (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
aboveNextLineKeyword> MATCH (CERR): "Z" (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                       :2_2:Other "Z":
********** / aboveNextLineKeyword                                                                                 :2_3:GoDeeper:
*********** / expectUnDeepers                                                                                    :2_3:GoDeeper:
************ / pNumAsText                                                                                       :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
expectUnDeepers> MATCH (CERR): (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
aboveNextLineKeyword> MATCH (CERR): (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                        :2_3:GoDeeper:
********** / aboveNextLineKeyword                                                                                  :2_3:Is:
*********** / expectUnDeepers                                                                                     :2_3:Is:
************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
expectUnDeepers> MATCH (EERR): <EMPTY>
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
aboveNextLineKeyword> MATCH (EERR): <EMPTY>
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                         :2_3:Is:
pre part> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pre part> MATCH (CERR): (
pre part> ERROR:
pre part> offset=14:
pre part> unexpected IS
pre part> expecting (, ), Other text, or other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (CERR): (
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting (, ), Other text, or other text or number

withPrePost> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
withPrePost> MATCH (CERR): (
withPrePost> ERROR:
withPrePost> offset=14:
withPrePost> unexpected IS
withPrePost> expecting (, ), Other text, or other text or number

******* / withPreOnly                                                                                              :2_2:GoDeeper:
******** / $*|                                                                                                    :2_2:GoDeeper:
********* / pre part                                                                                             :2_2:GoDeeper:
********** / aboveNextLineKeyword                                                                                :2_2:Other "Z":
*********** / expectUnDeepers                                                                                   :2_2:Other "Z":
************ / pNumAsText                                                                                       :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
expectUnDeepers> MATCH (CERR): "Z" (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
aboveNextLineKeyword> MATCH (CERR): "Z" (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                       :2_2:Other "Z":
********** / aboveNextLineKeyword                                                                                 :2_3:GoDeeper:
*********** / expectUnDeepers                                                                                    :2_3:GoDeeper:
************ / pNumAsText                                                                                       :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
expectUnDeepers> MATCH (CERR): (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
aboveNextLineKeyword> MATCH (CERR): (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                        :2_3:GoDeeper:
********** / aboveNextLineKeyword                                                                                  :2_3:Is:
*********** / expectUnDeepers                                                                                     :2_3:Is:
************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
expectUnDeepers> MATCH (EERR): <EMPTY>
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
aboveNextLineKeyword> MATCH (EERR): <EMPTY>
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                         :2_3:Is:
pre part> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pre part> MATCH (CERR): (
pre part> ERROR:
pre part> offset=14:
pre part> unexpected IS
pre part> expecting (, ), Other text, or other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (CERR): (
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting (, ), Other text, or other text or number

withPreOnly> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
withPreOnly> MATCH (CERR): (
withPreOnly> ERROR:
withPreOnly> offset=14:
withPreOnly> unexpected IS
withPreOnly> expecting (, ), Other text, or other text or number

pBSR> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pBSR> MATCH (CERR): (
pBSR> ERROR:
pBSR> offset=14:
pBSR> unexpected IS
pBSR> expecting (, ), Other text, expression, or other text or number

****** / Otherwise                                                                                                 :2_1:When:
Otherwise> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
Otherwise> MATCH (EERR): <EMPTY>
Otherwise> ERROR:
Otherwise> offset=10:
Otherwise> unexpected WHEN
Otherwise> expecting OTHERWISE

whenCase> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
whenCase> MATCH (EERR): <EMPTY>
whenCase> ERROR:
whenCase> offset=14:
whenCase> unexpected IS
whenCase> expecting (, ), Other text, expression, or other text or number

***** / pHornlike/uponLimb                                                                                          :2_1:When:
****** / preambleParamText:[Upon]                                                                                  :2_1:When:
******* / $>|                                                                                                     :2_1:When:
$>|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=10:
$>|> unexpected WHEN
$>|> expecting UPON

preambleParamText:[Upon]> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=10:
preambleParamText:[Upon]> unexpected WHEN
preambleParamText:[Upon]> expecting UPON

pHornlike/uponLimb> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pHornlike/uponLimb> MATCH (EERR): <EMPTY>
pHornlike/uponLimb> ERROR:
pHornlike/uponLimb> offset=10:
pHornlike/uponLimb> unexpected WHEN
pHornlike/uponLimb> expecting UPON

***** / whenCase                                                                                                    :2_1:When:
****** / whenMeansIf                                                                                               :2_1:When:
whenMeansIf> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
whenMeansIf> MATCH (COK): WHEN
whenMeansIf> VALUE: (When,[])

****** \ whenMeansIf has returned When                                                                              :2_2:GoDeeper:
****** / pBSR                                                                                                       :2_2:GoDeeper:
******* / ppp inner                                                                                                :2_2:GoDeeper:
******** / expression                                                                                             :2_2:GoDeeper:
********* / labelPrefix                                                                                          :2_2:GoDeeper:
labelPrefix> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=11:
labelPrefix> unexpected (
labelPrefix> expecting Other text

********* / term p                                                                                               :2_2:GoDeeper:
********** / term p/notLabelTerm                                                                                :2_2:GoDeeper:
*********** / term p/2:someIndentation expr p                                                                  :2_2:GoDeeper:
************ / someIndentation                                                                                :2_2:GoDeeper:
************* / myindented: consuming GoDeeper                                                               :2_2:GoDeeper:
myindented: consuming GoDeeper> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
myindented: consuming GoDeeper> MATCH (COK): (
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

************* \ myindented: consuming GoDeeper has returned GoDeeper                                          :2_2:Other "Z":
************* / manyIndentation/leaf?                                                                         :2_2:Other "Z":
************** / expression                                                                                  :2_2:Other "Z":
*************** / labelPrefix                                                                               :2_2:Other "Z":
labelPrefix> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
labelPrefix> MATCH (COK): "Z"
labelPrefix> VALUE: ("Z",[])

*************** \ labelPrefix has returned "Z"                                                               :2_3:GoDeeper:
*************** / term p                                                                                     :2_3:GoDeeper:
**************** / term p/notLabelTerm                                                                      :2_3:GoDeeper:
***************** / term p/2:someIndentation expr p                                                        :2_3:GoDeeper:
****************** / someIndentation                                                                      :2_3:GoDeeper:
******************* / myindented: consuming GoDeeper                                                     :2_3:GoDeeper:
myindented: consuming GoDeeper> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
myindented: consuming GoDeeper> MATCH (COK): (
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

******************* \ myindented: consuming GoDeeper has returned GoDeeper                                :2_3:Is:
******************* / manyIndentation/leaf?                                                               :2_3:Is:
******************** / expression                                                                        :2_3:Is:
********************* / labelPrefix                                                                     :2_3:Is:
labelPrefix> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=14:
labelPrefix> unexpected IS
labelPrefix> expecting Other text

********************* / term p                                                                          :2_3:Is:
********************** / term p/notLabelTerm                                                           :2_3:Is:
*********************** / term p/2:someIndentation expr p                                             :2_3:Is:
************************ / someIndentation                                                           :2_3:Is:
************************* / myindented: consuming GoDeeper                                          :2_3:Is:
myindented: consuming GoDeeper> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=14:
myindented: consuming GoDeeper> unexpected IS
myindented: consuming GoDeeper> expecting (

someIndentation> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting (

term p/2:someIndentation expr p> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p/2:someIndentation expr p> MATCH (EERR): <EMPTY>
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=14:
term p/2:someIndentation expr p> unexpected IS
term p/2:someIndentation expr p> expecting (

*********************** / term p/3:plain p                                                            :2_3:Is:
************************ / pRelPred                                                                  :2_3:Is:
************************* / slRelPred                                                               :2_3:Is:
************************** / nested simpleHorn                                                     :2_3:Is:
*************************** > |^|                                                                 :2_3:Is:
*************************** / $*|                                                                 :2_3:Is:
**************************** / slMultiTerm                                                       :2_3:Is:
***************************** / someSL                                                          :2_3:Is:
****************************** / pNumAsText                                                    :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

nested simpleHorn> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=14:
nested simpleHorn> unexpected IS
nested simpleHorn> expecting other text or number

************************** / RPConstraint                                                          :2_3:Is:
*************************** / $*|                                                                 :2_3:Is:
**************************** / slMultiTerm                                                       :2_3:Is:
***************************** / someSL                                                          :2_3:Is:
****************************** / pNumAsText                                                    :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

RPConstraint> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=14:
RPConstraint> unexpected IS
RPConstraint> expecting other text or number

************************** / RPBoolStructR                                                         :2_3:Is:
*************************** / $*|                                                                 :2_3:Is:
**************************** / slMultiTerm                                                       :2_3:Is:
***************************** / someSL                                                          :2_3:Is:
****************************** / pNumAsText                                                    :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

RPBoolStructR> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=14:
RPBoolStructR> unexpected IS
RPBoolStructR> expecting other text or number

************************** / RPMT                                                                  :2_3:Is:
*************************** / $*|                                                                 :2_3:Is:
**************************** / slAKA                                                             :2_3:Is:
***************************** / $*|                                                             :2_3:Is:
****************************** / slAKA base                                                    :2_3:Is:
******************************* / slMultiTerm                                                 :2_3:Is:
******************************** / someSL                                                    :2_3:Is:
********************************* / pNumAsText                                              :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

slAKA base> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=14:
slAKA base> unexpected IS
slAKA base> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

slAKA> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=14:
slAKA> unexpected IS
slAKA> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

RPMT> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=14:
RPMT> unexpected IS
RPMT> expecting other text or number

slRelPred> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=14:
slRelPred> unexpected IS
slRelPred> expecting other text or number

pRelPred> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pRelPred> MATCH (EERR): <EMPTY>
pRelPred> ERROR:
pRelPred> offset=14:
pRelPred> unexpected IS
pRelPred> expecting other text or number

term p/3:plain p> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p/3:plain p> MATCH (EERR): <EMPTY>
term p/3:plain p> ERROR:
term p/3:plain p> offset=14:
term p/3:plain p> unexpected IS
term p/3:plain p> expecting other text or number

term p/notLabelTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p/notLabelTerm> MATCH (EERR): <EMPTY>
term p/notLabelTerm> ERROR:
term p/notLabelTerm> offset=14:
term p/notLabelTerm> unexpected IS
term p/notLabelTerm> expecting ( or term

term p> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p> MATCH (EERR): <EMPTY>
term p> ERROR:
term p> offset=14:
term p> unexpected IS
term p> expecting ( or term

expression> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
expression> MATCH (EERR): <EMPTY>
expression> ERROR:
expression> offset=14:
expression> unexpected IS
expression> expecting expression

manyIndentation/leaf?> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
manyIndentation/leaf?> MATCH (EERR): <EMPTY>
manyIndentation/leaf?> ERROR:
manyIndentation/leaf?> offset=14:
manyIndentation/leaf?> unexpected IS
manyIndentation/leaf?> expecting expression

******************* / manyIndentation/deeper; calling someIndentation                                     :2_3:Is:
******************** / someIndentation                                                                   :2_3:Is:
********************* / myindented: consuming GoDeeper                                                  :2_3:Is:
myindented: consuming GoDeeper> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=14:
myindented: consuming GoDeeper> unexpected IS
myindented: consuming GoDeeper> expecting (

someIndentation> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting (

manyIndentation/deeper; calling someIndentation> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
manyIndentation/deeper; calling someIndentation> MATCH (EERR): <EMPTY>
manyIndentation/deeper; calling someIndentation> ERROR:
manyIndentation/deeper; calling someIndentation> offset=14:
manyIndentation/deeper; calling someIndentation> unexpected IS
manyIndentation/deeper; calling someIndentation> expecting (

someIndentation> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someIndentation> MATCH (CERR): (
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting ( or expression

term p/2:someIndentation expr p> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p/2:someIndentation expr p> MATCH (CERR): (
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=14:
term p/2:someIndentation expr p> unexpected IS
term p/2:someIndentation expr p> expecting ( or expression

***************** / term p/3:plain p                                                                       :2_3:GoDeeper:
****************** / pRelPred                                                                             :2_3:GoDeeper:
******************* / slRelPred                                                                          :2_3:GoDeeper:
******************** / nested simpleHorn                                                                :2_3:GoDeeper:
********************* > |^|                                                                            :2_3:GoDeeper:
********************* / $*|                                                                            :2_3:GoDeeper:
********************** / slMultiTerm                                                                  :2_3:GoDeeper:
*********************** / someSL                                                                     :2_3:GoDeeper:
************************ / pNumAsText                                                               :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

nested simpleHorn> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=13:
nested simpleHorn> unexpected (
nested simpleHorn> expecting other text or number

******************** / RPConstraint                                                                     :2_3:GoDeeper:
********************* / $*|                                                                            :2_3:GoDeeper:
********************** / slMultiTerm                                                                  :2_3:GoDeeper:
*********************** / someSL                                                                     :2_3:GoDeeper:
************************ / pNumAsText                                                               :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

RPConstraint> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=13:
RPConstraint> unexpected (
RPConstraint> expecting other text or number

******************** / RPBoolStructR                                                                    :2_3:GoDeeper:
********************* / $*|                                                                            :2_3:GoDeeper:
********************** / slMultiTerm                                                                  :2_3:GoDeeper:
*********************** / someSL                                                                     :2_3:GoDeeper:
************************ / pNumAsText                                                               :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

RPBoolStructR> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=13:
RPBoolStructR> unexpected (
RPBoolStructR> expecting other text or number

******************** / RPMT                                                                             :2_3:GoDeeper:
********************* / $*|                                                                            :2_3:GoDeeper:
********************** / slAKA                                                                        :2_3:GoDeeper:
*********************** / $*|                                                                        :2_3:GoDeeper:
************************ / slAKA base                                                               :2_3:GoDeeper:
************************* / slMultiTerm                                                            :2_3:GoDeeper:
************************** / someSL                                                               :2_3:GoDeeper:
*************************** / pNumAsText                                                         :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

slAKA base> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=13:
slAKA base> unexpected (
slAKA base> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

slAKA> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=13:
slAKA> unexpected (
slAKA> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

RPMT> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=13:
RPMT> unexpected (
RPMT> expecting other text or number

slRelPred> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=13:
slRelPred> unexpected (
slRelPred> expecting other text or number

pRelPred> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pRelPred> MATCH (EERR): <EMPTY>
pRelPred> ERROR:
pRelPred> offset=13:
pRelPred> unexpected (
pRelPred> expecting other text or number

term p/3:plain p> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p/3:plain p> MATCH (EERR): <EMPTY>
term p/3:plain p> ERROR:
term p/3:plain p> offset=13:
term p/3:plain p> unexpected (
term p/3:plain p> expecting other text or number

term p/notLabelTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p/notLabelTerm> MATCH (EERR): <EMPTY>
term p/notLabelTerm> ERROR:
term p/notLabelTerm> offset=14:
term p/notLabelTerm> unexpected IS
term p/notLabelTerm> expecting ( or expression

term p> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p> MATCH (EERR): <EMPTY>
term p> ERROR:
term p> offset=14:
term p> unexpected IS
term p> expecting ( or expression

expression> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
expression> MATCH (CERR): "Z"
expression> ERROR:
expression> offset=14:
expression> unexpected IS
expression> expecting (, NOT, or expression

manyIndentation/leaf?> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
manyIndentation/leaf?> MATCH (EERR): <EMPTY>
manyIndentation/leaf?> ERROR:
manyIndentation/leaf?> offset=14:
manyIndentation/leaf?> unexpected IS
manyIndentation/leaf?> expecting (, NOT, or expression

************* / manyIndentation/deeper; calling someIndentation                                               :2_2:Other "Z":
************** / someIndentation                                                                             :2_2:Other "Z":
*************** / myindented: consuming GoDeeper                                                            :2_2:Other "Z":
myindented: consuming GoDeeper> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=12:
myindented: consuming GoDeeper> unexpected "Z"
myindented: consuming GoDeeper> expecting (

someIndentation> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=12:
someIndentation> unexpected "Z"
someIndentation> expecting (

manyIndentation/deeper; calling someIndentation> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
manyIndentation/deeper; calling someIndentation> MATCH (EERR): <EMPTY>
manyIndentation/deeper; calling someIndentation> ERROR:
manyIndentation/deeper; calling someIndentation> offset=12:
manyIndentation/deeper; calling someIndentation> unexpected "Z"
manyIndentation/deeper; calling someIndentation> expecting (

someIndentation> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someIndentation> MATCH (CERR): (
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting (, NOT, or expression

term p/2:someIndentation expr p> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p/2:someIndentation expr p> MATCH (CERR): (
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=14:
term p/2:someIndentation expr p> unexpected IS
term p/2:someIndentation expr p> expecting (, NOT, or expression

*********** / term p/3:plain p                                                                                 :2_2:GoDeeper:
************ / pRelPred                                                                                       :2_2:GoDeeper:
************* / slRelPred                                                                                    :2_2:GoDeeper:
************** / nested simpleHorn                                                                          :2_2:GoDeeper:
*************** > |^|                                                                                      :2_2:GoDeeper:
*************** / $*|                                                                                      :2_2:GoDeeper:
**************** / slMultiTerm                                                                            :2_2:GoDeeper:
***************** / someSL                                                                               :2_2:GoDeeper:
****************** / pNumAsText                                                                         :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

nested simpleHorn> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=11:
nested simpleHorn> unexpected (
nested simpleHorn> expecting other text or number

************** / RPConstraint                                                                               :2_2:GoDeeper:
*************** / $*|                                                                                      :2_2:GoDeeper:
**************** / slMultiTerm                                                                            :2_2:GoDeeper:
***************** / someSL                                                                               :2_2:GoDeeper:
****************** / pNumAsText                                                                         :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

RPConstraint> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=11:
RPConstraint> unexpected (
RPConstraint> expecting other text or number

************** / RPBoolStructR                                                                              :2_2:GoDeeper:
*************** / $*|                                                                                      :2_2:GoDeeper:
**************** / slMultiTerm                                                                            :2_2:GoDeeper:
***************** / someSL                                                                               :2_2:GoDeeper:
****************** / pNumAsText                                                                         :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

RPBoolStructR> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=11:
RPBoolStructR> unexpected (
RPBoolStructR> expecting other text or number

************** / RPMT                                                                                       :2_2:GoDeeper:
*************** / $*|                                                                                      :2_2:GoDeeper:
**************** / slAKA                                                                                  :2_2:GoDeeper:
***************** / $*|                                                                                  :2_2:GoDeeper:
****************** / slAKA base                                                                         :2_2:GoDeeper:
******************* / slMultiTerm                                                                      :2_2:GoDeeper:
******************** / someSL                                                                         :2_2:GoDeeper:
********************* / pNumAsText                                                                   :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

slAKA base> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=11:
slAKA base> unexpected (
slAKA base> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

slAKA> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=11:
slAKA> unexpected (
slAKA> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

RPMT> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=11:
RPMT> unexpected (
RPMT> expecting other text or number

slRelPred> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=11:
slRelPred> unexpected (
slRelPred> expecting other text or number

pRelPred> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pRelPred> MATCH (EERR): <EMPTY>
pRelPred> ERROR:
pRelPred> offset=11:
pRelPred> unexpected (
pRelPred> expecting other text or number

term p/3:plain p> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p/3:plain p> MATCH (EERR): <EMPTY>
term p/3:plain p> ERROR:
term p/3:plain p> offset=11:
term p/3:plain p> unexpected (
term p/3:plain p> expecting other text or number

term p/notLabelTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p/notLabelTerm> MATCH (EERR): <EMPTY>
term p/notLabelTerm> ERROR:
term p/notLabelTerm> offset=14:
term p/notLabelTerm> unexpected IS
term p/notLabelTerm> expecting (, NOT, or expression

term p> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p> MATCH (EERR): <EMPTY>
term p> ERROR:
term p> offset=14:
term p> unexpected IS
term p> expecting (, NOT, or expression

expression> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
expression> MATCH (EERR): <EMPTY>
expression> ERROR:
expression> offset=14:
expression> unexpected IS
expression> expecting expression

ppp inner> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
ppp inner> MATCH (EERR): <EMPTY>
ppp inner> ERROR:
ppp inner> offset=14:
ppp inner> unexpected IS
ppp inner> expecting expression

******* / withPrePost                                                                                              :2_2:GoDeeper:
******** > |<* starting                                                                                           :2_2:GoDeeper:
******** / $*|                                                                                                    :2_2:GoDeeper:
********* / pre part                                                                                             :2_2:GoDeeper:
********** / aboveNextLineKeyword                                                                                :2_2:Other "Z":
*********** / expectUnDeepers                                                                                   :2_2:Other "Z":
************ / pNumAsText                                                                                       :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
expectUnDeepers> MATCH (CERR): "Z" (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
aboveNextLineKeyword> MATCH (CERR): "Z" (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                       :2_2:Other "Z":
********** / aboveNextLineKeyword                                                                                 :2_3:GoDeeper:
*********** / expectUnDeepers                                                                                    :2_3:GoDeeper:
************ / pNumAsText                                                                                       :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
expectUnDeepers> MATCH (CERR): (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
aboveNextLineKeyword> MATCH (CERR): (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                        :2_3:GoDeeper:
********** / aboveNextLineKeyword                                                                                  :2_3:Is:
*********** / expectUnDeepers                                                                                     :2_3:Is:
************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
expectUnDeepers> MATCH (EERR): <EMPTY>
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
aboveNextLineKeyword> MATCH (EERR): <EMPTY>
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                         :2_3:Is:
pre part> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pre part> MATCH (CERR): (
pre part> ERROR:
pre part> offset=14:
pre part> unexpected IS
pre part> expecting (, ), Other text, or other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (CERR): (
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting (, ), Other text, or other text or number

withPrePost> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
withPrePost> MATCH (CERR): (
withPrePost> ERROR:
withPrePost> offset=14:
withPrePost> unexpected IS
withPrePost> expecting (, ), Other text, or other text or number

******* / withPreOnly                                                                                              :2_2:GoDeeper:
******** / $*|                                                                                                    :2_2:GoDeeper:
********* / pre part                                                                                             :2_2:GoDeeper:
********** / aboveNextLineKeyword                                                                                :2_2:Other "Z":
*********** / expectUnDeepers                                                                                   :2_2:Other "Z":
************ / pNumAsText                                                                                       :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
expectUnDeepers> MATCH (CERR): "Z" (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
aboveNextLineKeyword> MATCH (CERR): "Z" (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                       :2_2:Other "Z":
********** / aboveNextLineKeyword                                                                                 :2_3:GoDeeper:
*********** / expectUnDeepers                                                                                    :2_3:GoDeeper:
************ / pNumAsText                                                                                       :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
expectUnDeepers> MATCH (CERR): (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
aboveNextLineKeyword> MATCH (CERR): (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                        :2_3:GoDeeper:
********** / aboveNextLineKeyword                                                                                  :2_3:Is:
*********** / expectUnDeepers                                                                                     :2_3:Is:
************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
expectUnDeepers> MATCH (EERR): <EMPTY>
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
aboveNextLineKeyword> MATCH (EERR): <EMPTY>
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                         :2_3:Is:
pre part> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pre part> MATCH (CERR): (
pre part> ERROR:
pre part> offset=14:
pre part> unexpected IS
pre part> expecting (, ), Other text, or other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (CERR): (
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting (, ), Other text, or other text or number

withPreOnly> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
withPreOnly> MATCH (CERR): (
withPreOnly> ERROR:
withPreOnly> offset=14:
withPreOnly> unexpected IS
withPreOnly> expecting (, ), Other text, or other text or number

pBSR> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pBSR> MATCH (CERR): (
pBSR> ERROR:
pBSR> offset=14:
pBSR> unexpected IS
pBSR> expecting (, ), Other text, expression, or other text or number

****** / Otherwise                                                                                                 :2_1:When:
Otherwise> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
Otherwise> MATCH (EERR): <EMPTY>
Otherwise> ERROR:
Otherwise> offset=10:
Otherwise> unexpected WHEN
Otherwise> expecting OTHERWISE

whenCase> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
whenCase> MATCH (EERR): <EMPTY>
whenCase> ERROR:
whenCase> offset=14:
whenCase> unexpected IS
whenCase> expecting (, ), Other text, expression, or other text or number

***** / pHornlike/givenLimb                                                                                         :2_1:When:
****** / preambleParamText:[Given]                                                                                 :2_1:When:
******* / $>|                                                                                                     :2_1:When:
$>|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=10:
$>|> unexpected WHEN
$>|> expecting GIVEN

preambleParamText:[Given]> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=10:
preambleParamText:[Given]> unexpected WHEN
preambleParamText:[Given]> expecting GIVEN

pHornlike/givenLimb> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pHornlike/givenLimb> MATCH (EERR): <EMPTY>
pHornlike/givenLimb> ERROR:
pHornlike/givenLimb> offset=10:
pHornlike/givenLimb> unexpected WHEN
pHornlike/givenLimb> expecting GIVEN

***** / whenCase                                                                                                    :2_1:When:
****** / whenMeansIf                                                                                               :2_1:When:
whenMeansIf> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
whenMeansIf> MATCH (COK): WHEN
whenMeansIf> VALUE: (When,[])

****** \ whenMeansIf has returned When                                                                              :2_2:GoDeeper:
****** / pBSR                                                                                                       :2_2:GoDeeper:
******* / ppp inner                                                                                                :2_2:GoDeeper:
******** / expression                                                                                             :2_2:GoDeeper:
********* / labelPrefix                                                                                          :2_2:GoDeeper:
labelPrefix> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=11:
labelPrefix> unexpected (
labelPrefix> expecting Other text

********* / term p                                                                                               :2_2:GoDeeper:
********** / term p/notLabelTerm                                                                                :2_2:GoDeeper:
*********** / term p/2:someIndentation expr p                                                                  :2_2:GoDeeper:
************ / someIndentation                                                                                :2_2:GoDeeper:
************* / myindented: consuming GoDeeper                                                               :2_2:GoDeeper:
myindented: consuming GoDeeper> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
myindented: consuming GoDeeper> MATCH (COK): (
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

************* \ myindented: consuming GoDeeper has returned GoDeeper                                          :2_2:Other "Z":
************* / manyIndentation/leaf?                                                                         :2_2:Other "Z":
************** / expression                                                                                  :2_2:Other "Z":
*************** / labelPrefix                                                                               :2_2:Other "Z":
labelPrefix> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
labelPrefix> MATCH (COK): "Z"
labelPrefix> VALUE: ("Z",[])

*************** \ labelPrefix has returned "Z"                                                               :2_3:GoDeeper:
*************** / term p                                                                                     :2_3:GoDeeper:
**************** / term p/notLabelTerm                                                                      :2_3:GoDeeper:
***************** / term p/2:someIndentation expr p                                                        :2_3:GoDeeper:
****************** / someIndentation                                                                      :2_3:GoDeeper:
******************* / myindented: consuming GoDeeper                                                     :2_3:GoDeeper:
myindented: consuming GoDeeper> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
myindented: consuming GoDeeper> MATCH (COK): (
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

******************* \ myindented: consuming GoDeeper has returned GoDeeper                                :2_3:Is:
******************* / manyIndentation/leaf?                                                               :2_3:Is:
******************** / expression                                                                        :2_3:Is:
********************* / labelPrefix                                                                     :2_3:Is:
labelPrefix> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=14:
labelPrefix> unexpected IS
labelPrefix> expecting Other text

********************* / term p                                                                          :2_3:Is:
********************** / term p/notLabelTerm                                                           :2_3:Is:
*********************** / term p/2:someIndentation expr p                                             :2_3:Is:
************************ / someIndentation                                                           :2_3:Is:
************************* / myindented: consuming GoDeeper                                          :2_3:Is:
myindented: consuming GoDeeper> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=14:
myindented: consuming GoDeeper> unexpected IS
myindented: consuming GoDeeper> expecting (

someIndentation> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting (

term p/2:someIndentation expr p> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p/2:someIndentation expr p> MATCH (EERR): <EMPTY>
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=14:
term p/2:someIndentation expr p> unexpected IS
term p/2:someIndentation expr p> expecting (

*********************** / term p/3:plain p                                                            :2_3:Is:
************************ / pRelPred                                                                  :2_3:Is:
************************* / slRelPred                                                               :2_3:Is:
************************** / nested simpleHorn                                                     :2_3:Is:
*************************** > |^|                                                                 :2_3:Is:
*************************** / $*|                                                                 :2_3:Is:
**************************** / slMultiTerm                                                       :2_3:Is:
***************************** / someSL                                                          :2_3:Is:
****************************** / pNumAsText                                                    :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

nested simpleHorn> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=14:
nested simpleHorn> unexpected IS
nested simpleHorn> expecting other text or number

************************** / RPConstraint                                                          :2_3:Is:
*************************** / $*|                                                                 :2_3:Is:
**************************** / slMultiTerm                                                       :2_3:Is:
***************************** / someSL                                                          :2_3:Is:
****************************** / pNumAsText                                                    :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

RPConstraint> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=14:
RPConstraint> unexpected IS
RPConstraint> expecting other text or number

************************** / RPBoolStructR                                                         :2_3:Is:
*************************** / $*|                                                                 :2_3:Is:
**************************** / slMultiTerm                                                       :2_3:Is:
***************************** / someSL                                                          :2_3:Is:
****************************** / pNumAsText                                                    :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

RPBoolStructR> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=14:
RPBoolStructR> unexpected IS
RPBoolStructR> expecting other text or number

************************** / RPMT                                                                  :2_3:Is:
*************************** / $*|                                                                 :2_3:Is:
**************************** / slAKA                                                             :2_3:Is:
***************************** / $*|                                                             :2_3:Is:
****************************** / slAKA base                                                    :2_3:Is:
******************************* / slMultiTerm                                                 :2_3:Is:
******************************** / someSL                                                    :2_3:Is:
********************************* / pNumAsText                                              :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

slAKA base> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=14:
slAKA base> unexpected IS
slAKA base> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

slAKA> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=14:
slAKA> unexpected IS
slAKA> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

RPMT> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=14:
RPMT> unexpected IS
RPMT> expecting other text or number

slRelPred> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=14:
slRelPred> unexpected IS
slRelPred> expecting other text or number

pRelPred> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pRelPred> MATCH (EERR): <EMPTY>
pRelPred> ERROR:
pRelPred> offset=14:
pRelPred> unexpected IS
pRelPred> expecting other text or number

term p/3:plain p> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p/3:plain p> MATCH (EERR): <EMPTY>
term p/3:plain p> ERROR:
term p/3:plain p> offset=14:
term p/3:plain p> unexpected IS
term p/3:plain p> expecting other text or number

term p/notLabelTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p/notLabelTerm> MATCH (EERR): <EMPTY>
term p/notLabelTerm> ERROR:
term p/notLabelTerm> offset=14:
term p/notLabelTerm> unexpected IS
term p/notLabelTerm> expecting ( or term

term p> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p> MATCH (EERR): <EMPTY>
term p> ERROR:
term p> offset=14:
term p> unexpected IS
term p> expecting ( or term

expression> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
expression> MATCH (EERR): <EMPTY>
expression> ERROR:
expression> offset=14:
expression> unexpected IS
expression> expecting expression

manyIndentation/leaf?> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
manyIndentation/leaf?> MATCH (EERR): <EMPTY>
manyIndentation/leaf?> ERROR:
manyIndentation/leaf?> offset=14:
manyIndentation/leaf?> unexpected IS
manyIndentation/leaf?> expecting expression

******************* / manyIndentation/deeper; calling someIndentation                                     :2_3:Is:
******************** / someIndentation                                                                   :2_3:Is:
********************* / myindented: consuming GoDeeper                                                  :2_3:Is:
myindented: consuming GoDeeper> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=14:
myindented: consuming GoDeeper> unexpected IS
myindented: consuming GoDeeper> expecting (

someIndentation> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting (

manyIndentation/deeper; calling someIndentation> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
manyIndentation/deeper; calling someIndentation> MATCH (EERR): <EMPTY>
manyIndentation/deeper; calling someIndentation> ERROR:
manyIndentation/deeper; calling someIndentation> offset=14:
manyIndentation/deeper; calling someIndentation> unexpected IS
manyIndentation/deeper; calling someIndentation> expecting (

someIndentation> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someIndentation> MATCH (CERR): (
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting ( or expression

term p/2:someIndentation expr p> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p/2:someIndentation expr p> MATCH (CERR): (
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=14:
term p/2:someIndentation expr p> unexpected IS
term p/2:someIndentation expr p> expecting ( or expression

***************** / term p/3:plain p                                                                       :2_3:GoDeeper:
****************** / pRelPred                                                                             :2_3:GoDeeper:
******************* / slRelPred                                                                          :2_3:GoDeeper:
******************** / nested simpleHorn                                                                :2_3:GoDeeper:
********************* > |^|                                                                            :2_3:GoDeeper:
********************* / $*|                                                                            :2_3:GoDeeper:
********************** / slMultiTerm                                                                  :2_3:GoDeeper:
*********************** / someSL                                                                     :2_3:GoDeeper:
************************ / pNumAsText                                                               :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

nested simpleHorn> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=13:
nested simpleHorn> unexpected (
nested simpleHorn> expecting other text or number

******************** / RPConstraint                                                                     :2_3:GoDeeper:
********************* / $*|                                                                            :2_3:GoDeeper:
********************** / slMultiTerm                                                                  :2_3:GoDeeper:
*********************** / someSL                                                                     :2_3:GoDeeper:
************************ / pNumAsText                                                               :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

RPConstraint> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=13:
RPConstraint> unexpected (
RPConstraint> expecting other text or number

******************** / RPBoolStructR                                                                    :2_3:GoDeeper:
********************* / $*|                                                                            :2_3:GoDeeper:
********************** / slMultiTerm                                                                  :2_3:GoDeeper:
*********************** / someSL                                                                     :2_3:GoDeeper:
************************ / pNumAsText                                                               :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

RPBoolStructR> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=13:
RPBoolStructR> unexpected (
RPBoolStructR> expecting other text or number

******************** / RPMT                                                                             :2_3:GoDeeper:
********************* / $*|                                                                            :2_3:GoDeeper:
********************** / slAKA                                                                        :2_3:GoDeeper:
*********************** / $*|                                                                        :2_3:GoDeeper:
************************ / slAKA base                                                               :2_3:GoDeeper:
************************* / slMultiTerm                                                            :2_3:GoDeeper:
************************** / someSL                                                               :2_3:GoDeeper:
*************************** / pNumAsText                                                         :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

slAKA base> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=13:
slAKA base> unexpected (
slAKA base> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

slAKA> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=13:
slAKA> unexpected (
slAKA> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

RPMT> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=13:
RPMT> unexpected (
RPMT> expecting other text or number

slRelPred> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=13:
slRelPred> unexpected (
slRelPred> expecting other text or number

pRelPred> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pRelPred> MATCH (EERR): <EMPTY>
pRelPred> ERROR:
pRelPred> offset=13:
pRelPred> unexpected (
pRelPred> expecting other text or number

term p/3:plain p> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p/3:plain p> MATCH (EERR): <EMPTY>
term p/3:plain p> ERROR:
term p/3:plain p> offset=13:
term p/3:plain p> unexpected (
term p/3:plain p> expecting other text or number

term p/notLabelTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p/notLabelTerm> MATCH (EERR): <EMPTY>
term p/notLabelTerm> ERROR:
term p/notLabelTerm> offset=14:
term p/notLabelTerm> unexpected IS
term p/notLabelTerm> expecting ( or expression

term p> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p> MATCH (EERR): <EMPTY>
term p> ERROR:
term p> offset=14:
term p> unexpected IS
term p> expecting ( or expression

expression> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
expression> MATCH (CERR): "Z"
expression> ERROR:
expression> offset=14:
expression> unexpected IS
expression> expecting (, NOT, or expression

manyIndentation/leaf?> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
manyIndentation/leaf?> MATCH (EERR): <EMPTY>
manyIndentation/leaf?> ERROR:
manyIndentation/leaf?> offset=14:
manyIndentation/leaf?> unexpected IS
manyIndentation/leaf?> expecting (, NOT, or expression

************* / manyIndentation/deeper; calling someIndentation                                               :2_2:Other "Z":
************** / someIndentation                                                                             :2_2:Other "Z":
*************** / myindented: consuming GoDeeper                                                            :2_2:Other "Z":
myindented: consuming GoDeeper> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=12:
myindented: consuming GoDeeper> unexpected "Z"
myindented: consuming GoDeeper> expecting (

someIndentation> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=12:
someIndentation> unexpected "Z"
someIndentation> expecting (

manyIndentation/deeper; calling someIndentation> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
manyIndentation/deeper; calling someIndentation> MATCH (EERR): <EMPTY>
manyIndentation/deeper; calling someIndentation> ERROR:
manyIndentation/deeper; calling someIndentation> offset=12:
manyIndentation/deeper; calling someIndentation> unexpected "Z"
manyIndentation/deeper; calling someIndentation> expecting (

someIndentation> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someIndentation> MATCH (CERR): (
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting (, NOT, or expression

term p/2:someIndentation expr p> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p/2:someIndentation expr p> MATCH (CERR): (
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=14:
term p/2:someIndentation expr p> unexpected IS
term p/2:someIndentation expr p> expecting (, NOT, or expression

*********** / term p/3:plain p                                                                                 :2_2:GoDeeper:
************ / pRelPred                                                                                       :2_2:GoDeeper:
************* / slRelPred                                                                                    :2_2:GoDeeper:
************** / nested simpleHorn                                                                          :2_2:GoDeeper:
*************** > |^|                                                                                      :2_2:GoDeeper:
*************** / $*|                                                                                      :2_2:GoDeeper:
**************** / slMultiTerm                                                                            :2_2:GoDeeper:
***************** / someSL                                                                               :2_2:GoDeeper:
****************** / pNumAsText                                                                         :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

nested simpleHorn> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=11:
nested simpleHorn> unexpected (
nested simpleHorn> expecting other text or number

************** / RPConstraint                                                                               :2_2:GoDeeper:
*************** / $*|                                                                                      :2_2:GoDeeper:
**************** / slMultiTerm                                                                            :2_2:GoDeeper:
***************** / someSL                                                                               :2_2:GoDeeper:
****************** / pNumAsText                                                                         :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

RPConstraint> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=11:
RPConstraint> unexpected (
RPConstraint> expecting other text or number

************** / RPBoolStructR                                                                              :2_2:GoDeeper:
*************** / $*|                                                                                      :2_2:GoDeeper:
**************** / slMultiTerm                                                                            :2_2:GoDeeper:
***************** / someSL                                                                               :2_2:GoDeeper:
****************** / pNumAsText                                                                         :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

RPBoolStructR> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=11:
RPBoolStructR> unexpected (
RPBoolStructR> expecting other text or number

************** / RPMT                                                                                       :2_2:GoDeeper:
*************** / $*|                                                                                      :2_2:GoDeeper:
**************** / slAKA                                                                                  :2_2:GoDeeper:
***************** / $*|                                                                                  :2_2:GoDeeper:
****************** / slAKA base                                                                         :2_2:GoDeeper:
******************* / slMultiTerm                                                                      :2_2:GoDeeper:
******************** / someSL                                                                         :2_2:GoDeeper:
********************* / pNumAsText                                                                   :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

slAKA base> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=11:
slAKA base> unexpected (
slAKA base> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

slAKA> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=11:
slAKA> unexpected (
slAKA> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

RPMT> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=11:
RPMT> unexpected (
RPMT> expecting other text or number

slRelPred> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=11:
slRelPred> unexpected (
slRelPred> expecting other text or number

pRelPred> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pRelPred> MATCH (EERR): <EMPTY>
pRelPred> ERROR:
pRelPred> offset=11:
pRelPred> unexpected (
pRelPred> expecting other text or number

term p/3:plain p> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p/3:plain p> MATCH (EERR): <EMPTY>
term p/3:plain p> ERROR:
term p/3:plain p> offset=11:
term p/3:plain p> unexpected (
term p/3:plain p> expecting other text or number

term p/notLabelTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p/notLabelTerm> MATCH (EERR): <EMPTY>
term p/notLabelTerm> ERROR:
term p/notLabelTerm> offset=14:
term p/notLabelTerm> unexpected IS
term p/notLabelTerm> expecting (, NOT, or expression

term p> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p> MATCH (EERR): <EMPTY>
term p> ERROR:
term p> offset=14:
term p> unexpected IS
term p> expecting (, NOT, or expression

expression> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
expression> MATCH (EERR): <EMPTY>
expression> ERROR:
expression> offset=14:
expression> unexpected IS
expression> expecting expression

ppp inner> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
ppp inner> MATCH (EERR): <EMPTY>
ppp inner> ERROR:
ppp inner> offset=14:
ppp inner> unexpected IS
ppp inner> expecting expression

******* / withPrePost                                                                                              :2_2:GoDeeper:
******** > |<* starting                                                                                           :2_2:GoDeeper:
******** / $*|                                                                                                    :2_2:GoDeeper:
********* / pre part                                                                                             :2_2:GoDeeper:
********** / aboveNextLineKeyword                                                                                :2_2:Other "Z":
*********** / expectUnDeepers                                                                                   :2_2:Other "Z":
************ / pNumAsText                                                                                       :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
expectUnDeepers> MATCH (CERR): "Z" (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
aboveNextLineKeyword> MATCH (CERR): "Z" (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                       :2_2:Other "Z":
********** / aboveNextLineKeyword                                                                                 :2_3:GoDeeper:
*********** / expectUnDeepers                                                                                    :2_3:GoDeeper:
************ / pNumAsText                                                                                       :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
expectUnDeepers> MATCH (CERR): (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
aboveNextLineKeyword> MATCH (CERR): (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                        :2_3:GoDeeper:
********** / aboveNextLineKeyword                                                                                  :2_3:Is:
*********** / expectUnDeepers                                                                                     :2_3:Is:
************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
expectUnDeepers> MATCH (EERR): <EMPTY>
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
aboveNextLineKeyword> MATCH (EERR): <EMPTY>
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                         :2_3:Is:
pre part> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pre part> MATCH (CERR): (
pre part> ERROR:
pre part> offset=14:
pre part> unexpected IS
pre part> expecting (, ), Other text, or other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (CERR): (
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting (, ), Other text, or other text or number

withPrePost> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
withPrePost> MATCH (CERR): (
withPrePost> ERROR:
withPrePost> offset=14:
withPrePost> unexpected IS
withPrePost> expecting (, ), Other text, or other text or number

******* / withPreOnly                                                                                              :2_2:GoDeeper:
******** / $*|                                                                                                    :2_2:GoDeeper:
********* / pre part                                                                                             :2_2:GoDeeper:
********** / aboveNextLineKeyword                                                                                :2_2:Other "Z":
*********** / expectUnDeepers                                                                                   :2_2:Other "Z":
************ / pNumAsText                                                                                       :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
expectUnDeepers> MATCH (CERR): "Z" (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
aboveNextLineKeyword> MATCH (CERR): "Z" (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                       :2_2:Other "Z":
********** / aboveNextLineKeyword                                                                                 :2_3:GoDeeper:
*********** / expectUnDeepers                                                                                    :2_3:GoDeeper:
************ / pNumAsText                                                                                       :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
expectUnDeepers> MATCH (CERR): (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
aboveNextLineKeyword> MATCH (CERR): (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                        :2_3:GoDeeper:
********** / aboveNextLineKeyword                                                                                  :2_3:Is:
*********** / expectUnDeepers                                                                                     :2_3:Is:
************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
expectUnDeepers> MATCH (EERR): <EMPTY>
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
aboveNextLineKeyword> MATCH (EERR): <EMPTY>
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                         :2_3:Is:
pre part> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pre part> MATCH (CERR): (
pre part> ERROR:
pre part> offset=14:
pre part> unexpected IS
pre part> expecting (, ), Other text, or other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (CERR): (
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting (, ), Other text, or other text or number

withPreOnly> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
withPreOnly> MATCH (CERR): (
withPreOnly> ERROR:
withPreOnly> offset=14:
withPreOnly> unexpected IS
withPreOnly> expecting (, ), Other text, or other text or number

pBSR> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pBSR> MATCH (CERR): (
pBSR> ERROR:
pBSR> offset=14:
pBSR> unexpected IS
pBSR> expecting (, ), Other text, expression, or other text or number

****** / Otherwise                                                                                                 :2_1:When:
Otherwise> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
Otherwise> MATCH (EERR): <EMPTY>
Otherwise> ERROR:
Otherwise> offset=10:
Otherwise> unexpected WHEN
Otherwise> expecting OTHERWISE

whenCase> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
whenCase> MATCH (EERR): <EMPTY>
whenCase> ERROR:
whenCase> offset=14:
whenCase> unexpected IS
whenCase> expecting (, ), Other text, expression, or other text or number

***** / pHornlike/ambitious                                                                                         :2_1:When:
****** / $>|                                                                                                       :2_1:When:
$>|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=10:
$>|> unexpected WHEN
$>|> expecting DECIDE or DEFINE

pHornlike/ambitious> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pHornlike/ambitious> MATCH (EERR): <EMPTY>
pHornlike/ambitious> ERROR:
pHornlike/ambitious> offset=10:
pHornlike/ambitious> unexpected WHEN
pHornlike/ambitious> expecting DECIDE or DEFINE

***** / pHornlike/someStructure                                                                                     :2_1:When:
****** / manyIndentation/leaf?                                                                                     :2_1:When:
******* / relPredNextlineWhen                                                                                     :2_1:When:
******** / pRelPred optIndentedTuple whenCase                                                                    :2_1:When:
********* / optIndentedTuple                                                                                    :2_1:When:
********** / optIndented                                                                                       :2_1:When:
*********** / pRelPred                                                                                        :2_1:When:
************ / slRelPred                                                                                     :2_1:When:
************* / nested simpleHorn                                                                           :2_1:When:
************** > |^|                                                                                       :2_1:When:
************** / $*|                                                                                       :2_1:When:
*************** / slMultiTerm                                                                             :2_1:When:
**************** / someSL                                                                                :2_1:When:
***************** / pNumAsText                                                                          :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

nested simpleHorn> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=10:
nested simpleHorn> unexpected WHEN
nested simpleHorn> expecting other text or number

************* / RPConstraint                                                                                :2_1:When:
************** / $*|                                                                                       :2_1:When:
*************** / slMultiTerm                                                                             :2_1:When:
**************** / someSL                                                                                :2_1:When:
***************** / pNumAsText                                                                          :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

RPConstraint> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=10:
RPConstraint> unexpected WHEN
RPConstraint> expecting other text or number

************* / RPBoolStructR                                                                               :2_1:When:
************** / $*|                                                                                       :2_1:When:
*************** / slMultiTerm                                                                             :2_1:When:
**************** / someSL                                                                                :2_1:When:
***************** / pNumAsText                                                                          :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

RPBoolStructR> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=10:
RPBoolStructR> unexpected WHEN
RPBoolStructR> expecting other text or number

************* / RPMT                                                                                        :2_1:When:
************** / $*|                                                                                       :2_1:When:
*************** / slAKA                                                                                   :2_1:When:
**************** / $*|                                                                                   :2_1:When:
***************** / slAKA base                                                                          :2_1:When:
****************** / slMultiTerm                                                                       :2_1:When:
******************* / someSL                                                                          :2_1:When:
******************** / pNumAsText                                                                    :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

slAKA base> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=10:
slAKA base> unexpected WHEN
slAKA base> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

slAKA> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=10:
slAKA> unexpected WHEN
slAKA> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

RPMT> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=10:
RPMT> unexpected WHEN
RPMT> expecting other text or number

slRelPred> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=10:
slRelPred> unexpected WHEN
slRelPred> expecting other text or number

pRelPred> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pRelPred> MATCH (EERR): <EMPTY>
pRelPred> ERROR:
pRelPred> offset=10:
pRelPred> unexpected WHEN
pRelPred> expecting other text or number

optIndented> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
optIndented> MATCH (EERR): <EMPTY>
optIndented> ERROR:
optIndented> offset=10:
optIndented> unexpected WHEN
optIndented> expecting other text or number

optIndentedTuple> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
optIndentedTuple> MATCH (EERR): <EMPTY>
optIndentedTuple> ERROR:
optIndentedTuple> offset=10:
optIndentedTuple> unexpected WHEN
optIndentedTuple> expecting other text or number

pRelPred optIndentedTuple whenCase> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pRelPred optIndentedTuple whenCase> MATCH (EERR): <EMPTY>
pRelPred optIndentedTuple whenCase> ERROR:
pRelPred optIndentedTuple whenCase> offset=10:
pRelPred optIndentedTuple whenCase> unexpected WHEN
pRelPred optIndentedTuple whenCase> expecting other text or number

relPredNextlineWhen> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
relPredNextlineWhen> MATCH (EERR): <EMPTY>
relPredNextlineWhen> ERROR:
relPredNextlineWhen> offset=10:
relPredNextlineWhen> unexpected WHEN
relPredNextlineWhen> expecting other text or number

******* / relPredSamelineWhen                                                                                     :2_1:When:
******** / $*|                                                                                                   :2_1:When:
********* / slRelPred                                                                                           :2_1:When:
********** / nested simpleHorn                                                                                 :2_1:When:
*********** > |^|                                                                                             :2_1:When:
*********** / $*|                                                                                             :2_1:When:
************ / slMultiTerm                                                                                   :2_1:When:
************* / someSL                                                                                      :2_1:When:
************** / pNumAsText                                                                                :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

nested simpleHorn> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=10:
nested simpleHorn> unexpected WHEN
nested simpleHorn> expecting other text or number

********** / RPConstraint                                                                                      :2_1:When:
*********** / $*|                                                                                             :2_1:When:
************ / slMultiTerm                                                                                   :2_1:When:
************* / someSL                                                                                      :2_1:When:
************** / pNumAsText                                                                                :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

RPConstraint> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=10:
RPConstraint> unexpected WHEN
RPConstraint> expecting other text or number

********** / RPBoolStructR                                                                                     :2_1:When:
*********** / $*|                                                                                             :2_1:When:
************ / slMultiTerm                                                                                   :2_1:When:
************* / someSL                                                                                      :2_1:When:
************** / pNumAsText                                                                                :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

RPBoolStructR> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=10:
RPBoolStructR> unexpected WHEN
RPBoolStructR> expecting other text or number

********** / RPMT                                                                                              :2_1:When:
*********** / $*|                                                                                             :2_1:When:
************ / slAKA                                                                                         :2_1:When:
************* / $*|                                                                                         :2_1:When:
************** / slAKA base                                                                                :2_1:When:
*************** / slMultiTerm                                                                             :2_1:When:
**************** / someSL                                                                                :2_1:When:
***************** / pNumAsText                                                                          :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

slAKA base> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=10:
slAKA base> unexpected WHEN
slAKA base> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

slAKA> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=10:
slAKA> unexpected WHEN
slAKA> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

RPMT> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=10:
RPMT> unexpected WHEN
RPMT> expecting other text or number

slRelPred> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=10:
slRelPred> unexpected WHEN
slRelPred> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

relPredSamelineWhen> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
relPredSamelineWhen> MATCH (EERR): <EMPTY>
relPredSamelineWhen> ERROR:
relPredSamelineWhen> offset=10:
relPredSamelineWhen> unexpected WHEN
relPredSamelineWhen> expecting other text or number

manyIndentation/leaf?> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
manyIndentation/leaf?> MATCH (EERR): <EMPTY>
manyIndentation/leaf?> ERROR:
manyIndentation/leaf?> offset=10:
manyIndentation/leaf?> unexpected WHEN
manyIndentation/leaf?> expecting other text or number

****** / manyIndentation/deeper; calling someIndentation                                                           :2_1:When:
******* / someIndentation                                                                                         :2_1:When:
******** / myindented: consuming GoDeeper                                                                        :2_1:When:
myindented: consuming GoDeeper> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=10:
myindented: consuming GoDeeper> unexpected WHEN
myindented: consuming GoDeeper> expecting (

someIndentation> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=10:
someIndentation> unexpected WHEN
someIndentation> expecting (

manyIndentation/deeper; calling someIndentation> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
manyIndentation/deeper; calling someIndentation> MATCH (EERR): <EMPTY>
manyIndentation/deeper; calling someIndentation> ERROR:
manyIndentation/deeper; calling someIndentation> offset=10:
manyIndentation/deeper; calling someIndentation> unexpected WHEN
manyIndentation/deeper; calling someIndentation> expecting (

pHornlike/someStructure> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pHornlike/someStructure> MATCH (EERR): <EMPTY>
pHornlike/someStructure> ERROR:
pHornlike/someStructure> offset=10:
pHornlike/someStructure> unexpected WHEN
pHornlike/someStructure> expecting (, DECIDE, DEFINE, or other text or number

***** / pHornlike/ambitious                                                                                         :2_1:When:
****** / $>|                                                                                                       :2_1:When:
$>|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=10:
$>|> unexpected WHEN
$>|> expecting DECIDE or DEFINE

pHornlike/ambitious> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pHornlike/ambitious> MATCH (EERR): <EMPTY>
pHornlike/ambitious> ERROR:
pHornlike/ambitious> offset=10:
pHornlike/ambitious> unexpected WHEN
pHornlike/ambitious> expecting DECIDE or DEFINE

***** / pHornlike/someStructure                                                                                     :2_1:When:
****** / manyIndentation/leaf?                                                                                     :2_1:When:
******* / relPredNextlineWhen                                                                                     :2_1:When:
******** / pRelPred optIndentedTuple whenCase                                                                    :2_1:When:
********* / optIndentedTuple                                                                                    :2_1:When:
********** / optIndented                                                                                       :2_1:When:
*********** / pRelPred                                                                                        :2_1:When:
************ / slRelPred                                                                                     :2_1:When:
************* / nested simpleHorn                                                                           :2_1:When:
************** > |^|                                                                                       :2_1:When:
************** / $*|                                                                                       :2_1:When:
*************** / slMultiTerm                                                                             :2_1:When:
**************** / someSL                                                                                :2_1:When:
***************** / pNumAsText                                                                          :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

nested simpleHorn> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=10:
nested simpleHorn> unexpected WHEN
nested simpleHorn> expecting other text or number

************* / RPConstraint                                                                                :2_1:When:
************** / $*|                                                                                       :2_1:When:
*************** / slMultiTerm                                                                             :2_1:When:
**************** / someSL                                                                                :2_1:When:
***************** / pNumAsText                                                                          :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

RPConstraint> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=10:
RPConstraint> unexpected WHEN
RPConstraint> expecting other text or number

************* / RPBoolStructR                                                                               :2_1:When:
************** / $*|                                                                                       :2_1:When:
*************** / slMultiTerm                                                                             :2_1:When:
**************** / someSL                                                                                :2_1:When:
***************** / pNumAsText                                                                          :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

RPBoolStructR> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=10:
RPBoolStructR> unexpected WHEN
RPBoolStructR> expecting other text or number

************* / RPMT                                                                                        :2_1:When:
************** / $*|                                                                                       :2_1:When:
*************** / slAKA                                                                                   :2_1:When:
**************** / $*|                                                                                   :2_1:When:
***************** / slAKA base                                                                          :2_1:When:
****************** / slMultiTerm                                                                       :2_1:When:
******************* / someSL                                                                          :2_1:When:
******************** / pNumAsText                                                                    :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

slAKA base> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=10:
slAKA base> unexpected WHEN
slAKA base> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

slAKA> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=10:
slAKA> unexpected WHEN
slAKA> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

RPMT> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=10:
RPMT> unexpected WHEN
RPMT> expecting other text or number

slRelPred> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=10:
slRelPred> unexpected WHEN
slRelPred> expecting other text or number

pRelPred> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pRelPred> MATCH (EERR): <EMPTY>
pRelPred> ERROR:
pRelPred> offset=10:
pRelPred> unexpected WHEN
pRelPred> expecting other text or number

optIndented> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
optIndented> MATCH (EERR): <EMPTY>
optIndented> ERROR:
optIndented> offset=10:
optIndented> unexpected WHEN
optIndented> expecting other text or number

optIndentedTuple> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
optIndentedTuple> MATCH (EERR): <EMPTY>
optIndentedTuple> ERROR:
optIndentedTuple> offset=10:
optIndentedTuple> unexpected WHEN
optIndentedTuple> expecting other text or number

pRelPred optIndentedTuple whenCase> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pRelPred optIndentedTuple whenCase> MATCH (EERR): <EMPTY>
pRelPred optIndentedTuple whenCase> ERROR:
pRelPred optIndentedTuple whenCase> offset=10:
pRelPred optIndentedTuple whenCase> unexpected WHEN
pRelPred optIndentedTuple whenCase> expecting other text or number

relPredNextlineWhen> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
relPredNextlineWhen> MATCH (EERR): <EMPTY>
relPredNextlineWhen> ERROR:
relPredNextlineWhen> offset=10:
relPredNextlineWhen> unexpected WHEN
relPredNextlineWhen> expecting other text or number

******* / relPredSamelineWhen                                                                                     :2_1:When:
******** / $*|                                                                                                   :2_1:When:
********* / slRelPred                                                                                           :2_1:When:
********** / nested simpleHorn                                                                                 :2_1:When:
*********** > |^|                                                                                             :2_1:When:
*********** / $*|                                                                                             :2_1:When:
************ / slMultiTerm                                                                                   :2_1:When:
************* / someSL                                                                                      :2_1:When:
************** / pNumAsText                                                                                :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

nested simpleHorn> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=10:
nested simpleHorn> unexpected WHEN
nested simpleHorn> expecting other text or number

********** / RPConstraint                                                                                      :2_1:When:
*********** / $*|                                                                                             :2_1:When:
************ / slMultiTerm                                                                                   :2_1:When:
************* / someSL                                                                                      :2_1:When:
************** / pNumAsText                                                                                :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

RPConstraint> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=10:
RPConstraint> unexpected WHEN
RPConstraint> expecting other text or number

********** / RPBoolStructR                                                                                     :2_1:When:
*********** / $*|                                                                                             :2_1:When:
************ / slMultiTerm                                                                                   :2_1:When:
************* / someSL                                                                                      :2_1:When:
************** / pNumAsText                                                                                :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

RPBoolStructR> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=10:
RPBoolStructR> unexpected WHEN
RPBoolStructR> expecting other text or number

********** / RPMT                                                                                              :2_1:When:
*********** / $*|                                                                                             :2_1:When:
************ / slAKA                                                                                         :2_1:When:
************* / $*|                                                                                         :2_1:When:
************** / slAKA base                                                                                :2_1:When:
*************** / slMultiTerm                                                                             :2_1:When:
**************** / someSL                                                                                :2_1:When:
***************** / pNumAsText                                                                          :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

slAKA base> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=10:
slAKA base> unexpected WHEN
slAKA base> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

slAKA> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=10:
slAKA> unexpected WHEN
slAKA> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

RPMT> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=10:
RPMT> unexpected WHEN
RPMT> expecting other text or number

slRelPred> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=10:
slRelPred> unexpected WHEN
slRelPred> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

relPredSamelineWhen> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
relPredSamelineWhen> MATCH (EERR): <EMPTY>
relPredSamelineWhen> ERROR:
relPredSamelineWhen> offset=10:
relPredSamelineWhen> unexpected WHEN
relPredSamelineWhen> expecting other text or number

manyIndentation/leaf?> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
manyIndentation/leaf?> MATCH (EERR): <EMPTY>
manyIndentation/leaf?> ERROR:
manyIndentation/leaf?> offset=10:
manyIndentation/leaf?> unexpected WHEN
manyIndentation/leaf?> expecting other text or number

****** / manyIndentation/deeper; calling someIndentation                                                           :2_1:When:
******* / someIndentation                                                                                         :2_1:When:
******** / myindented: consuming GoDeeper                                                                        :2_1:When:
myindented: consuming GoDeeper> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=10:
myindented: consuming GoDeeper> unexpected WHEN
myindented: consuming GoDeeper> expecting (

someIndentation> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=10:
someIndentation> unexpected WHEN
someIndentation> expecting (

manyIndentation/deeper; calling someIndentation> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
manyIndentation/deeper; calling someIndentation> MATCH (EERR): <EMPTY>
manyIndentation/deeper; calling someIndentation> ERROR:
manyIndentation/deeper; calling someIndentation> offset=10:
manyIndentation/deeper; calling someIndentation> unexpected WHEN
manyIndentation/deeper; calling someIndentation> expecting (

pHornlike/someStructure> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pHornlike/someStructure> MATCH (EERR): <EMPTY>
pHornlike/someStructure> ERROR:
pHornlike/someStructure> offset=10:
pHornlike/someStructure> unexpected WHEN
pHornlike/someStructure> expecting (, DECIDE, DEFINE, or other text or number

***** / pHornlike/givenLimb                                                                                         :2_1:When:
****** / preambleParamText:[Given]                                                                                 :2_1:When:
******* / $>|                                                                                                     :2_1:When:
$>|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=10:
$>|> unexpected WHEN
$>|> expecting GIVEN

preambleParamText:[Given]> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
preambleParamText:[Given]> MATCH (EERR): <EMPTY>
preambleParamText:[Given]> ERROR:
preambleParamText:[Given]> offset=10:
preambleParamText:[Given]> unexpected WHEN
preambleParamText:[Given]> expecting GIVEN

pHornlike/givenLimb> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pHornlike/givenLimb> MATCH (EERR): <EMPTY>
pHornlike/givenLimb> ERROR:
pHornlike/givenLimb> offset=10:
pHornlike/givenLimb> unexpected WHEN
pHornlike/givenLimb> expecting GIVEN

***** / whenCase                                                                                                    :2_1:When:
****** / whenMeansIf                                                                                               :2_1:When:
whenMeansIf> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
whenMeansIf> MATCH (COK): WHEN
whenMeansIf> VALUE: (When,[])

****** \ whenMeansIf has returned When                                                                              :2_2:GoDeeper:
****** / pBSR                                                                                                       :2_2:GoDeeper:
******* / ppp inner                                                                                                :2_2:GoDeeper:
******** / expression                                                                                             :2_2:GoDeeper:
********* / labelPrefix                                                                                          :2_2:GoDeeper:
labelPrefix> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=11:
labelPrefix> unexpected (
labelPrefix> expecting Other text

********* / term p                                                                                               :2_2:GoDeeper:
********** / term p/notLabelTerm                                                                                :2_2:GoDeeper:
*********** / term p/2:someIndentation expr p                                                                  :2_2:GoDeeper:
************ / someIndentation                                                                                :2_2:GoDeeper:
************* / myindented: consuming GoDeeper                                                               :2_2:GoDeeper:
myindented: consuming GoDeeper> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
myindented: consuming GoDeeper> MATCH (COK): (
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

************* \ myindented: consuming GoDeeper has returned GoDeeper                                          :2_2:Other "Z":
************* / manyIndentation/leaf?                                                                         :2_2:Other "Z":
************** / expression                                                                                  :2_2:Other "Z":
*************** / labelPrefix                                                                               :2_2:Other "Z":
labelPrefix> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
labelPrefix> MATCH (COK): "Z"
labelPrefix> VALUE: ("Z",[])

*************** \ labelPrefix has returned "Z"                                                               :2_3:GoDeeper:
*************** / term p                                                                                     :2_3:GoDeeper:
**************** / term p/notLabelTerm                                                                      :2_3:GoDeeper:
***************** / term p/2:someIndentation expr p                                                        :2_3:GoDeeper:
****************** / someIndentation                                                                      :2_3:GoDeeper:
******************* / myindented: consuming GoDeeper                                                     :2_3:GoDeeper:
myindented: consuming GoDeeper> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
myindented: consuming GoDeeper> MATCH (COK): (
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

******************* \ myindented: consuming GoDeeper has returned GoDeeper                                :2_3:Is:
******************* / manyIndentation/leaf?                                                               :2_3:Is:
******************** / expression                                                                        :2_3:Is:
********************* / labelPrefix                                                                     :2_3:Is:
labelPrefix> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=14:
labelPrefix> unexpected IS
labelPrefix> expecting Other text

********************* / term p                                                                          :2_3:Is:
********************** / term p/notLabelTerm                                                           :2_3:Is:
*********************** / term p/2:someIndentation expr p                                             :2_3:Is:
************************ / someIndentation                                                           :2_3:Is:
************************* / myindented: consuming GoDeeper                                          :2_3:Is:
myindented: consuming GoDeeper> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=14:
myindented: consuming GoDeeper> unexpected IS
myindented: consuming GoDeeper> expecting (

someIndentation> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting (

term p/2:someIndentation expr p> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p/2:someIndentation expr p> MATCH (EERR): <EMPTY>
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=14:
term p/2:someIndentation expr p> unexpected IS
term p/2:someIndentation expr p> expecting (

*********************** / term p/3:plain p                                                            :2_3:Is:
************************ / pRelPred                                                                  :2_3:Is:
************************* / slRelPred                                                               :2_3:Is:
************************** / nested simpleHorn                                                     :2_3:Is:
*************************** > |^|                                                                 :2_3:Is:
*************************** / $*|                                                                 :2_3:Is:
**************************** / slMultiTerm                                                       :2_3:Is:
***************************** / someSL                                                          :2_3:Is:
****************************** / pNumAsText                                                    :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

nested simpleHorn> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=14:
nested simpleHorn> unexpected IS
nested simpleHorn> expecting other text or number

************************** / RPConstraint                                                          :2_3:Is:
*************************** / $*|                                                                 :2_3:Is:
**************************** / slMultiTerm                                                       :2_3:Is:
***************************** / someSL                                                          :2_3:Is:
****************************** / pNumAsText                                                    :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

RPConstraint> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=14:
RPConstraint> unexpected IS
RPConstraint> expecting other text or number

************************** / RPBoolStructR                                                         :2_3:Is:
*************************** / $*|                                                                 :2_3:Is:
**************************** / slMultiTerm                                                       :2_3:Is:
***************************** / someSL                                                          :2_3:Is:
****************************** / pNumAsText                                                    :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

RPBoolStructR> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=14:
RPBoolStructR> unexpected IS
RPBoolStructR> expecting other text or number

************************** / RPMT                                                                  :2_3:Is:
*************************** / $*|                                                                 :2_3:Is:
**************************** / slAKA                                                             :2_3:Is:
***************************** / $*|                                                             :2_3:Is:
****************************** / slAKA base                                                    :2_3:Is:
******************************* / slMultiTerm                                                 :2_3:Is:
******************************** / someSL                                                    :2_3:Is:
********************************* / pNumAsText                                              :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

slAKA base> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=14:
slAKA base> unexpected IS
slAKA base> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

slAKA> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=14:
slAKA> unexpected IS
slAKA> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

RPMT> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=14:
RPMT> unexpected IS
RPMT> expecting other text or number

slRelPred> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=14:
slRelPred> unexpected IS
slRelPred> expecting other text or number

pRelPred> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pRelPred> MATCH (EERR): <EMPTY>
pRelPred> ERROR:
pRelPred> offset=14:
pRelPred> unexpected IS
pRelPred> expecting other text or number

term p/3:plain p> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p/3:plain p> MATCH (EERR): <EMPTY>
term p/3:plain p> ERROR:
term p/3:plain p> offset=14:
term p/3:plain p> unexpected IS
term p/3:plain p> expecting other text or number

term p/notLabelTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p/notLabelTerm> MATCH (EERR): <EMPTY>
term p/notLabelTerm> ERROR:
term p/notLabelTerm> offset=14:
term p/notLabelTerm> unexpected IS
term p/notLabelTerm> expecting ( or term

term p> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p> MATCH (EERR): <EMPTY>
term p> ERROR:
term p> offset=14:
term p> unexpected IS
term p> expecting ( or term

expression> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
expression> MATCH (EERR): <EMPTY>
expression> ERROR:
expression> offset=14:
expression> unexpected IS
expression> expecting expression

manyIndentation/leaf?> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
manyIndentation/leaf?> MATCH (EERR): <EMPTY>
manyIndentation/leaf?> ERROR:
manyIndentation/leaf?> offset=14:
manyIndentation/leaf?> unexpected IS
manyIndentation/leaf?> expecting expression

******************* / manyIndentation/deeper; calling someIndentation                                     :2_3:Is:
******************** / someIndentation                                                                   :2_3:Is:
********************* / myindented: consuming GoDeeper                                                  :2_3:Is:
myindented: consuming GoDeeper> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=14:
myindented: consuming GoDeeper> unexpected IS
myindented: consuming GoDeeper> expecting (

someIndentation> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting (

manyIndentation/deeper; calling someIndentation> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
manyIndentation/deeper; calling someIndentation> MATCH (EERR): <EMPTY>
manyIndentation/deeper; calling someIndentation> ERROR:
manyIndentation/deeper; calling someIndentation> offset=14:
manyIndentation/deeper; calling someIndentation> unexpected IS
manyIndentation/deeper; calling someIndentation> expecting (

someIndentation> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someIndentation> MATCH (CERR): (
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting ( or expression

term p/2:someIndentation expr p> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p/2:someIndentation expr p> MATCH (CERR): (
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=14:
term p/2:someIndentation expr p> unexpected IS
term p/2:someIndentation expr p> expecting ( or expression

***************** / term p/3:plain p                                                                       :2_3:GoDeeper:
****************** / pRelPred                                                                             :2_3:GoDeeper:
******************* / slRelPred                                                                          :2_3:GoDeeper:
******************** / nested simpleHorn                                                                :2_3:GoDeeper:
********************* > |^|                                                                            :2_3:GoDeeper:
********************* / $*|                                                                            :2_3:GoDeeper:
********************** / slMultiTerm                                                                  :2_3:GoDeeper:
*********************** / someSL                                                                     :2_3:GoDeeper:
************************ / pNumAsText                                                               :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

nested simpleHorn> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=13:
nested simpleHorn> unexpected (
nested simpleHorn> expecting other text or number

******************** / RPConstraint                                                                     :2_3:GoDeeper:
********************* / $*|                                                                            :2_3:GoDeeper:
********************** / slMultiTerm                                                                  :2_3:GoDeeper:
*********************** / someSL                                                                     :2_3:GoDeeper:
************************ / pNumAsText                                                               :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

RPConstraint> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=13:
RPConstraint> unexpected (
RPConstraint> expecting other text or number

******************** / RPBoolStructR                                                                    :2_3:GoDeeper:
********************* / $*|                                                                            :2_3:GoDeeper:
********************** / slMultiTerm                                                                  :2_3:GoDeeper:
*********************** / someSL                                                                     :2_3:GoDeeper:
************************ / pNumAsText                                                               :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

RPBoolStructR> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=13:
RPBoolStructR> unexpected (
RPBoolStructR> expecting other text or number

******************** / RPMT                                                                             :2_3:GoDeeper:
********************* / $*|                                                                            :2_3:GoDeeper:
********************** / slAKA                                                                        :2_3:GoDeeper:
*********************** / $*|                                                                        :2_3:GoDeeper:
************************ / slAKA base                                                               :2_3:GoDeeper:
************************* / slMultiTerm                                                            :2_3:GoDeeper:
************************** / someSL                                                               :2_3:GoDeeper:
*************************** / pNumAsText                                                         :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

slAKA base> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=13:
slAKA base> unexpected (
slAKA base> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

slAKA> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=13:
slAKA> unexpected (
slAKA> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

RPMT> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=13:
RPMT> unexpected (
RPMT> expecting other text or number

slRelPred> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=13:
slRelPred> unexpected (
slRelPred> expecting other text or number

pRelPred> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pRelPred> MATCH (EERR): <EMPTY>
pRelPred> ERROR:
pRelPred> offset=13:
pRelPred> unexpected (
pRelPred> expecting other text or number

term p/3:plain p> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p/3:plain p> MATCH (EERR): <EMPTY>
term p/3:plain p> ERROR:
term p/3:plain p> offset=13:
term p/3:plain p> unexpected (
term p/3:plain p> expecting other text or number

term p/notLabelTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p/notLabelTerm> MATCH (EERR): <EMPTY>
term p/notLabelTerm> ERROR:
term p/notLabelTerm> offset=14:
term p/notLabelTerm> unexpected IS
term p/notLabelTerm> expecting ( or expression

term p> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p> MATCH (EERR): <EMPTY>
term p> ERROR:
term p> offset=14:
term p> unexpected IS
term p> expecting ( or expression

expression> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
expression> MATCH (CERR): "Z"
expression> ERROR:
expression> offset=14:
expression> unexpected IS
expression> expecting (, NOT, or expression

manyIndentation/leaf?> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
manyIndentation/leaf?> MATCH (EERR): <EMPTY>
manyIndentation/leaf?> ERROR:
manyIndentation/leaf?> offset=14:
manyIndentation/leaf?> unexpected IS
manyIndentation/leaf?> expecting (, NOT, or expression

************* / manyIndentation/deeper; calling someIndentation                                               :2_2:Other "Z":
************** / someIndentation                                                                             :2_2:Other "Z":
*************** / myindented: consuming GoDeeper                                                            :2_2:Other "Z":
myindented: consuming GoDeeper> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=12:
myindented: consuming GoDeeper> unexpected "Z"
myindented: consuming GoDeeper> expecting (

someIndentation> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=12:
someIndentation> unexpected "Z"
someIndentation> expecting (

manyIndentation/deeper; calling someIndentation> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
manyIndentation/deeper; calling someIndentation> MATCH (EERR): <EMPTY>
manyIndentation/deeper; calling someIndentation> ERROR:
manyIndentation/deeper; calling someIndentation> offset=12:
manyIndentation/deeper; calling someIndentation> unexpected "Z"
manyIndentation/deeper; calling someIndentation> expecting (

someIndentation> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someIndentation> MATCH (CERR): (
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting (, NOT, or expression

term p/2:someIndentation expr p> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p/2:someIndentation expr p> MATCH (CERR): (
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=14:
term p/2:someIndentation expr p> unexpected IS
term p/2:someIndentation expr p> expecting (, NOT, or expression

*********** / term p/3:plain p                                                                                 :2_2:GoDeeper:
************ / pRelPred                                                                                       :2_2:GoDeeper:
************* / slRelPred                                                                                    :2_2:GoDeeper:
************** / nested simpleHorn                                                                          :2_2:GoDeeper:
*************** > |^|                                                                                      :2_2:GoDeeper:
*************** / $*|                                                                                      :2_2:GoDeeper:
**************** / slMultiTerm                                                                            :2_2:GoDeeper:
***************** / someSL                                                                               :2_2:GoDeeper:
****************** / pNumAsText                                                                         :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

nested simpleHorn> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=11:
nested simpleHorn> unexpected (
nested simpleHorn> expecting other text or number

************** / RPConstraint                                                                               :2_2:GoDeeper:
*************** / $*|                                                                                      :2_2:GoDeeper:
**************** / slMultiTerm                                                                            :2_2:GoDeeper:
***************** / someSL                                                                               :2_2:GoDeeper:
****************** / pNumAsText                                                                         :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

RPConstraint> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=11:
RPConstraint> unexpected (
RPConstraint> expecting other text or number

************** / RPBoolStructR                                                                              :2_2:GoDeeper:
*************** / $*|                                                                                      :2_2:GoDeeper:
**************** / slMultiTerm                                                                            :2_2:GoDeeper:
***************** / someSL                                                                               :2_2:GoDeeper:
****************** / pNumAsText                                                                         :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

RPBoolStructR> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=11:
RPBoolStructR> unexpected (
RPBoolStructR> expecting other text or number

************** / RPMT                                                                                       :2_2:GoDeeper:
*************** / $*|                                                                                      :2_2:GoDeeper:
**************** / slAKA                                                                                  :2_2:GoDeeper:
***************** / $*|                                                                                  :2_2:GoDeeper:
****************** / slAKA base                                                                         :2_2:GoDeeper:
******************* / slMultiTerm                                                                      :2_2:GoDeeper:
******************** / someSL                                                                         :2_2:GoDeeper:
********************* / pNumAsText                                                                   :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

slAKA base> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=11:
slAKA base> unexpected (
slAKA base> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

slAKA> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=11:
slAKA> unexpected (
slAKA> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

RPMT> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=11:
RPMT> unexpected (
RPMT> expecting other text or number

slRelPred> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=11:
slRelPred> unexpected (
slRelPred> expecting other text or number

pRelPred> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pRelPred> MATCH (EERR): <EMPTY>
pRelPred> ERROR:
pRelPred> offset=11:
pRelPred> unexpected (
pRelPred> expecting other text or number

term p/3:plain p> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p/3:plain p> MATCH (EERR): <EMPTY>
term p/3:plain p> ERROR:
term p/3:plain p> offset=11:
term p/3:plain p> unexpected (
term p/3:plain p> expecting other text or number

term p/notLabelTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p/notLabelTerm> MATCH (EERR): <EMPTY>
term p/notLabelTerm> ERROR:
term p/notLabelTerm> offset=14:
term p/notLabelTerm> unexpected IS
term p/notLabelTerm> expecting (, NOT, or expression

term p> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p> MATCH (EERR): <EMPTY>
term p> ERROR:
term p> offset=14:
term p> unexpected IS
term p> expecting (, NOT, or expression

expression> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
expression> MATCH (EERR): <EMPTY>
expression> ERROR:
expression> offset=14:
expression> unexpected IS
expression> expecting expression

ppp inner> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
ppp inner> MATCH (EERR): <EMPTY>
ppp inner> ERROR:
ppp inner> offset=14:
ppp inner> unexpected IS
ppp inner> expecting expression

******* / withPrePost                                                                                              :2_2:GoDeeper:
******** > |<* starting                                                                                           :2_2:GoDeeper:
******** / $*|                                                                                                    :2_2:GoDeeper:
********* / pre part                                                                                             :2_2:GoDeeper:
********** / aboveNextLineKeyword                                                                                :2_2:Other "Z":
*********** / expectUnDeepers                                                                                   :2_2:Other "Z":
************ / pNumAsText                                                                                       :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
expectUnDeepers> MATCH (CERR): "Z" (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
aboveNextLineKeyword> MATCH (CERR): "Z" (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                       :2_2:Other "Z":
********** / aboveNextLineKeyword                                                                                 :2_3:GoDeeper:
*********** / expectUnDeepers                                                                                    :2_3:GoDeeper:
************ / pNumAsText                                                                                       :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
expectUnDeepers> MATCH (CERR): (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
aboveNextLineKeyword> MATCH (CERR): (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                        :2_3:GoDeeper:
********** / aboveNextLineKeyword                                                                                  :2_3:Is:
*********** / expectUnDeepers                                                                                     :2_3:Is:
************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
expectUnDeepers> MATCH (EERR): <EMPTY>
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
aboveNextLineKeyword> MATCH (EERR): <EMPTY>
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                         :2_3:Is:
pre part> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pre part> MATCH (CERR): (
pre part> ERROR:
pre part> offset=14:
pre part> unexpected IS
pre part> expecting (, ), Other text, or other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (CERR): (
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting (, ), Other text, or other text or number

withPrePost> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
withPrePost> MATCH (CERR): (
withPrePost> ERROR:
withPrePost> offset=14:
withPrePost> unexpected IS
withPrePost> expecting (, ), Other text, or other text or number

******* / withPreOnly                                                                                              :2_2:GoDeeper:
******** / $*|                                                                                                    :2_2:GoDeeper:
********* / pre part                                                                                             :2_2:GoDeeper:
********** / aboveNextLineKeyword                                                                                :2_2:Other "Z":
*********** / expectUnDeepers                                                                                   :2_2:Other "Z":
************ / pNumAsText                                                                                       :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
expectUnDeepers> MATCH (CERR): "Z" (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
aboveNextLineKeyword> MATCH (CERR): "Z" (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                       :2_2:Other "Z":
********** / aboveNextLineKeyword                                                                                 :2_3:GoDeeper:
*********** / expectUnDeepers                                                                                    :2_3:GoDeeper:
************ / pNumAsText                                                                                       :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
expectUnDeepers> MATCH (CERR): (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
aboveNextLineKeyword> MATCH (CERR): (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                        :2_3:GoDeeper:
********** / aboveNextLineKeyword                                                                                  :2_3:Is:
*********** / expectUnDeepers                                                                                     :2_3:Is:
************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
expectUnDeepers> MATCH (EERR): <EMPTY>
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
aboveNextLineKeyword> MATCH (EERR): <EMPTY>
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                         :2_3:Is:
pre part> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pre part> MATCH (CERR): (
pre part> ERROR:
pre part> offset=14:
pre part> unexpected IS
pre part> expecting (, ), Other text, or other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (CERR): (
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting (, ), Other text, or other text or number

withPreOnly> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
withPreOnly> MATCH (CERR): (
withPreOnly> ERROR:
withPreOnly> offset=14:
withPreOnly> unexpected IS
withPreOnly> expecting (, ), Other text, or other text or number

pBSR> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pBSR> MATCH (CERR): (
pBSR> ERROR:
pBSR> offset=14:
pBSR> unexpected IS
pBSR> expecting (, ), Other text, expression, or other text or number

****** / Otherwise                                                                                                 :2_1:When:
Otherwise> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
Otherwise> MATCH (EERR): <EMPTY>
Otherwise> ERROR:
Otherwise> offset=10:
Otherwise> unexpected WHEN
Otherwise> expecting OTHERWISE

whenCase> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
whenCase> MATCH (EERR): <EMPTY>
whenCase> ERROR:
whenCase> offset=14:
whenCase> unexpected IS
whenCase> expecting (, ), Other text, expression, or other text or number

***** / pHornlike/uponLimb                                                                                          :2_1:When:
****** / preambleParamText:[Upon]                                                                                  :2_1:When:
******* / $>|                                                                                                     :2_1:When:
$>|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=10:
$>|> unexpected WHEN
$>|> expecting UPON

preambleParamText:[Upon]> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
preambleParamText:[Upon]> MATCH (EERR): <EMPTY>
preambleParamText:[Upon]> ERROR:
preambleParamText:[Upon]> offset=10:
preambleParamText:[Upon]> unexpected WHEN
preambleParamText:[Upon]> expecting UPON

pHornlike/uponLimb> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pHornlike/uponLimb> MATCH (EERR): <EMPTY>
pHornlike/uponLimb> ERROR:
pHornlike/uponLimb> offset=10:
pHornlike/uponLimb> unexpected WHEN
pHornlike/uponLimb> expecting UPON

***** / whenCase                                                                                                    :2_1:When:
****** / whenMeansIf                                                                                               :2_1:When:
whenMeansIf> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
whenMeansIf> MATCH (COK): WHEN
whenMeansIf> VALUE: (When,[])

****** \ whenMeansIf has returned When                                                                              :2_2:GoDeeper:
****** / pBSR                                                                                                       :2_2:GoDeeper:
******* / ppp inner                                                                                                :2_2:GoDeeper:
******** / expression                                                                                             :2_2:GoDeeper:
********* / labelPrefix                                                                                          :2_2:GoDeeper:
labelPrefix> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=11:
labelPrefix> unexpected (
labelPrefix> expecting Other text

********* / term p                                                                                               :2_2:GoDeeper:
********** / term p/notLabelTerm                                                                                :2_2:GoDeeper:
*********** / term p/2:someIndentation expr p                                                                  :2_2:GoDeeper:
************ / someIndentation                                                                                :2_2:GoDeeper:
************* / myindented: consuming GoDeeper                                                               :2_2:GoDeeper:
myindented: consuming GoDeeper> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
myindented: consuming GoDeeper> MATCH (COK): (
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

************* \ myindented: consuming GoDeeper has returned GoDeeper                                          :2_2:Other "Z":
************* / manyIndentation/leaf?                                                                         :2_2:Other "Z":
************** / expression                                                                                  :2_2:Other "Z":
*************** / labelPrefix                                                                               :2_2:Other "Z":
labelPrefix> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
labelPrefix> MATCH (COK): "Z"
labelPrefix> VALUE: ("Z",[])

*************** \ labelPrefix has returned "Z"                                                               :2_3:GoDeeper:
*************** / term p                                                                                     :2_3:GoDeeper:
**************** / term p/notLabelTerm                                                                      :2_3:GoDeeper:
***************** / term p/2:someIndentation expr p                                                        :2_3:GoDeeper:
****************** / someIndentation                                                                      :2_3:GoDeeper:
******************* / myindented: consuming GoDeeper                                                     :2_3:GoDeeper:
myindented: consuming GoDeeper> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
myindented: consuming GoDeeper> MATCH (COK): (
myindented: consuming GoDeeper> VALUE: (GoDeeper,[])

******************* \ myindented: consuming GoDeeper has returned GoDeeper                                :2_3:Is:
******************* / manyIndentation/leaf?                                                               :2_3:Is:
******************** / expression                                                                        :2_3:Is:
********************* / labelPrefix                                                                     :2_3:Is:
labelPrefix> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
labelPrefix> MATCH (EERR): <EMPTY>
labelPrefix> ERROR:
labelPrefix> offset=14:
labelPrefix> unexpected IS
labelPrefix> expecting Other text

********************* / term p                                                                          :2_3:Is:
********************** / term p/notLabelTerm                                                           :2_3:Is:
*********************** / term p/2:someIndentation expr p                                             :2_3:Is:
************************ / someIndentation                                                           :2_3:Is:
************************* / myindented: consuming GoDeeper                                          :2_3:Is:
myindented: consuming GoDeeper> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=14:
myindented: consuming GoDeeper> unexpected IS
myindented: consuming GoDeeper> expecting (

someIndentation> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting (

term p/2:someIndentation expr p> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p/2:someIndentation expr p> MATCH (EERR): <EMPTY>
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=14:
term p/2:someIndentation expr p> unexpected IS
term p/2:someIndentation expr p> expecting (

*********************** / term p/3:plain p                                                            :2_3:Is:
************************ / pRelPred                                                                  :2_3:Is:
************************* / slRelPred                                                               :2_3:Is:
************************** / nested simpleHorn                                                     :2_3:Is:
*************************** > |^|                                                                 :2_3:Is:
*************************** / $*|                                                                 :2_3:Is:
**************************** / slMultiTerm                                                       :2_3:Is:
***************************** / someSL                                                          :2_3:Is:
****************************** / pNumAsText                                                    :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

nested simpleHorn> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=14:
nested simpleHorn> unexpected IS
nested simpleHorn> expecting other text or number

************************** / RPConstraint                                                          :2_3:Is:
*************************** / $*|                                                                 :2_3:Is:
**************************** / slMultiTerm                                                       :2_3:Is:
***************************** / someSL                                                          :2_3:Is:
****************************** / pNumAsText                                                    :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

RPConstraint> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=14:
RPConstraint> unexpected IS
RPConstraint> expecting other text or number

************************** / RPBoolStructR                                                         :2_3:Is:
*************************** / $*|                                                                 :2_3:Is:
**************************** / slMultiTerm                                                       :2_3:Is:
***************************** / someSL                                                          :2_3:Is:
****************************** / pNumAsText                                                    :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

RPBoolStructR> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=14:
RPBoolStructR> unexpected IS
RPBoolStructR> expecting other text or number

************************** / RPMT                                                                  :2_3:Is:
*************************** / $*|                                                                 :2_3:Is:
**************************** / slAKA                                                             :2_3:Is:
***************************** / $*|                                                             :2_3:Is:
****************************** / slAKA base                                                    :2_3:Is:
******************************* / slMultiTerm                                                 :2_3:Is:
******************************** / someSL                                                    :2_3:Is:
********************************* / pNumAsText                                              :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

someSL> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=14:
someSL> unexpected IS
someSL> expecting other text or number

slMultiTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=14:
slMultiTerm> unexpected IS
slMultiTerm> expecting other text or number

slAKA base> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=14:
slAKA base> unexpected IS
slAKA base> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

slAKA> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=14:
slAKA> unexpected IS
slAKA> expecting other text or number

$*|> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting other text or number

RPMT> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=14:
RPMT> unexpected IS
RPMT> expecting other text or number

slRelPred> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=14:
slRelPred> unexpected IS
slRelPred> expecting other text or number

pRelPred> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pRelPred> MATCH (EERR): <EMPTY>
pRelPred> ERROR:
pRelPred> offset=14:
pRelPred> unexpected IS
pRelPred> expecting other text or number

term p/3:plain p> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p/3:plain p> MATCH (EERR): <EMPTY>
term p/3:plain p> ERROR:
term p/3:plain p> offset=14:
term p/3:plain p> unexpected IS
term p/3:plain p> expecting other text or number

term p/notLabelTerm> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p/notLabelTerm> MATCH (EERR): <EMPTY>
term p/notLabelTerm> ERROR:
term p/notLabelTerm> offset=14:
term p/notLabelTerm> unexpected IS
term p/notLabelTerm> expecting ( or term

term p> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
term p> MATCH (EERR): <EMPTY>
term p> ERROR:
term p> offset=14:
term p> unexpected IS
term p> expecting ( or term

expression> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
expression> MATCH (EERR): <EMPTY>
expression> ERROR:
expression> offset=14:
expression> unexpected IS
expression> expecting expression

manyIndentation/leaf?> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
manyIndentation/leaf?> MATCH (EERR): <EMPTY>
manyIndentation/leaf?> ERROR:
manyIndentation/leaf?> offset=14:
manyIndentation/leaf?> unexpected IS
manyIndentation/leaf?> expecting expression

******************* / manyIndentation/deeper; calling someIndentation                                     :2_3:Is:
******************** / someIndentation                                                                   :2_3:Is:
********************* / myindented: consuming GoDeeper                                                  :2_3:Is:
myindented: consuming GoDeeper> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=14:
myindented: consuming GoDeeper> unexpected IS
myindented: consuming GoDeeper> expecting (

someIndentation> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting (

manyIndentation/deeper; calling someIndentation> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
manyIndentation/deeper; calling someIndentation> MATCH (EERR): <EMPTY>
manyIndentation/deeper; calling someIndentation> ERROR:
manyIndentation/deeper; calling someIndentation> offset=14:
manyIndentation/deeper; calling someIndentation> unexpected IS
manyIndentation/deeper; calling someIndentation> expecting (

someIndentation> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someIndentation> MATCH (CERR): (
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting ( or expression

term p/2:someIndentation expr p> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p/2:someIndentation expr p> MATCH (CERR): (
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=14:
term p/2:someIndentation expr p> unexpected IS
term p/2:someIndentation expr p> expecting ( or expression

***************** / term p/3:plain p                                                                       :2_3:GoDeeper:
****************** / pRelPred                                                                             :2_3:GoDeeper:
******************* / slRelPred                                                                          :2_3:GoDeeper:
******************** / nested simpleHorn                                                                :2_3:GoDeeper:
********************* > |^|                                                                            :2_3:GoDeeper:
********************* / $*|                                                                            :2_3:GoDeeper:
********************** / slMultiTerm                                                                  :2_3:GoDeeper:
*********************** / someSL                                                                     :2_3:GoDeeper:
************************ / pNumAsText                                                               :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

nested simpleHorn> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=13:
nested simpleHorn> unexpected (
nested simpleHorn> expecting other text or number

******************** / RPConstraint                                                                     :2_3:GoDeeper:
********************* / $*|                                                                            :2_3:GoDeeper:
********************** / slMultiTerm                                                                  :2_3:GoDeeper:
*********************** / someSL                                                                     :2_3:GoDeeper:
************************ / pNumAsText                                                               :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

RPConstraint> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=13:
RPConstraint> unexpected (
RPConstraint> expecting other text or number

******************** / RPBoolStructR                                                                    :2_3:GoDeeper:
********************* / $*|                                                                            :2_3:GoDeeper:
********************** / slMultiTerm                                                                  :2_3:GoDeeper:
*********************** / someSL                                                                     :2_3:GoDeeper:
************************ / pNumAsText                                                               :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

RPBoolStructR> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=13:
RPBoolStructR> unexpected (
RPBoolStructR> expecting other text or number

******************** / RPMT                                                                             :2_3:GoDeeper:
********************* / $*|                                                                            :2_3:GoDeeper:
********************** / slAKA                                                                        :2_3:GoDeeper:
*********************** / $*|                                                                        :2_3:GoDeeper:
************************ / slAKA base                                                               :2_3:GoDeeper:
************************* / slMultiTerm                                                            :2_3:GoDeeper:
************************** / someSL                                                               :2_3:GoDeeper:
*************************** / pNumAsText                                                         :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=13:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=13:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

slAKA base> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=13:
slAKA base> unexpected (
slAKA base> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

slAKA> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=13:
slAKA> unexpected (
slAKA> expecting other text or number

$*|> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=13:
$*|> unexpected (
$*|> expecting other text or number

RPMT> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=13:
RPMT> unexpected (
RPMT> expecting other text or number

slRelPred> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=13:
slRelPred> unexpected (
slRelPred> expecting other text or number

pRelPred> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pRelPred> MATCH (EERR): <EMPTY>
pRelPred> ERROR:
pRelPred> offset=13:
pRelPred> unexpected (
pRelPred> expecting other text or number

term p/3:plain p> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p/3:plain p> MATCH (EERR): <EMPTY>
term p/3:plain p> ERROR:
term p/3:plain p> offset=13:
term p/3:plain p> unexpected (
term p/3:plain p> expecting other text or number

term p/notLabelTerm> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p/notLabelTerm> MATCH (EERR): <EMPTY>
term p/notLabelTerm> ERROR:
term p/notLabelTerm> offset=14:
term p/notLabelTerm> unexpected IS
term p/notLabelTerm> expecting ( or expression

term p> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
term p> MATCH (EERR): <EMPTY>
term p> ERROR:
term p> offset=14:
term p> unexpected IS
term p> expecting ( or expression

expression> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
expression> MATCH (CERR): "Z"
expression> ERROR:
expression> offset=14:
expression> unexpected IS
expression> expecting (, NOT, or expression

manyIndentation/leaf?> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
manyIndentation/leaf?> MATCH (EERR): <EMPTY>
manyIndentation/leaf?> ERROR:
manyIndentation/leaf?> offset=14:
manyIndentation/leaf?> unexpected IS
manyIndentation/leaf?> expecting (, NOT, or expression

************* / manyIndentation/deeper; calling someIndentation                                               :2_2:Other "Z":
************** / someIndentation                                                                             :2_2:Other "Z":
*************** / myindented: consuming GoDeeper                                                            :2_2:Other "Z":
myindented: consuming GoDeeper> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=12:
myindented: consuming GoDeeper> unexpected "Z"
myindented: consuming GoDeeper> expecting (

someIndentation> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=12:
someIndentation> unexpected "Z"
someIndentation> expecting (

manyIndentation/deeper; calling someIndentation> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
manyIndentation/deeper; calling someIndentation> MATCH (EERR): <EMPTY>
manyIndentation/deeper; calling someIndentation> ERROR:
manyIndentation/deeper; calling someIndentation> offset=12:
manyIndentation/deeper; calling someIndentation> unexpected "Z"
manyIndentation/deeper; calling someIndentation> expecting (

someIndentation> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someIndentation> MATCH (CERR): (
someIndentation> ERROR:
someIndentation> offset=14:
someIndentation> unexpected IS
someIndentation> expecting (, NOT, or expression

term p/2:someIndentation expr p> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p/2:someIndentation expr p> MATCH (CERR): (
term p/2:someIndentation expr p> ERROR:
term p/2:someIndentation expr p> offset=14:
term p/2:someIndentation expr p> unexpected IS
term p/2:someIndentation expr p> expecting (, NOT, or expression

*********** / term p/3:plain p                                                                                 :2_2:GoDeeper:
************ / pRelPred                                                                                       :2_2:GoDeeper:
************* / slRelPred                                                                                    :2_2:GoDeeper:
************** / nested simpleHorn                                                                          :2_2:GoDeeper:
*************** > |^|                                                                                      :2_2:GoDeeper:
*************** / $*|                                                                                      :2_2:GoDeeper:
**************** / slMultiTerm                                                                            :2_2:GoDeeper:
***************** / someSL                                                                               :2_2:GoDeeper:
****************** / pNumAsText                                                                         :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

nested simpleHorn> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=11:
nested simpleHorn> unexpected (
nested simpleHorn> expecting other text or number

************** / RPConstraint                                                                               :2_2:GoDeeper:
*************** / $*|                                                                                      :2_2:GoDeeper:
**************** / slMultiTerm                                                                            :2_2:GoDeeper:
***************** / someSL                                                                               :2_2:GoDeeper:
****************** / pNumAsText                                                                         :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

RPConstraint> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=11:
RPConstraint> unexpected (
RPConstraint> expecting other text or number

************** / RPBoolStructR                                                                              :2_2:GoDeeper:
*************** / $*|                                                                                      :2_2:GoDeeper:
**************** / slMultiTerm                                                                            :2_2:GoDeeper:
***************** / someSL                                                                               :2_2:GoDeeper:
****************** / pNumAsText                                                                         :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

RPBoolStructR> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=11:
RPBoolStructR> unexpected (
RPBoolStructR> expecting other text or number

************** / RPMT                                                                                       :2_2:GoDeeper:
*************** / $*|                                                                                      :2_2:GoDeeper:
**************** / slAKA                                                                                  :2_2:GoDeeper:
***************** / $*|                                                                                  :2_2:GoDeeper:
****************** / slAKA base                                                                         :2_2:GoDeeper:
******************* / slMultiTerm                                                                      :2_2:GoDeeper:
******************** / someSL                                                                         :2_2:GoDeeper:
********************* / pNumAsText                                                                   :2_2:GoDeeper:
pNumAsText> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=11:
pNumAsText> unexpected (
pNumAsText> expecting number

someSL> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=11:
someSL> unexpected (
someSL> expecting other text or number

slMultiTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=11:
slMultiTerm> unexpected (
slMultiTerm> expecting other text or number

slAKA base> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=11:
slAKA base> unexpected (
slAKA base> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

slAKA> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=11:
slAKA> unexpected (
slAKA> expecting other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=11:
$*|> unexpected (
$*|> expecting other text or number

RPMT> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=11:
RPMT> unexpected (
RPMT> expecting other text or number

slRelPred> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=11:
slRelPred> unexpected (
slRelPred> expecting other text or number

pRelPred> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pRelPred> MATCH (EERR): <EMPTY>
pRelPred> ERROR:
pRelPred> offset=11:
pRelPred> unexpected (
pRelPred> expecting other text or number

term p/3:plain p> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p/3:plain p> MATCH (EERR): <EMPTY>
term p/3:plain p> ERROR:
term p/3:plain p> offset=11:
term p/3:plain p> unexpected (
term p/3:plain p> expecting other text or number

term p/notLabelTerm> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p/notLabelTerm> MATCH (EERR): <EMPTY>
term p/notLabelTerm> ERROR:
term p/notLabelTerm> offset=14:
term p/notLabelTerm> unexpected IS
term p/notLabelTerm> expecting (, NOT, or expression

term p> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
term p> MATCH (EERR): <EMPTY>
term p> ERROR:
term p> offset=14:
term p> unexpected IS
term p> expecting (, NOT, or expression

expression> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
expression> MATCH (EERR): <EMPTY>
expression> ERROR:
expression> offset=14:
expression> unexpected IS
expression> expecting expression

ppp inner> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
ppp inner> MATCH (EERR): <EMPTY>
ppp inner> ERROR:
ppp inner> offset=14:
ppp inner> unexpected IS
ppp inner> expecting expression

******* / withPrePost                                                                                              :2_2:GoDeeper:
******** > |<* starting                                                                                           :2_2:GoDeeper:
******** / $*|                                                                                                    :2_2:GoDeeper:
********* / pre part                                                                                             :2_2:GoDeeper:
********** / aboveNextLineKeyword                                                                                :2_2:Other "Z":
*********** / expectUnDeepers                                                                                   :2_2:Other "Z":
************ / pNumAsText                                                                                       :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
expectUnDeepers> MATCH (CERR): "Z" (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
aboveNextLineKeyword> MATCH (CERR): "Z" (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                       :2_2:Other "Z":
********** / aboveNextLineKeyword                                                                                 :2_3:GoDeeper:
*********** / expectUnDeepers                                                                                    :2_3:GoDeeper:
************ / pNumAsText                                                                                       :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
expectUnDeepers> MATCH (CERR): (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
aboveNextLineKeyword> MATCH (CERR): (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                        :2_3:GoDeeper:
********** / aboveNextLineKeyword                                                                                  :2_3:Is:
*********** / expectUnDeepers                                                                                     :2_3:Is:
************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
expectUnDeepers> MATCH (EERR): <EMPTY>
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
aboveNextLineKeyword> MATCH (EERR): <EMPTY>
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                         :2_3:Is:
pre part> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pre part> MATCH (CERR): (
pre part> ERROR:
pre part> offset=14:
pre part> unexpected IS
pre part> expecting (, ), Other text, or other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (CERR): (
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting (, ), Other text, or other text or number

withPrePost> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
withPrePost> MATCH (CERR): (
withPrePost> ERROR:
withPrePost> offset=14:
withPrePost> unexpected IS
withPrePost> expecting (, ), Other text, or other text or number

******* / withPreOnly                                                                                              :2_2:GoDeeper:
******** / $*|                                                                                                    :2_2:GoDeeper:
********* / pre part                                                                                             :2_2:GoDeeper:
********** / aboveNextLineKeyword                                                                                :2_2:Other "Z":
*********** / expectUnDeepers                                                                                   :2_2:Other "Z":
************ / pNumAsText                                                                                       :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
expectUnDeepers> MATCH (CERR): "Z" (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP <…>
aboveNextLineKeyword> MATCH (CERR): "Z" (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                       :2_2:Other "Z":
********** / aboveNextLineKeyword                                                                                 :2_3:GoDeeper:
*********** / expectUnDeepers                                                                                    :2_3:GoDeeper:
************ / pNumAsText                                                                                       :2_3:GoDeeper:
pNumAsText> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=13:
pNumAsText> unexpected (
pNumAsText> expecting number

************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
expectUnDeepers> MATCH (CERR): (
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: ( IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" )  <…>
aboveNextLineKeyword> MATCH (CERR): (
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                        :2_3:GoDeeper:
********** / aboveNextLineKeyword                                                                                  :2_3:Is:
*********** / expectUnDeepers                                                                                     :2_3:Is:
************ / pNumAsText                                                                                        :2_3:Is:
pNumAsText> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=14:
pNumAsText> unexpected IS
pNumAsText> expecting number

expectUnDeepers> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
expectUnDeepers> MATCH (EERR): <EMPTY>
expectUnDeepers> ERROR:
expectUnDeepers> offset=14:
expectUnDeepers> unexpected IS
expectUnDeepers> expecting (, ), or other text or number

aboveNextLineKeyword> IN: IS ( "Q" ) ) ) AND ( "P" ( > ( "NP" ) )  <…>
aboveNextLineKeyword> MATCH (EERR): <EMPTY>
aboveNextLineKeyword> ERROR:
aboveNextLineKeyword> offset=14:
aboveNextLineKeyword> unexpected IS
aboveNextLineKeyword> expecting (, ), or other text or number

********** > /*= lookAhead failed, delegating to plain /+=                                                         :2_3:Is:
pre part> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pre part> MATCH (CERR): (
pre part> ERROR:
pre part> offset=14:
pre part> unexpected IS
pre part> expecting (, ), Other text, or other text or number

$*|> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
$*|> MATCH (CERR): (
$*|> ERROR:
$*|> offset=14:
$*|> unexpected IS
$*|> expecting (, ), Other text, or other text or number

withPreOnly> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
withPreOnly> MATCH (CERR): (
withPreOnly> ERROR:
withPreOnly> offset=14:
withPreOnly> unexpected IS
withPreOnly> expecting (, ), Other text, or other text or number

pBSR> IN: ( "Z" ( IS ( "Q" ) ) ) AND ( "P" ( > ( " <…>
pBSR> MATCH (CERR): (
pBSR> ERROR:
pBSR> offset=14:
pBSR> unexpected IS
pBSR> expecting (, ), Other text, expression, or other text or number

****** / Otherwise                                                                                                 :2_1:When:
Otherwise> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
Otherwise> MATCH (EERR): <EMPTY>
Otherwise> ERROR:
Otherwise> offset=10:
Otherwise> unexpected WHEN
Otherwise> expecting OTHERWISE

whenCase> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
whenCase> MATCH (EERR): <EMPTY>
whenCase> ERROR:
whenCase> offset=14:
whenCase> unexpected IS
whenCase> expecting (, ), Other text, expression, or other text or number

***** / pHornlike/ambitious                                                                                         :2_1:When:
****** / $>|                                                                                                       :2_1:When:
$>|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=10:
$>|> unexpected WHEN
$>|> expecting DECIDE or DEFINE

pHornlike/ambitious> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pHornlike/ambitious> MATCH (EERR): <EMPTY>
pHornlike/ambitious> ERROR:
pHornlike/ambitious> offset=10:
pHornlike/ambitious> unexpected WHEN
pHornlike/ambitious> expecting DECIDE or DEFINE

***** / pHornlike/someStructure                                                                                     :2_1:When:
****** / manyIndentation/leaf?                                                                                     :2_1:When:
******* / relPredNextlineWhen                                                                                     :2_1:When:
******** / pRelPred optIndentedTuple whenCase                                                                    :2_1:When:
********* / optIndentedTuple                                                                                    :2_1:When:
********** / optIndented                                                                                       :2_1:When:
*********** / pRelPred                                                                                        :2_1:When:
************ / slRelPred                                                                                     :2_1:When:
************* / nested simpleHorn                                                                           :2_1:When:
************** > |^|                                                                                       :2_1:When:
************** / $*|                                                                                       :2_1:When:
*************** / slMultiTerm                                                                             :2_1:When:
**************** / someSL                                                                                :2_1:When:
***************** / pNumAsText                                                                          :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

nested simpleHorn> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=10:
nested simpleHorn> unexpected WHEN
nested simpleHorn> expecting other text or number

************* / RPConstraint                                                                                :2_1:When:
************** / $*|                                                                                       :2_1:When:
*************** / slMultiTerm                                                                             :2_1:When:
**************** / someSL                                                                                :2_1:When:
***************** / pNumAsText                                                                          :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

RPConstraint> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=10:
RPConstraint> unexpected WHEN
RPConstraint> expecting other text or number

************* / RPBoolStructR                                                                               :2_1:When:
************** / $*|                                                                                       :2_1:When:
*************** / slMultiTerm                                                                             :2_1:When:
**************** / someSL                                                                                :2_1:When:
***************** / pNumAsText                                                                          :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

RPBoolStructR> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=10:
RPBoolStructR> unexpected WHEN
RPBoolStructR> expecting other text or number

************* / RPMT                                                                                        :2_1:When:
************** / $*|                                                                                       :2_1:When:
*************** / slAKA                                                                                   :2_1:When:
**************** / $*|                                                                                   :2_1:When:
***************** / slAKA base                                                                          :2_1:When:
****************** / slMultiTerm                                                                       :2_1:When:
******************* / someSL                                                                          :2_1:When:
******************** / pNumAsText                                                                    :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

slAKA base> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=10:
slAKA base> unexpected WHEN
slAKA base> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

slAKA> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=10:
slAKA> unexpected WHEN
slAKA> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

RPMT> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=10:
RPMT> unexpected WHEN
RPMT> expecting other text or number

slRelPred> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=10:
slRelPred> unexpected WHEN
slRelPred> expecting other text or number

pRelPred> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pRelPred> MATCH (EERR): <EMPTY>
pRelPred> ERROR:
pRelPred> offset=10:
pRelPred> unexpected WHEN
pRelPred> expecting other text or number

optIndented> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
optIndented> MATCH (EERR): <EMPTY>
optIndented> ERROR:
optIndented> offset=10:
optIndented> unexpected WHEN
optIndented> expecting other text or number

optIndentedTuple> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
optIndentedTuple> MATCH (EERR): <EMPTY>
optIndentedTuple> ERROR:
optIndentedTuple> offset=10:
optIndentedTuple> unexpected WHEN
optIndentedTuple> expecting other text or number

pRelPred optIndentedTuple whenCase> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pRelPred optIndentedTuple whenCase> MATCH (EERR): <EMPTY>
pRelPred optIndentedTuple whenCase> ERROR:
pRelPred optIndentedTuple whenCase> offset=10:
pRelPred optIndentedTuple whenCase> unexpected WHEN
pRelPred optIndentedTuple whenCase> expecting other text or number

relPredNextlineWhen> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
relPredNextlineWhen> MATCH (EERR): <EMPTY>
relPredNextlineWhen> ERROR:
relPredNextlineWhen> offset=10:
relPredNextlineWhen> unexpected WHEN
relPredNextlineWhen> expecting other text or number

******* / relPredSamelineWhen                                                                                     :2_1:When:
******** / $*|                                                                                                   :2_1:When:
********* / slRelPred                                                                                           :2_1:When:
********** / nested simpleHorn                                                                                 :2_1:When:
*********** > |^|                                                                                             :2_1:When:
*********** / $*|                                                                                             :2_1:When:
************ / slMultiTerm                                                                                   :2_1:When:
************* / someSL                                                                                      :2_1:When:
************** / pNumAsText                                                                                :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

nested simpleHorn> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=10:
nested simpleHorn> unexpected WHEN
nested simpleHorn> expecting other text or number

********** / RPConstraint                                                                                      :2_1:When:
*********** / $*|                                                                                             :2_1:When:
************ / slMultiTerm                                                                                   :2_1:When:
************* / someSL                                                                                      :2_1:When:
************** / pNumAsText                                                                                :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

RPConstraint> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=10:
RPConstraint> unexpected WHEN
RPConstraint> expecting other text or number

********** / RPBoolStructR                                                                                     :2_1:When:
*********** / $*|                                                                                             :2_1:When:
************ / slMultiTerm                                                                                   :2_1:When:
************* / someSL                                                                                      :2_1:When:
************** / pNumAsText                                                                                :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

RPBoolStructR> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=10:
RPBoolStructR> unexpected WHEN
RPBoolStructR> expecting other text or number

********** / RPMT                                                                                              :2_1:When:
*********** / $*|                                                                                             :2_1:When:
************ / slAKA                                                                                         :2_1:When:
************* / $*|                                                                                         :2_1:When:
************** / slAKA base                                                                                :2_1:When:
*************** / slMultiTerm                                                                             :2_1:When:
**************** / someSL                                                                                :2_1:When:
***************** / pNumAsText                                                                          :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

slAKA base> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=10:
slAKA base> unexpected WHEN
slAKA base> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

slAKA> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=10:
slAKA> unexpected WHEN
slAKA> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

RPMT> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=10:
RPMT> unexpected WHEN
RPMT> expecting other text or number

slRelPred> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=10:
slRelPred> unexpected WHEN
slRelPred> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

relPredSamelineWhen> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
relPredSamelineWhen> MATCH (EERR): <EMPTY>
relPredSamelineWhen> ERROR:
relPredSamelineWhen> offset=10:
relPredSamelineWhen> unexpected WHEN
relPredSamelineWhen> expecting other text or number

manyIndentation/leaf?> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
manyIndentation/leaf?> MATCH (EERR): <EMPTY>
manyIndentation/leaf?> ERROR:
manyIndentation/leaf?> offset=10:
manyIndentation/leaf?> unexpected WHEN
manyIndentation/leaf?> expecting other text or number

****** / manyIndentation/deeper; calling someIndentation                                                           :2_1:When:
******* / someIndentation                                                                                         :2_1:When:
******** / myindented: consuming GoDeeper                                                                        :2_1:When:
myindented: consuming GoDeeper> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=10:
myindented: consuming GoDeeper> unexpected WHEN
myindented: consuming GoDeeper> expecting (

someIndentation> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=10:
someIndentation> unexpected WHEN
someIndentation> expecting (

manyIndentation/deeper; calling someIndentation> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
manyIndentation/deeper; calling someIndentation> MATCH (EERR): <EMPTY>
manyIndentation/deeper; calling someIndentation> ERROR:
manyIndentation/deeper; calling someIndentation> offset=10:
manyIndentation/deeper; calling someIndentation> unexpected WHEN
manyIndentation/deeper; calling someIndentation> expecting (

pHornlike/someStructure> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pHornlike/someStructure> MATCH (EERR): <EMPTY>
pHornlike/someStructure> ERROR:
pHornlike/someStructure> offset=10:
pHornlike/someStructure> unexpected WHEN
pHornlike/someStructure> expecting (, DECIDE, DEFINE, or other text or number

***** / pHornlike/ambitious                                                                                         :2_1:When:
****** / $>|                                                                                                       :2_1:When:
$>|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=10:
$>|> unexpected WHEN
$>|> expecting DECIDE or DEFINE

pHornlike/ambitious> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pHornlike/ambitious> MATCH (EERR): <EMPTY>
pHornlike/ambitious> ERROR:
pHornlike/ambitious> offset=10:
pHornlike/ambitious> unexpected WHEN
pHornlike/ambitious> expecting DECIDE or DEFINE

***** / pHornlike/someStructure                                                                                     :2_1:When:
****** / manyIndentation/leaf?                                                                                     :2_1:When:
******* / relPredNextlineWhen                                                                                     :2_1:When:
******** / pRelPred optIndentedTuple whenCase                                                                    :2_1:When:
********* / optIndentedTuple                                                                                    :2_1:When:
********** / optIndented                                                                                       :2_1:When:
*********** / pRelPred                                                                                        :2_1:When:
************ / slRelPred                                                                                     :2_1:When:
************* / nested simpleHorn                                                                           :2_1:When:
************** > |^|                                                                                       :2_1:When:
************** / $*|                                                                                       :2_1:When:
*************** / slMultiTerm                                                                             :2_1:When:
**************** / someSL                                                                                :2_1:When:
***************** / pNumAsText                                                                          :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

nested simpleHorn> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=10:
nested simpleHorn> unexpected WHEN
nested simpleHorn> expecting other text or number

************* / RPConstraint                                                                                :2_1:When:
************** / $*|                                                                                       :2_1:When:
*************** / slMultiTerm                                                                             :2_1:When:
**************** / someSL                                                                                :2_1:When:
***************** / pNumAsText                                                                          :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

RPConstraint> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=10:
RPConstraint> unexpected WHEN
RPConstraint> expecting other text or number

************* / RPBoolStructR                                                                               :2_1:When:
************** / $*|                                                                                       :2_1:When:
*************** / slMultiTerm                                                                             :2_1:When:
**************** / someSL                                                                                :2_1:When:
***************** / pNumAsText                                                                          :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

RPBoolStructR> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=10:
RPBoolStructR> unexpected WHEN
RPBoolStructR> expecting other text or number

************* / RPMT                                                                                        :2_1:When:
************** / $*|                                                                                       :2_1:When:
*************** / slAKA                                                                                   :2_1:When:
**************** / $*|                                                                                   :2_1:When:
***************** / slAKA base                                                                          :2_1:When:
****************** / slMultiTerm                                                                       :2_1:When:
******************* / someSL                                                                          :2_1:When:
******************** / pNumAsText                                                                    :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

slAKA base> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=10:
slAKA base> unexpected WHEN
slAKA base> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

slAKA> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=10:
slAKA> unexpected WHEN
slAKA> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

RPMT> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=10:
RPMT> unexpected WHEN
RPMT> expecting other text or number

slRelPred> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=10:
slRelPred> unexpected WHEN
slRelPred> expecting other text or number

pRelPred> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pRelPred> MATCH (EERR): <EMPTY>
pRelPred> ERROR:
pRelPred> offset=10:
pRelPred> unexpected WHEN
pRelPred> expecting other text or number

optIndented> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
optIndented> MATCH (EERR): <EMPTY>
optIndented> ERROR:
optIndented> offset=10:
optIndented> unexpected WHEN
optIndented> expecting other text or number

optIndentedTuple> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
optIndentedTuple> MATCH (EERR): <EMPTY>
optIndentedTuple> ERROR:
optIndentedTuple> offset=10:
optIndentedTuple> unexpected WHEN
optIndentedTuple> expecting other text or number

pRelPred optIndentedTuple whenCase> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pRelPred optIndentedTuple whenCase> MATCH (EERR): <EMPTY>
pRelPred optIndentedTuple whenCase> ERROR:
pRelPred optIndentedTuple whenCase> offset=10:
pRelPred optIndentedTuple whenCase> unexpected WHEN
pRelPred optIndentedTuple whenCase> expecting other text or number

relPredNextlineWhen> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
relPredNextlineWhen> MATCH (EERR): <EMPTY>
relPredNextlineWhen> ERROR:
relPredNextlineWhen> offset=10:
relPredNextlineWhen> unexpected WHEN
relPredNextlineWhen> expecting other text or number

******* / relPredSamelineWhen                                                                                     :2_1:When:
******** / $*|                                                                                                   :2_1:When:
********* / slRelPred                                                                                           :2_1:When:
********** / nested simpleHorn                                                                                 :2_1:When:
*********** > |^|                                                                                             :2_1:When:
*********** / $*|                                                                                             :2_1:When:
************ / slMultiTerm                                                                                   :2_1:When:
************* / someSL                                                                                      :2_1:When:
************** / pNumAsText                                                                                :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

nested simpleHorn> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=10:
nested simpleHorn> unexpected WHEN
nested simpleHorn> expecting other text or number

********** / RPConstraint                                                                                      :2_1:When:
*********** / $*|                                                                                             :2_1:When:
************ / slMultiTerm                                                                                   :2_1:When:
************* / someSL                                                                                      :2_1:When:
************** / pNumAsText                                                                                :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

RPConstraint> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=10:
RPConstraint> unexpected WHEN
RPConstraint> expecting other text or number

********** / RPBoolStructR                                                                                     :2_1:When:
*********** / $*|                                                                                             :2_1:When:
************ / slMultiTerm                                                                                   :2_1:When:
************* / someSL                                                                                      :2_1:When:
************** / pNumAsText                                                                                :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

RPBoolStructR> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=10:
RPBoolStructR> unexpected WHEN
RPBoolStructR> expecting other text or number

********** / RPMT                                                                                              :2_1:When:
*********** / $*|                                                                                             :2_1:When:
************ / slAKA                                                                                         :2_1:When:
************* / $*|                                                                                         :2_1:When:
************** / slAKA base                                                                                :2_1:When:
*************** / slMultiTerm                                                                             :2_1:When:
**************** / someSL                                                                                :2_1:When:
***************** / pNumAsText                                                                          :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

slAKA base> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=10:
slAKA base> unexpected WHEN
slAKA base> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

slAKA> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=10:
slAKA> unexpected WHEN
slAKA> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

RPMT> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=10:
RPMT> unexpected WHEN
RPMT> expecting other text or number

slRelPred> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=10:
slRelPred> unexpected WHEN
slRelPred> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

relPredSamelineWhen> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
relPredSamelineWhen> MATCH (EERR): <EMPTY>
relPredSamelineWhen> ERROR:
relPredSamelineWhen> offset=10:
relPredSamelineWhen> unexpected WHEN
relPredSamelineWhen> expecting other text or number

manyIndentation/leaf?> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
manyIndentation/leaf?> MATCH (EERR): <EMPTY>
manyIndentation/leaf?> ERROR:
manyIndentation/leaf?> offset=10:
manyIndentation/leaf?> unexpected WHEN
manyIndentation/leaf?> expecting other text or number

****** / manyIndentation/deeper; calling someIndentation                                                           :2_1:When:
******* / someIndentation                                                                                         :2_1:When:
******** / myindented: consuming GoDeeper                                                                        :2_1:When:
myindented: consuming GoDeeper> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=10:
myindented: consuming GoDeeper> unexpected WHEN
myindented: consuming GoDeeper> expecting (

someIndentation> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=10:
someIndentation> unexpected WHEN
someIndentation> expecting (

manyIndentation/deeper; calling someIndentation> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
manyIndentation/deeper; calling someIndentation> MATCH (EERR): <EMPTY>
manyIndentation/deeper; calling someIndentation> ERROR:
manyIndentation/deeper; calling someIndentation> offset=10:
manyIndentation/deeper; calling someIndentation> unexpected WHEN
manyIndentation/deeper; calling someIndentation> expecting (

pHornlike/someStructure> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pHornlike/someStructure> MATCH (EERR): <EMPTY>
pHornlike/someStructure> ERROR:
pHornlike/someStructure> offset=10:
pHornlike/someStructure> unexpected WHEN
pHornlike/someStructure> expecting (, DECIDE, DEFINE, or other text or number

***** / pHornlike/ambitious                                                                                         :2_1:When:
****** / $>|                                                                                                       :2_1:When:
$>|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=10:
$>|> unexpected WHEN
$>|> expecting DECIDE or DEFINE

pHornlike/ambitious> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pHornlike/ambitious> MATCH (EERR): <EMPTY>
pHornlike/ambitious> ERROR:
pHornlike/ambitious> offset=10:
pHornlike/ambitious> unexpected WHEN
pHornlike/ambitious> expecting DECIDE or DEFINE

***** / pHornlike/someStructure                                                                                     :2_1:When:
****** / manyIndentation/leaf?                                                                                     :2_1:When:
******* / relPredNextlineWhen                                                                                     :2_1:When:
******** / pRelPred optIndentedTuple whenCase                                                                    :2_1:When:
********* / optIndentedTuple                                                                                    :2_1:When:
********** / optIndented                                                                                       :2_1:When:
*********** / pRelPred                                                                                        :2_1:When:
************ / slRelPred                                                                                     :2_1:When:
************* / nested simpleHorn                                                                           :2_1:When:
************** > |^|                                                                                       :2_1:When:
************** / $*|                                                                                       :2_1:When:
*************** / slMultiTerm                                                                             :2_1:When:
**************** / someSL                                                                                :2_1:When:
***************** / pNumAsText                                                                          :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

nested simpleHorn> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=10:
nested simpleHorn> unexpected WHEN
nested simpleHorn> expecting other text or number

************* / RPConstraint                                                                                :2_1:When:
************** / $*|                                                                                       :2_1:When:
*************** / slMultiTerm                                                                             :2_1:When:
**************** / someSL                                                                                :2_1:When:
***************** / pNumAsText                                                                          :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

RPConstraint> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=10:
RPConstraint> unexpected WHEN
RPConstraint> expecting other text or number

************* / RPBoolStructR                                                                               :2_1:When:
************** / $*|                                                                                       :2_1:When:
*************** / slMultiTerm                                                                             :2_1:When:
**************** / someSL                                                                                :2_1:When:
***************** / pNumAsText                                                                          :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

RPBoolStructR> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=10:
RPBoolStructR> unexpected WHEN
RPBoolStructR> expecting other text or number

************* / RPMT                                                                                        :2_1:When:
************** / $*|                                                                                       :2_1:When:
*************** / slAKA                                                                                   :2_1:When:
**************** / $*|                                                                                   :2_1:When:
***************** / slAKA base                                                                          :2_1:When:
****************** / slMultiTerm                                                                       :2_1:When:
******************* / someSL                                                                          :2_1:When:
******************** / pNumAsText                                                                    :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

slAKA base> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=10:
slAKA base> unexpected WHEN
slAKA base> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

slAKA> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=10:
slAKA> unexpected WHEN
slAKA> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

RPMT> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=10:
RPMT> unexpected WHEN
RPMT> expecting other text or number

slRelPred> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=10:
slRelPred> unexpected WHEN
slRelPred> expecting other text or number

pRelPred> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pRelPred> MATCH (EERR): <EMPTY>
pRelPred> ERROR:
pRelPred> offset=10:
pRelPred> unexpected WHEN
pRelPred> expecting other text or number

optIndented> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
optIndented> MATCH (EERR): <EMPTY>
optIndented> ERROR:
optIndented> offset=10:
optIndented> unexpected WHEN
optIndented> expecting other text or number

optIndentedTuple> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
optIndentedTuple> MATCH (EERR): <EMPTY>
optIndentedTuple> ERROR:
optIndentedTuple> offset=10:
optIndentedTuple> unexpected WHEN
optIndentedTuple> expecting other text or number

pRelPred optIndentedTuple whenCase> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pRelPred optIndentedTuple whenCase> MATCH (EERR): <EMPTY>
pRelPred optIndentedTuple whenCase> ERROR:
pRelPred optIndentedTuple whenCase> offset=10:
pRelPred optIndentedTuple whenCase> unexpected WHEN
pRelPred optIndentedTuple whenCase> expecting other text or number

relPredNextlineWhen> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
relPredNextlineWhen> MATCH (EERR): <EMPTY>
relPredNextlineWhen> ERROR:
relPredNextlineWhen> offset=10:
relPredNextlineWhen> unexpected WHEN
relPredNextlineWhen> expecting other text or number

******* / relPredSamelineWhen                                                                                     :2_1:When:
******** / $*|                                                                                                   :2_1:When:
********* / slRelPred                                                                                           :2_1:When:
********** / nested simpleHorn                                                                                 :2_1:When:
*********** > |^|                                                                                             :2_1:When:
*********** / $*|                                                                                             :2_1:When:
************ / slMultiTerm                                                                                   :2_1:When:
************* / someSL                                                                                      :2_1:When:
************** / pNumAsText                                                                                :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

nested simpleHorn> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
nested simpleHorn> MATCH (EERR): <EMPTY>
nested simpleHorn> ERROR:
nested simpleHorn> offset=10:
nested simpleHorn> unexpected WHEN
nested simpleHorn> expecting other text or number

********** / RPConstraint                                                                                      :2_1:When:
*********** / $*|                                                                                             :2_1:When:
************ / slMultiTerm                                                                                   :2_1:When:
************* / someSL                                                                                      :2_1:When:
************** / pNumAsText                                                                                :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

RPConstraint> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
RPConstraint> MATCH (EERR): <EMPTY>
RPConstraint> ERROR:
RPConstraint> offset=10:
RPConstraint> unexpected WHEN
RPConstraint> expecting other text or number

********** / RPBoolStructR                                                                                     :2_1:When:
*********** / $*|                                                                                             :2_1:When:
************ / slMultiTerm                                                                                   :2_1:When:
************* / someSL                                                                                      :2_1:When:
************** / pNumAsText                                                                                :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

RPBoolStructR> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
RPBoolStructR> MATCH (EERR): <EMPTY>
RPBoolStructR> ERROR:
RPBoolStructR> offset=10:
RPBoolStructR> unexpected WHEN
RPBoolStructR> expecting other text or number

********** / RPMT                                                                                              :2_1:When:
*********** / $*|                                                                                             :2_1:When:
************ / slAKA                                                                                         :2_1:When:
************* / $*|                                                                                         :2_1:When:
************** / slAKA base                                                                                :2_1:When:
*************** / slMultiTerm                                                                             :2_1:When:
**************** / someSL                                                                                :2_1:When:
***************** / pNumAsText                                                                          :2_1:When:
pNumAsText> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pNumAsText> MATCH (EERR): <EMPTY>
pNumAsText> ERROR:
pNumAsText> offset=10:
pNumAsText> unexpected WHEN
pNumAsText> expecting number

someSL> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someSL> MATCH (EERR): <EMPTY>
someSL> ERROR:
someSL> offset=10:
someSL> unexpected WHEN
someSL> expecting other text or number

slMultiTerm> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slMultiTerm> MATCH (EERR): <EMPTY>
slMultiTerm> ERROR:
slMultiTerm> offset=10:
slMultiTerm> unexpected WHEN
slMultiTerm> expecting other text or number

slAKA base> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slAKA base> MATCH (EERR): <EMPTY>
slAKA base> ERROR:
slAKA base> offset=10:
slAKA base> unexpected WHEN
slAKA base> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

slAKA> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slAKA> MATCH (EERR): <EMPTY>
slAKA> ERROR:
slAKA> offset=10:
slAKA> unexpected WHEN
slAKA> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

RPMT> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
RPMT> MATCH (EERR): <EMPTY>
RPMT> ERROR:
RPMT> offset=10:
RPMT> unexpected WHEN
RPMT> expecting other text or number

slRelPred> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
slRelPred> MATCH (EERR): <EMPTY>
slRelPred> ERROR:
slRelPred> offset=10:
slRelPred> unexpected WHEN
slRelPred> expecting other text or number

$*|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$*|> MATCH (EERR): <EMPTY>
$*|> ERROR:
$*|> offset=10:
$*|> unexpected WHEN
$*|> expecting other text or number

relPredSamelineWhen> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
relPredSamelineWhen> MATCH (EERR): <EMPTY>
relPredSamelineWhen> ERROR:
relPredSamelineWhen> offset=10:
relPredSamelineWhen> unexpected WHEN
relPredSamelineWhen> expecting other text or number

manyIndentation/leaf?> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
manyIndentation/leaf?> MATCH (EERR): <EMPTY>
manyIndentation/leaf?> ERROR:
manyIndentation/leaf?> offset=10:
manyIndentation/leaf?> unexpected WHEN
manyIndentation/leaf?> expecting other text or number

****** / manyIndentation/deeper; calling someIndentation                                                           :2_1:When:
******* / someIndentation                                                                                         :2_1:When:
******** / myindented: consuming GoDeeper                                                                        :2_1:When:
myindented: consuming GoDeeper> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=10:
myindented: consuming GoDeeper> unexpected WHEN
myindented: consuming GoDeeper> expecting (

someIndentation> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
someIndentation> MATCH (EERR): <EMPTY>
someIndentation> ERROR:
someIndentation> offset=10:
someIndentation> unexpected WHEN
someIndentation> expecting (

manyIndentation/deeper; calling someIndentation> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
manyIndentation/deeper; calling someIndentation> MATCH (EERR): <EMPTY>
manyIndentation/deeper; calling someIndentation> ERROR:
manyIndentation/deeper; calling someIndentation> offset=10:
manyIndentation/deeper; calling someIndentation> unexpected WHEN
manyIndentation/deeper; calling someIndentation> expecting (

pHornlike/someStructure> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pHornlike/someStructure> MATCH (EERR): <EMPTY>
pHornlike/someStructure> ERROR:
pHornlike/someStructure> offset=10:
pHornlike/someStructure> unexpected WHEN
pHornlike/someStructure> expecting (, DECIDE, DEFINE, or other text or number

pHornlike / permute> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pHornlike / permute> MATCH (EERR): <EMPTY>
pHornlike / permute> ERROR:
pHornlike / permute> offset=14:
pHornlike / permute> unexpected IS
pHornlike / permute> expecting (, ), GIVEN, Other text, UPON, expression, or other text or number

pHornlike> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pHornlike> MATCH (EERR): <EMPTY>
pHornlike> ERROR:
pHornlike> offset=14:
pHornlike> unexpected IS
pHornlike> expecting (, ), GIVEN, Other text, UPON, expression, other text or number, or §

*** / pRuleLabel                                                                                                      :2_1:When:
**** / $>|                                                                                                           :2_1:When:
$>|> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
$>|> MATCH (EERR): <EMPTY>
$>|> ERROR:
$>|> offset=10:
$>|> unexpected WHEN
$>|> expecting §

pRuleLabel> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pRuleLabel> MATCH (EERR): <EMPTY>
pRuleLabel> ERROR:
pRuleLabel> offset=10:
pRuleLabel> unexpected WHEN
pRuleLabel> expecting §

*** / pRule: unwrapping indentation and recursing                                                                     :2_1:When:
**** / myindented: consuming GoDeeper                                                                                :2_1:When:
myindented: consuming GoDeeper> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
myindented: consuming GoDeeper> MATCH (EERR): <EMPTY>
myindented: consuming GoDeeper> ERROR:
myindented: consuming GoDeeper> offset=10:
myindented: consuming GoDeeper> unexpected WHEN
myindented: consuming GoDeeper> expecting (

pRule: unwrapping indentation and recursing> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pRule: unwrapping indentation and recursing> MATCH (EERR): <EMPTY>
pRule: unwrapping indentation and recursing> ERROR:
pRule: unwrapping indentation and recursing> offset=10:
pRule: unwrapping indentation and recursing> unexpected WHEN
pRule: unwrapping indentation and recursing> expecting (

pRule> IN: WHEN ( "Z" ( IS ( "Q" ) ) ) AND ( "P" (  <…>
pRule> MATCH (EERR): <EMPTY>
pRule> ERROR:
pRule> offset=14:
pRule> unexpected IS
pRule> expecting DECIDE ... IS ... Horn rule, EOL, or regulative rule


revised parser
  horn-2 FAILED [1]

Failures:

  test/Spec.hs:124:3: 
  1) revised parser horn-2
       expected: [[Hornlike {name = ["X"], keyword = Decide, given = Nothing, upon = Nothing, clauses = [HC2 {hHead = RPConstraint ["X"] RPis ["Y"], hBody = Just (All Nothing [Leaf (RPConstraint ["Z"] RPis ["Q"]),Leaf (RPConstraint ["P"] RPgt ["NP"])])}], rlabel = Nothing, lsource = Nothing, srcref = Just (SrcRef {url = "test/Spec", short = "test/Spec", srcrow = 1, srccol = 1, version = Nothing}), defaults = [], symtab = []}]]
       but parsing failed with error:
       2:1:
       unexpected WHEN
       expecting end of input
       DECIDE X      IS     Y     
       ✳ WHEN Z      IS     Q     
       AND    P      >      NP    
       

  To rerun use: --match "/revised parser/horn-2/"

Randomized with seed 153969751

Finished in 0.0642 seconds
1 example, 1 failure

natural4> Test suite natural4-test failed
Test suite failure for package natural4-0.1.0.0
    natural4-test:  exited with: ExitFailure 1
Logs printed to console

